<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shared Event Countdowns</title>
  <style>
    :root {
      /* Typography Scale */
      --font-size-xs: 11px;
      --font-size-sm: 13px;
      --font-size-base: 15px;
      --font-size-lg: 18px;
      --font-size-xl: 22px;
      --font-size-2xl: 28px;
      --font-size-3xl: 36px;
      
      /* Font Weights */
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      
      /* Spacing Scale */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
      --space-10: 40px;
      
      /* Border Radius Scale */
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 14px;
      --radius-xl: 18px;
      
      /* Colors */
      --bg: #ffffff;
      --card: #ffffff;
      --text: #1a1a2e;
      --muted: #6b7280;
      --accent: #667eea;
      --accent2: #764ba2;
      --danger: #ef4444;
      --success: #10b981;
      --shadow: 0 2px 8px rgba(0,0,0,0.08);
      --shadow-hover: 0 4px 16px rgba(0,0,0,0.12);
      --border: #e5e7eb;
      --font: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --input-bg: #ffffff;
      --day-other: #fafafa;
      --day-hover: #f9fafb;
      --btn-secondary-bg: #f3f4f6;
      --btn-secondary-hover: #e5e7eb;
      --focus-ring: 0 0 0 3px rgba(102, 126, 234, 0.4);
    }

    body.dark {
      --bg: #0f172a;
      --card: #1e293b;
      --text: #f1f5f9;
      --muted: #94a3b8;
      --border: #334155;
      --shadow: 0 2px 8px rgba(0,0,0,0.3);
      --shadow-hover: 0 4px 16px rgba(0,0,0,0.4);
      --input-bg: #1e293b;
      --day-other: #1a2535;
      --day-hover: #273548;
      --btn-secondary-bg: #334155;
      --btn-secondary-hover: #475569;
      --focus-ring: 0 0 0 3px rgba(102, 126, 234, 0.5);
    }

    /* Accessibility: Focus visible */
    :focus-visible {
      outline: none;
      box-shadow: var(--focus-ring);
    }
    
    /* Reduced motion for users who prefer it */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Priority Colors */
    .priority-urgent { --priority-color: #ef4444; --priority-bg: #fef2f2; }
    .priority-high { --priority-color: #f97316; --priority-bg: #fff7ed; }
    .priority-medium { --priority-color: #eab308; --priority-bg: #fefce8; }
    .priority-low { --priority-color: #22c55e; --priority-bg: #f0fdf4; }
    .priority-none { --priority-color: #6b7280; --priority-bg: var(--day-other); }
    if (!nextDate) return;
    pushTaskClone(task, { dueDate: nextDate.toISOString(), completed: false });

  // Toggle overlays - menu buttons switch between views
    }

    .btn {
      padding: var(--space-3) var(--space-6);
      border: none;
      border-radius: var(--radius-md);
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
      box-shadow: 0 4px 12px rgba(102,126,234,0.3);
    }
    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(102,126,234,0.4);
    }
    .btn-primary:active { transform: translateY(0); }
    .btn-ghost {
      background: #fef2f2;
      color: var(--danger);
    }
    .btn-ghost:hover { background: #fee2e2; }
    .btn-cancel {
      background: var(--btn-secondary-bg);
      color: var(--muted);
      display: none;
    }
    .btn-cancel:hover { background: var(--btn-secondary-hover); }

    .event-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .event-list.loading .event-row {
      display: none;
    }
    .event-skeleton {
      display: grid;
      gap: 12px;
    }
    .event-skeleton-row {
      height: 78px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      background: linear-gradient(90deg, var(--day-other), var(--day-hover), var(--day-other));
      background-size: 200% 100%;
      animation: shimmer 1.2s ease-in-out infinite;
    }
    @keyframes shimmer {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .event-row {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      box-shadow: var(--shadow);
      transition: transform 0.15s, box-shadow 0.15s, background 0.2s;
    }
    .event-row:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: #d1d5db;
    }
    .event-row.highlighted {
      border: 2px solid;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }

    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .event-info {
      flex: 1;
      min-width: 0;
      text-align: right;
    }
    .event-name {
      font-size: 17px;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .event-date {
      font-size: 13px;
      color: var(--muted);
      margin-top: 3px;
    }

    /* Inline editing helpers */
    .inline-edit-input {
      font: inherit;
      color: var(--text);
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 6px 8px;
      min-width: 160px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .inline-edit-input:focus {
      outline: 2px solid var(--accent);
      border-color: var(--accent);
    }
    .inline-edit-input.small { min-width: 120px; }

    .priority-popover {
      position: fixed;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-hover);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 9999;
      min-width: 180px;
    }
    .priority-popover button {
      padding: 10px 12px;
      background: transparent;
      border: none;
      text-align: right;
      font: inherit;
      cursor: pointer;
    }
    .priority-popover button:hover { background: var(--btn-secondary-bg); }

    .conflict-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--danger);
      font-size: 13px;
      font-weight: 600;
    }
    .conflict-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--danger);
      display: inline-block;
      box-shadow: 0 0 0 4px rgba(239,68,68,0.18);
    }

    

    /* Pomodoro - Fullscreen like Task Manager */
    .pomodoro-overlay {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      display: none;
      flex-direction: column;
      z-index: 300;
      overflow: hidden;
    }
    .pomodoro-overlay.open { display: flex; }
    
    .pomodoro-header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 32px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-bottom: 1px solid var(--border);
    }
    
    .pomodoro-header-title {
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    @media (max-width: 768px) {
      .event-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      .event-actions {
        width: 100%;
        justify-content: flex-end;
      }
      .timer {
        width: 100%;
        justify-content: space-between;
      }
      .event-info { width: 100%; }
      
      /* Responsive Pomodoro */
      .pomodoro-card { padding: 24px; gap: 24px; border-radius: 24px; }
      .pomodoro-timer-wrap { width: 240px; height: 240px; }
      .pomodoro-time { font-size: 52px; }
      .pomodoro-btn { width: 52px; height: 52px; font-size: 20px; }
      .pomodoro-btn.primary { width: 64px; height: 64px; font-size: 28px; }
      .pomodoro-settings-panel { grid-template-columns: repeat(2, 1fr); }
      .pomodoro-stats { grid-template-columns: repeat(3, 1fr); gap: 8px; }
      .pomodoro-stat { padding: 16px 8px; }
      .pomodoro-stat .value { font-size: 24px; }
      .pomodoro-presets { gap: 8px; }
      .pomodoro-preset { padding: 10px 16px; font-size: 12px; }
      .pomodoro-header-bar { padding: 12px 16px; }
      .pomodoro-content { padding: 20px 16px; }
    }
    
    .pomodoro-container {
      width: 100%;
      max-width: 600px;
    }
    
    .pomodoro-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 32px;
      padding: 40px 32px;
      box-shadow: 0 20px 60px rgba(102, 126, 234, 0.15), 0 0 0 1px rgba(255,255,255,0.1) inset;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 32px;
      overflow: visible;
    }
    
    /* Timer Circle */
    .pomodoro-timer-wrap {
      position: relative;
      width: 280px;
      height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .pomodoro-timer-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: conic-gradient(
        from 0deg,
        var(--accent) 0%,
        var(--accent2) var(--progress, 0%),
        var(--border) var(--progress, 0%),
        var(--border) 100%
      );
      padding: 8px;
    }
    
    .pomodoro-timer-ring::before {
      content: '';
      position: absolute;
      inset: 8px;
      background: var(--card);
      border-radius: 50%;
    }
    
    .pomodoro-timer {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    
    .pomodoro-time {
      font-size: 64px;
      font-weight: 300;
      letter-spacing: -2px;
      color: var(--text);
      font-variant-numeric: tabular-nums;
      line-height: 1;
      text-shadow: 0 2px 20px rgba(102, 126, 234, 0.2);
    }
    
    .pomodoro-mode {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
      margin-top: 16px;
      text-transform: uppercase;
      letter-spacing: 3px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .pomodoro-mode-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }
    
    .pomodoro-next {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }
    
    /* Controls */
    .pomodoro-controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: center;
    }
    
    .pomodoro-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      backdrop-filter: blur(10px);
      color: var(--text);
      font-size: 22px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2);
      position: relative;
      overflow: hidden;
    }
    
    .pomodoro-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      padding: 2px;
      background: linear-gradient(135deg, rgba(102,126,234,0.3), rgba(118,75,162,0.3));
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }
    
    .pomodoro-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(102,126,234,0.3), inset 0 1px 0 rgba(255,255,255,0.3);
    }
    
    .pomodoro-btn:active {
      transform: translateY(0) scale(0.98);
    }
    
    .pomodoro-btn.primary {
      width: 72px;
      height: 72px;
      font-size: 28px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4), 0 0 0 4px rgba(102,126,234,0.15);
    }
    
    .pomodoro-btn.primary::before {
      display: none;
    }
    
    .pomodoro-btn.primary:hover {
      transform: translateY(-4px) scale(1.08);
      box-shadow: 0 12px 40px rgba(102, 126, 234, 0.5), 0 0 0 6px rgba(102,126,234,0.2);
    }
    
    /* Presets */
    .pomodoro-presets {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .pomodoro-preset {
      padding: 12px 24px;
      border-radius: 24px;
      border: 2px solid var(--border);
      background: transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      transition: all 0.2s;
    }
    
    .pomodoro-preset:hover {
      color: var(--text);
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .pomodoro-preset.active {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border-color: transparent;
      color: white;
      box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
    }
    
    /* Settings Panel */
    .pomodoro-settings-panel {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      padding: 24px;
      background: var(--btn-secondary-bg);
      border-radius: 20px;
      width: 100%;
      max-width: 500px;
    }
    
    .pomodoro-field {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }
    
    .pomodoro-field label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .pomodoro-field input {
      width: 70px;
      padding: 12px;
      border: 2px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      color: var(--text);
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      transition: all 0.2s;
    }
    
    .pomodoro-field input:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    /* Options Row */
    .pomodoro-options {
      display: flex;
      gap: 24px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .pomodoro-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 20px;
      background: var(--btn-secondary-bg);
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pomodoro-option:hover {
      background: var(--btn-secondary-hover);
    }
    
    .pomodoro-option input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .pomodoro-option label {
      font-size: 14px;
      color: var(--text);
      cursor: pointer;
    }
    
    .pomodoro-sound-select {
      padding: 12px 16px;
      border: 2px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
    }
    
    .pomodoro-preview-btn {
      padding: 12px 16px;
      border: 2px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pomodoro-preview-btn:hover {
      border-color: var(--accent);
      background: var(--btn-secondary-bg);
    }
    
    /* Stats Cards */
    .pomodoro-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      width: 100%;
      max-width: 500px;
    }
    
    .pomodoro-stat {
      padding: 24px 16px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-radius: 20px;
      text-align: center;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }
    
    .pomodoro-stat .label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .pomodoro-stat .value {
      font-size: 32px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Day Progress */
    .pomodoro-daily {
      width: 100%;
      max-width: 500px;
      text-align: center;
    }
    
    .pomodoro-daily-bar {
      height: 8px;
      background: var(--border);
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 12px;
    }
    
    .pomodoro-daily-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #10b981, #22d3ee);
      border-radius: 999px;
      transition: width 0.5s ease;
    }
    
    .pomodoro-daily-label {
      font-size: 13px;
      color: var(--muted);
    }
    
    /* Task Select */
    .pomodoro-task-select {
      width: 100%;
      max-width: 400px;
      padding: 14px 20px;
      border: 2px solid var(--border);
      border-radius: 16px;
      background: var(--card);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pomodoro-task-select:focus {
      border-color: var(--accent);
      outline: none;
    }

    /* Pomodoro Mini Player */
    .pomodoro-mini {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 16px 24px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      display: none;
      align-items: center;
      gap: 16px;
      z-index: 9999;
      cursor: pointer;
      transition: all 0.3s;
    }
    .pomodoro-mini.visible { display: flex; }
    .pomodoro-mini:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.25);
    }
    .pomodoro-mini-time {
      font-size: 28px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .pomodoro-mini-mode {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .pomodoro-mini-close {
      border: none;
      background: var(--btn-secondary-bg);
      color: var(--muted);
      font-size: 18px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .pomodoro-mini-close:hover {
      background: var(--danger);
      color: white;
    }

    @media (max-width: 768px) {
      .event-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      .event-actions {
        width: 100%;
        justify-content: flex-end;
      }
      .timer {
        width: 100%;
        justify-content: space-between;
      }
      .event-info { width: 100%; }
      
      /* Responsive Pomodoro */
      .pomodoro-card { padding: 24px; gap: 24px; border-radius: 24px; }
      .pomodoro-timer-wrap { width: 240px; height: 240px; }
      .pomodoro-time { font-size: 52px; }
      .pomodoro-btn { width: 52px; height: 52px; font-size: 20px; }
      .pomodoro-btn.primary { width: 64px; height: 64px; font-size: 28px; }
      .pomodoro-settings-panel { grid-template-columns: repeat(2, 1fr); }
      .pomodoro-stats { grid-template-columns: repeat(3, 1fr); gap: 8px; }
      .pomodoro-stat { padding: 16px 8px; }
      .pomodoro-stat .value { font-size: 24px; }
      .pomodoro-presets { gap: 8px; }
      .pomodoro-preset { padding: 10px 16px; font-size: 12px; }
      .pomodoro-header-bar { padding: 12px 16px; }
      .pomodoro-content { padding: 20px 16px; }
    }

    /* Pomodoro - Fullscreen like Task Manager */
    .pomodoro-overlay {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      display: none;
      flex-direction: column;
      z-index: 300;
      overflow: hidden;
    }
    .pomodoro-overlay.open { display: flex; }
    
    .pomodoro-header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 32px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-bottom: 1px solid var(--border);
    }
    
    .pomodoro-header-title {
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .pomodoro-content {
      flex: 1;
      overflow-y: auto;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 40px 24px;
      background: linear-gradient(180deg, transparent 0%, rgba(102, 126, 234, 0.03) 100%);
    }
    
    .pomodoro-container {
      width: 100%;
      max-width: 600px;
    }
    
    .pomodoro-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 32px;
      padding: 40px 32px;
      box-shadow: 0 20px 60px rgba(102, 126, 234, 0.15), 0 0 0 1px rgba(255,255,255,0.1) inset;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 32px;
      overflow: visible;
    }
    
    /* Timer Circle */
    .pomodoro-timer-wrap {
      position: relative;
      width: 280px;
      height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .pomodoro-timer-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: conic-gradient(
        from 0deg,
        var(--accent) 0%,
        var(--accent2) var(--progress, 0%),
        var(--border) var(--progress, 0%),
        var(--border) 100%
      );
      padding: 8px;
    }
    
    .pomodoro-timer-ring::before {
      content: '';
      position: absolute;
      inset: 8px;
      background: var(--card);
      border-radius: 50%;
    }
    
    .pomodoro-timer {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    
    .pomodoro-time {
      font-size: 64px;
      font-weight: 300;
      letter-spacing: -2px;
      color: var(--text);
      font-variant-numeric: tabular-nums;
      line-height: 1;
      text-shadow: 0 2px 20px rgba(102, 126, 234, 0.2);
    }
    
    .pomodoro-mode {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
      margin-top: 16px;
      text-transform: uppercase;
      letter-spacing: 3px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .pomodoro-mode-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }
    
    .pomodoro-next {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }
    
    /* Controls */
    .pomodoro-controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: center;
    }
    
    .pomodoro-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      backdrop-filter: blur(10px);
      color: var(--text);
      font-size: 22px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2);
      position: relative;
      overflow: hidden;
    }
    
    .pomodoro-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      padding: 2px;
      background: linear-gradient(135deg, rgba(102,126,234,0.3), rgba(118,75,162,0.3));
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }
    
    .pomodoro-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(102,126,234,0.3), inset 0 1px 0 rgba(255,255,255,0.3);
    }
    
    .pomodoro-btn:active {
      transform: translateY(0) scale(0.98);
    }
    
    .pomodoro-btn.primary {
      width: 72px;
      height: 72px;
      font-size: 28px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4), 0 0 0 4px rgba(102,126,234,0.15);
    }
    
    .pomodoro-btn.primary::before {
      display: none;
    }
    
    .pomodoro-btn.primary:hover {
      transform: translateY(-4px) scale(1.08);
      box-shadow: 0 12px 40px rgba(102, 126, 234, 0.5), 0 0 0 6px rgba(102,126,234,0.2);
    }
    
    /* Presets */
    .pomodoro-presets {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .pomodoro-preset {
      padding: 12px 24px;
      border-radius: 24px;
      border: 2px solid var(--border);
      background: transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      transition: all 0.2s;
    }
    
    .pomodoro-preset:hover {
      color: var(--text);
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .pomodoro-preset.active {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border-color: transparent;
      color: white;
      box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
    }
    
    /* Settings Panel */
    .pomodoro-settings-panel {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      padding: 24px;
      background: var(--btn-secondary-bg);
      border-radius: 20px;
      width: 100%;
      max-width: 500px;
    }
    
    .pomodoro-field {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }
    
    .pomodoro-field label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .pomodoro-field input {
      width: 70px;
      padding: 12px;
      border: 2px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      color: var(--text);
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      transition: all 0.2s;
    }
    
    .pomodoro-field input:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    /* Options Row */
    .pomodoro-options {
      display: flex;
      gap: 24px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .pomodoro-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 20px;
      background: var(--btn-secondary-bg);
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pomodoro-option:hover {
      background: var(--btn-secondary-hover);
    }
    
    .pomodoro-option input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .pomodoro-option label {
      font-size: 14px;
      color: var(--text);
      cursor: pointer;
    }
    
    .pomodoro-sound-select {
      padding: 12px 16px;
      border: 2px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
    }
    
    .pomodoro-preview-btn {
      padding: 12px 16px;
      border: 2px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pomodoro-preview-btn:hover {
      border-color: var(--accent);
      background: var(--btn-secondary-bg);
    }
    
    /* Stats Cards */
    .pomodoro-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      width: 100%;
      max-width: 500px;
    }
    
    .pomodoro-stat {
      padding: 24px 16px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-radius: 20px;
      text-align: center;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }
    
    .pomodoro-stat .label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .pomodoro-stat .value {
      font-size: 32px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Day Progress */
    .pomodoro-daily {
      width: 100%;
      max-width: 500px;
      text-align: center;
    }
    
    .pomodoro-daily-bar {
      height: 8px;
      background: var(--border);
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 12px;
    }
    
    .pomodoro-daily-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #10b981, #22d3ee);
      border-radius: 999px;
      transition: width 0.5s ease;
    }
    
    .pomodoro-daily-label {
      font-size: 13px;
      color: var(--muted);
    }
    
    /* Task Select */
    .pomodoro-task-select {
      width: 100%;
      max-width: 400px;
      padding: 14px 20px;
      border: 2px solid var(--border);
      border-radius: 16px;
      background: var(--card);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .pomodoro-task-select:focus {
      border-color: var(--accent);
      outline: none;
    }

    /* Pomodoro Mini Player */
    .pomodoro-mini {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 16px 24px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      display: none;
      align-items: center;
      gap: 16px;
      z-index: 9999;
      cursor: pointer;
      transition: all 0.3s;
    }
    .pomodoro-mini.visible { display: flex; }
    .pomodoro-mini:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.25);
    }
    .pomodoro-mini-time {
      font-size: 28px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .pomodoro-mini-mode {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .pomodoro-mini-close {
      border: none;
      background: var(--btn-secondary-bg);
      color: var(--muted);
      font-size: 18px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .pomodoro-mini-close:hover {
      background: var(--danger);
      color: white;
    }

    .star-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      color: #d1d5db;
      font-size: 22px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .star-btn:hover {
      background: #fef3c7;
      color: #f59e0b;
      transform: scale(1.1);
    }
    .star-btn.active {
      color: #f59e0b;
    }

    .pin-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      color: #9ca3af;
      font-size: 20px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      opacity: 0.25;
    }
    .pin-btn:hover {
      background: #dbeafe;
      color: #3b82f6;
      transform: scale(1.1);
      opacity: 0.6;
    }
    .pin-btn.pinned {
      color: #3b82f6;
      opacity: 1;
    }
    .pin-btn.pinned:hover {
      opacity: 1;
    }

    .edit-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: #9ca3af;
      font-size: 16px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .edit-btn:hover {
      background: #eff6ff;
      color: var(--accent);
      transform: scale(1.1);
    }

    .timer {
      display: flex;
      gap: 8px;
    }
    .time-unit {
      text-align: center;
      background: var(--day-other);
      border-radius: 8px;
      padding: 8px 12px;
      min-width: 60px;
      transition: all 0.2s;
    }
    .time-unit:hover {
      background: var(--day-hover);
      transform: translateY(-1px);
    }
    .time-val {
      display: block;
      font-size: 22px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      line-height: 1.2;
    }
    .time-label {
      display: block;
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 3px;
    }

    .badge {
      font-size: 11px;
      font-weight: 600;
      padding: 5px 10px;
      border-radius: 20px;
      white-space: nowrap;
    }
    .badge-upcoming {
      background: #ecfdf5;
      color: #059669;
    }
    .badge-ended {
      background: #fef2f2;
      color: #dc2626;
    }

    .delete-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: #9ca3af;
      font-size: 20px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .delete-btn:hover {
      background: #fef2f2;
      color: var(--danger);
      transform: scale(1.1);
    }

    .event-actions {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      color: var(--muted);
      display: none;
    }
    .empty-state svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      opacity: 0.4;
    }
    .empty-state p {
      font-size: 14px;
    }

    .input-panel.editing {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(102,126,234,0.15);
    }

    /* Undo toast */
    .undo-toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 220;
      display: none;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
      border-radius: 12px;
      box-shadow: var(--shadow-hover);
      font-size: 14px;
    }
    .undo-toast.show { display: flex; }
    .undo-toast button {
      border: none;
      background: rgba(255,255,255,0.2);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.15s;
    }
    .undo-toast button:hover { background: rgba(255,255,255,0.3); }

    /* Clear confirmation modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 16px;
    }
    .modal-backdrop.open { display: flex; }
    .modal-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      max-width: 420px;
      width: 100%;
      box-shadow: var(--shadow-hover);
      text-align: center;
    }
    .modal-card h3 {
      font-size: 18px;
      margin-bottom: 8px;
      color: var(--text);
    }
    .modal-card p {
      color: var(--muted);
      margin-bottom: 16px;
      line-height: 1.4;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .modal-actions .btn {
      padding: var(--space-3) var(--space-4);
    }
    .btn-danger {
      background: var(--danger);
      color: white;
    }
    .btn-danger:hover {
      background: #dc2626;
    }

    /* Shortcut cheat sheet */
    .shortcuts-backdrop {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(102,126,234,0.25), rgba(15,23,42,0.65));
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 12000;
      padding: 20px;
      backdrop-filter: blur(8px);
    }
    .shortcuts-backdrop.open { display: flex; }
    .shortcuts-card {
      width: min(760px, 100%);
      background: var(--card);
      border-radius: 22px;
      border: 1px solid rgba(102,126,234,0.35);
      box-shadow: 0 24px 70px rgba(15,23,42,0.35), 0 0 0 1px rgba(255,255,255,0.25) inset;
      overflow: hidden;
      direction: rtl;
    }
    .shortcuts-hero {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 22px 26px 18px;
      background: linear-gradient(135deg, rgba(102,126,234,0.18), rgba(118,75,162,0.12));
      border-bottom: 1px solid var(--border);
    }
    .shortcuts-eyebrow {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .shortcuts-title {
      font-size: 22px;
      font-weight: 700;
      margin-top: 6px;
    }
    .shortcuts-subtitle {
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }
    .shortcuts-close {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--day-other);
      color: var(--text);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shortcuts-close:hover {
      background: var(--day-hover);
      transform: translateY(-1px);
    }
    .shortcuts-body {
      padding: 20px 26px 26px;
    }
    .shortcuts-section {
      margin-bottom: 18px;
    }
    .shortcuts-section:last-child { margin-bottom: 0; }
    .shortcuts-section-title {
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      margin-bottom: 10px;
    }
    .shortcuts-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px 16px;
    }
    .shortcut-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--day-other);
      border: 1px solid var(--border);
    }
    .shortcut-label {
      font-size: 14px;
      color: var(--text);
    }
    .shortcut-keys {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      direction: ltr;
    }
    .keycap {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      font-size: 12px;
      font-weight: 700;
      color: var(--text);
      text-transform: uppercase;
    }
    .keycap.wide { min-width: 44px; }
    .shortcut-note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 12px;
    }

    @media (max-width: 640px) {
      .shortcuts-grid { grid-template-columns: 1fr; }
      .shortcuts-hero { flex-direction: column; align-items: flex-start; }
      .shortcuts-close { align-self: flex-end; }
    }
    
    /* Day Drawer/Popover */
    .day-drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 250;
      padding: var(--space-4);
      backdrop-filter: blur(2px);
    }
    .day-drawer-backdrop.open { display: flex; }
    
    .day-drawer {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      width: 100%;
      max-width: 420px;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: var(--shadow-hover);
      display: flex;
      flex-direction: column;
      direction: rtl;
      animation: drawerSlideIn 0.25s ease-out;
    }
    @keyframes drawerSlideIn {
      from { opacity: 0; transform: scale(0.95) translateY(10px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }
    
    .day-drawer-header {
      padding: var(--space-5);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
    }
    .day-drawer-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
    }
    .day-drawer-subtitle {
      font-size: var(--font-size-sm);
      opacity: 0.9;
      margin-top: var(--space-1);
    }
    .day-drawer-close {
      background: rgba(255,255,255,0.2);
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      font-size: var(--font-size-lg);
      cursor: pointer;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    .day-drawer-close:hover {
      background: rgba(255,255,255,0.3);
    }
    
    .day-drawer-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-4);
    }
    
    .day-drawer-section {
      margin-bottom: var(--space-5);
    }
    .day-drawer-section:last-child {
      margin-bottom: 0;
    }
    .day-drawer-section-title {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-3);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    .day-drawer-section-title .count {
      background: var(--accent);
      color: white;
      font-size: var(--font-size-xs);
      padding: 2px 8px;
      border-radius: 10px;
    }
    
    .day-drawer-empty {
      color: var(--muted);
      font-size: var(--font-size-sm);
      text-align: center;
      padding: var(--space-4);
      background: var(--day-other);
      border-radius: var(--radius-md);
    }
    
    .day-drawer-item {
      padding: var(--space-3);
      background: var(--day-other);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-2);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      cursor: pointer;
      transition: all 0.15s;
      border-right: 3px solid transparent;
    }
    .day-drawer-item:hover {
      background: var(--day-hover);
      border-right-color: var(--accent);
    }
    .day-drawer-item:last-child {
      margin-bottom: 0;
    }
    
    .day-drawer-item-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .day-drawer-item-info {
      flex: 1;
      min-width: 0;
    }
    .day-drawer-item-name {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .day-drawer-item-time {
      font-size: var(--font-size-xs);
      color: var(--muted);
      margin-top: 2px;
    }
    .day-drawer-item-priority {
      font-size: var(--font-size-xs);
      padding: 2px var(--space-2);
      border-radius: var(--radius-sm);
      font-weight: var(--font-weight-medium);
    }
    .day-drawer-item.task-completed .day-drawer-item-name {
      text-decoration: line-through;
      opacity: 0.6;
    }
    
    .day-drawer-actions {
      padding: var(--space-4);
      border-top: 1px solid var(--border);
      display: flex;
      gap: var(--space-2);
    }
    .day-drawer-actions .btn {
      flex: 1;
      padding: var(--space-3) var(--space-4);
      font-size: var(--font-size-sm);
    }

    /* Notes/Description */
    .input-row-notes {
      margin-top: 12px;
    }
    .input-row-notes textarea {
      width: 100%;
      padding: 12px 14px;
      border: 2px solid var(--border);
      border-radius: 10px;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
      min-height: 60px;
      max-height: 150px;
      outline: none;
      direction: rtl;
      text-align: right;
      background: var(--input-bg);
      color: var(--text);
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .input-row-notes textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(102,126,234,0.15);
    }
    .event-notes {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .event-notes.expanded {
      max-height: none;
    }
    .notes-toggle {
      font-size: 11px;
      color: var(--accent);
      cursor: pointer;
      margin-top: 2px;
      display: inline-block;
    }
    .notes-toggle:hover {
      text-decoration: underline;
    }

    /* Task Manager Fullscreen Modal */
    .task-manager-overlay {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      z-index: 300;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }
    .task-manager-overlay.open {
      display: flex;
    }
    
    .task-manager-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-4) var(--space-6);
      background: var(--card);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
      gap: var(--space-4);
      flex-wrap: wrap;
    }
    
    .task-manager-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .task-manager-close {
      width: 40px;
      height: 40px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--card);
      color: var(--text);
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .task-manager-close:hover {
      background: #fef2f2;
      color: var(--danger);
    }
    
    .task-search-bar {
      flex: 1;
      max-width: 500px;
      position: relative;
    }
    .task-search-bar input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      border: 2px solid var(--border);
      border-radius: 10px;
      font-size: 15px;
      background: var(--input-bg);
      color: var(--text);
      outline: none;
      transition: all 0.2s;
    }
    .task-search-bar input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(102,126,234,0.15);
    }
    .task-search-bar::before {
      content: 'üîç';
      position: absolute;
      left: 14px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
    }
    
    .task-manager-body {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
    }
    
    /* Quick Add Task */
    .quick-add-task {
      max-width: 600px;
      margin: 0 auto 32px auto;
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: var(--shadow);
      transition: all 0.2s;
    }
    .quick-add-task:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(102,126,234,0.15);
    }
    .quick-add-task input[type="text"] {
      width: 100%;
      border: none;
      font-size: 16px;
      padding: 8px 0;
      background: transparent;
      color: var(--text);
      outline: none;
    }
    .quick-add-task input[type="text"]::placeholder {
      color: var(--muted);
    }
    .quick-add-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .quick-add-row .btn {
      padding: 10px 18px;
      font-size: 14px;
    }
    
    /* Color Picker */
    .color-picker {
      display: flex;
      gap: 6px;
    }
    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: all 0.15s;
    }
    .color-option:hover {
      transform: scale(1.15);
    }
    .color-option.selected {
      border-color: var(--text);
      box-shadow: 0 0 0 2px var(--card);
    }
    
    /* Label/Tag Input */
    .label-input-wrapper {
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--day-other);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
    }
    .label-input-wrapper input {
      border: none;
      background: transparent;
      font-size: 13px;
      width: 80px;
      color: var(--text);
      outline: none;
    }
    
    /* Task List */
    .task-sections {
      max-width: 900px;
      margin: 0 auto;
    }
    .task-section-title {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: var(--space-4);
      padding-left: var(--space-2);
    }
    .task-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      margin-bottom: var(--space-8);
    }
    
    /* Task Item (List style) */
    .task-item {
      background-color: var(--card);
      background-image: linear-gradient(90deg, var(--task-tint, var(--subject-tint, transparent)), transparent 55%);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4) var(--space-5);
      box-shadow: var(--shadow);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: var(--space-4);
      border-left: 4px solid var(--priority-color, var(--border));
    }
    .task-item.dragging {
      opacity: 0.55;
      cursor: grabbing;
    }
    .task-item:hover {
      box-shadow: var(--shadow-hover);
      background-color: var(--priority-bg, var(--card));
    }
    .task-item.completed {
      opacity: 0.6;
      background-color: var(--day-other);
    }
    
    .task-checkbox {
      width: 24px;
      height: 24px;
      border: 2px solid var(--priority-color, var(--border));
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s;
      background: transparent;
      color: transparent;
      font-size: var(--font-size-sm);
    }
    .task-checkbox:hover {
      background: var(--priority-bg, var(--day-hover));
    }
    .task-item.completed .task-checkbox {
      background: var(--priority-color, var(--success));
      border-color: var(--priority-color, var(--success));
      color: white;
    }
    
    .task-main {
      flex: 1;
      min-width: 0;
      cursor: pointer;
    }
    .task-title-row {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      margin-bottom: var(--space-1);
    }
    .task-title {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      color: var(--text);
      word-break: break-word;
    }
    .task-color-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      box-shadow: 0 0 0 2px var(--card);
      flex-shrink: 0;
    }
    .task-item.completed .task-title {
      text-decoration: line-through;
      color: var(--muted);
    }
    .task-priority-badge {
      font-size: 10px;
      font-weight: var(--font-weight-bold);
      padding: 3px var(--space-2);
      border-radius: var(--radius-lg);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: var(--priority-color);
      color: white;
      flex-shrink: 0;
    }
    
    .task-meta {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      flex-wrap: wrap;
    }
    .task-due {
      font-size: var(--font-size-sm);
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: var(--space-1);
    }
    .task-due.overdue {
      color: var(--danger);
      font-weight: var(--font-weight-semibold);
    }
    .task-due.soon {
      color: #f97316;
      font-weight: var(--font-weight-semibold);
    }
    .task-countdown {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-lg);
      background: var(--day-other);
      color: var(--text);
      font-variant-numeric: tabular-nums;
    }
    .task-countdown.overdue {
      background: #fef2f2;
      color: var(--danger);
    }
    .task-countdown.soon {
      background: #fff7ed;
      color: #f97316;
    }
    .task-recurrence {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-lg);
      background: color-mix(in srgb, var(--accent) 14%, var(--day-other));
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .task-subtasks {
      margin-top: var(--space-2);
      padding-top: var(--space-2);
      border-top: 1px dashed var(--border);
    }
    .task-subtask {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 14px;
      color: var(--text);
    }
    .task-subtask input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    .task-subtask.checked span {
      text-decoration: line-through;
      color: var(--muted);
    }
    .task-subtask-progress {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    
    .task-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
    }
    .task-action-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 16px;
      cursor: pointer;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    .task-action-btn:hover {
      background: var(--day-hover);
      color: var(--text);
    }
    .task-action-btn.delete:hover {
      background: #fef2f2;
      color: var(--danger);
    }
    
    /* Task Edit Modal */
    .task-edit-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 400;
      padding: 20px;
    }
    .task-edit-modal.open {
      display: flex;
    }
    .task-edit-card {
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .task-edit-card input[type="text"],
    .task-edit-card textarea {
      width: 100%;
      border: none;
      background: transparent;
      color: var(--text);
      outline: none;
      resize: none;
    }
    .task-edit-card input[type="text"] {
      font-size: 20px;
      font-weight: 600;
      padding: 8px 0;
    }
    .task-edit-card textarea {
      font-size: 15px;
      line-height: 1.6;
      min-height: 150px;
      margin-top: 16px;
    }
    
    .task-edit-section {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .task-edit-section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 12px;
    }
    
    .checklist-add {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 12px;
    }
    .checklist-add input {
      flex: 1;
      padding: 10px 14px;
      border: 2px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      background: var(--input-bg);
      color: var(--text);
      outline: none;
    }
    .checklist-add input:focus {
      border-color: var(--accent);
    }
    
    .task-edit-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
      gap: 12px;
    }
    
    /* Empty Tasks State */
    .tasks-empty {
      text-align: center;
      padding: 60px 20px;
      color: var(--muted);
    }
    .tasks-empty-icon {
      font-size: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    .tasks-empty h3 {
      font-size: 20px;
      color: var(--text);
      margin-bottom: 8px;
    }
    .tasks-empty p {
      font-size: 14px;
    }
    
    /* Suggested Tasks Banner */
    .suggested-tasks-banner {
      background: linear-gradient(135deg, rgba(102,126,234,0.1), rgba(118,75,162,0.1));
      border: 1px solid var(--accent);
      border-radius: 10px;
      padding: 12px 16px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      color: var(--text);
    }
    .suggested-tasks-banner .suggested-icon {
      font-size: 18px;
    }
    
    /* Task Subject Tag (when showing suggested) */
    .task-subject-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: rgba(102,126,234,0.15);
      color: var(--accent);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
      margin-left: 8px;
    }
    .task-subject-tag .tag-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }
    
    /* Filter Pills */
    .task-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .filter-pill {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--card);
      color: var(--muted);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }
    .filter-pill:hover {
      background: var(--day-hover);
    }
    .filter-pill.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    /* Priority Selector */
    .priority-selector {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .priority-option {
      padding: 8px 16px;
      border: 2px solid transparent;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .priority-option:hover {
      transform: scale(1.05);
    }
    .priority-option.selected {
      border-color: var(--text);
    }
    .priority-option[data-priority="urgent"] { background: #fef2f2; color: #ef4444; }
    .priority-option[data-priority="high"] { background: #fff7ed; color: #f97316; }
    .priority-option[data-priority="medium"] { background: #fefce8; color: #eab308; }
    .priority-option[data-priority="low"] { background: #f0fdf4; color: #22c55e; }
    .priority-option[data-priority="none"] { background: var(--day-other); color: var(--muted); }
    
    /* Task Checklist in Edit Modal */
    .task-checklist {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .task-checklist-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      padding: 8px 0;
    }
    .task-checklist-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    .task-checklist-item.checked span {
      text-decoration: line-through;
      color: var(--muted);
    }

    .task-color-picker {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .task-color-picker.compact {
      gap: 6px;
    }
    .task-color-option {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: var(--muted);
      background: var(--day-other);
    }
    .task-color-option.subject {
      font-weight: 700;
      color: #fff;
      border-style: dashed;
    }
    .task-color-option.disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .task-color-picker.compact .task-color-option {
      width: 22px;
      height: 22px;
      font-size: 10px;
    }
    .task-color-option.none {
      color: var(--muted);
      background: var(--day-other);
      border-color: var(--border);
    }
    .task-color-option:hover {
      transform: scale(1.12);
    }
    .task-color-option.selected {
      border-color: var(--text);
      box-shadow: 0 0 0 2px var(--card);
    }
    
    
    .subject-tab {
      padding: 8px 16px;
      border: 2px solid var(--border);
      border-radius: 20px;
      background: var(--card);
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
    }
    .subject-tab:hover {
      background: var(--day-hover);
      border-color: var(--accent);
    }
    .subject-tab.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .subject-tab.smart-view {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
      border: none;
    }
    .subject-tab.smart-view:not(.active) {
      background: var(--day-other);
      color: var(--muted);
    }
    .subject-tab .tab-count {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      background: rgba(255,255,255,0.25);
      min-width: 18px;
      text-align: center;
    }
    .subject-tab:not(.active) .tab-count {
      background: var(--day-other);
      color: var(--muted);
    }
    .subject-tab .tab-color,
    .subject-tab-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    /* Smart Views Section */
    .smart-views-section {
      display: flex;
      gap: 6px;
      padding-right: 12px;
      border-right: 1px solid var(--border);
      margin-right: 4px;
    }
    
    /* Subject with sub-subjects */
    .subject-tab.has-children .subject-tab-inner {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .subject-tab .expand-arrow {
      font-size: 8px;
      transition: transform 0.2s;
      opacity: 0.7;
    }
    .subject-tab.expanded .expand-arrow {
      transform: rotate(180deg);
    }
    
    /* Sub-subjects list (inline chips) */
    .sub-subjects-inline {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-left: 4px;
      padding-left: 8px;
      border-left: 2px solid var(--border);
    }
    .sub-subject-chip {
      padding: 4px 10px;
      border-radius: 12px;
      background: var(--day-other);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.15s;
    }
    .sub-subject-chip:hover {
      background: var(--day-hover);
    }
    .sub-subject-chip.active {
      background: var(--accent);
      color: white;
    }
    .sub-subject-chip .chip-color {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    
    
    
    /* -------------------- Subjects / Sidebar -------------------- */
    .add-subject-btn {
      width: 36px;
      height: 36px;
      border: 2px dashed var(--border);
      border-radius: 50%;
      background: transparent;
      color: var(--muted);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .add-subject-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(102,126,234,0.1);
    }
    
    /* Task Calendar in Sidebar - matches countdown calendar style */
    .task-calendar-section {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    
    
    .task-calendar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      gap: 10px;
    }
    
    .task-calendar-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    
    .task-calendar-nav {
      display: flex;
      gap: 8px;
    }
    
    
    
    .task-manager-sidebar {
      width: 260px;
      min-width: 200px;
      background: var(--card);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .task-manager-sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .task-manager-sidebar-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin: 0;
    }
    
    .task-manager-sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    
    /* Collapsible Subject List */
    .subject-list-item {
      margin-bottom: 4px;
    }
    
    .subject-list-header {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      gap: 8px;
    }
    
    .subject-list-header:hover {
      background: var(--day-hover);
    }
    
    .subject-list-header:hover .subject-actions {
      opacity: 1;
    }
    
    /* Subject Action Buttons */
    .subject-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
      margin-right: auto;
    }
    
    .subject-action-btn {
      width: 28px;
      height: 28px;
      border: 1px solid transparent;
      background: rgba(0,0,0,0.05);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      color: var(--text);
      opacity: 0.8;
    }
    
    body.dark .subject-action-btn {
      background: rgba(255,255,255,0.1);
    }
    
    .subject-action-btn:hover {
      background: rgba(0,0,0,0.15);
      opacity: 1;
      transform: scale(1.1);
      border-color: var(--border);
    }
    
    body.dark .subject-action-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .subject-list-header.active .subject-action-btn {
      background: rgba(255,255,255,0.15);
      color: white;
    }
    
    .subject-list-header.active .subject-action-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    
    .subject-action-btn.delete:hover {
      background: rgba(239, 68, 68, 0.15);
      color: var(--danger);
      border-color: var(--danger);
    }
    
    .subject-child-item .subject-action-btn {
      width: 26px;
      height: 26px;
      font-size: 13px;
    }
    
    .subject-child-item:hover .subject-actions {
      opacity: 1;
    }
    
    .subject-list-header.active {
      background: var(--accent);
      color: white;
    }
    .subject-list-header.drag-over,
    .subject-child-item.drag-over {
      outline: 2px dashed var(--accent);
      background: var(--day-hover);
    }
    
    .subject-list-header .subject-color-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    .subject-list-header .subject-name {
      flex: 1;
      font-size: 13px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .subject-list-header .subject-count {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      background: rgba(0,0,0,0.1);
      color: inherit;
    }
    
    .subject-list-header.active .subject-count {
      background: rgba(255,255,255,0.2);
    }
    
    .subject-list-header .collapse-arrow {
      font-size: 10px;
      transition: transform 0.25s ease;
      opacity: 0.6;
      cursor: pointer;
    }
    
    .subject-list-header .collapse-arrow:hover {
      opacity: 1;
    }
    
    .subject-list-item.expanded .collapse-arrow {
      transform: rotate(180deg);
    }
    
    .subject-list-children {
      padding-right: 20px;
      margin-top: 0;
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transition: max-height 0.3s ease, opacity 0.25s ease, margin-top 0.25s ease;
    }
    
    .subject-list-item.expanded .subject-list-children {
      max-height: 500px; /* Large enough for many children */
      opacity: 1;
      margin-top: 4px;
    }
    
    .subject-child-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      gap: 8px;
      margin-bottom: 2px;
      transform: translateX(0);
    }
    
    .subject-child-item:hover {
      background: var(--day-hover);
      transform: translateX(-2px);
    }
    
    .subject-child-item.active {
      background: var(--accent);
      color: white;
    }
    
    .subject-child-item .child-color {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    
    .subject-child-item .child-name {
      flex: 1;
      font-size: 12px;
    }
    
    .subject-child-item .child-count {
      font-size: 10px;
      opacity: 0.7;
    }
    
    /* Smart Views in Sidebar */
    .smart-views-list {
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border);
    }
    
    .smart-view-item {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      gap: 8px;
      margin-bottom: 2px;
    }
    
    .smart-view-item:hover {
      background: var(--day-hover);
    }
    
    .smart-view-item.active {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: white;
    }
    
    .smart-view-item .view-icon {
      font-size: 14px;
    }
    
    .smart-view-item .view-name {
      flex: 1;
      font-size: 13px;
      font-weight: 500;
    }
    
    .smart-view-item .view-count {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      background: rgba(0,0,0,0.1);
    }
    
    .smart-view-item.active .view-count {
      background: rgba(255,255,255,0.2);
    }
    
    .subjects-list-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 8px 12px 4px;
    }
    
    /* Add Subject Button in Sidebar */
    .add-subject-sidebar-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border: 2px dashed var(--border);
      border-radius: 8px;
      background: transparent;
      color: var(--muted);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s;
      width: 100%;
      margin-top: 8px;
    }
    
    .add-subject-sidebar-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(102,126,234,0.05);
    }
    
    /* Task Month List */
    .task-month-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    .task-month-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 10px;
    }
    
    .task-month-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: none;
      overflow: visible;
    }
    
    .task-month-item {
      padding: 8px 10px;
      background: var(--day-other);
      border-radius: 6px;
      border-right: 3px solid var(--accent);
      font-size: 12px;
    }
    
    .task-month-item-title {
      font-weight: 500;
      color: var(--text);
      margin-bottom: 2px;
    }
    
    .task-month-item-date {
      font-size: 10px;
      color: var(--muted);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.2);
      padding: 8px;
      min-width: 180px;
      z-index: 1000;
      display: none;
    }
    .context-menu.open {
      display: block;
    }
    .context-menu-item {
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text);
      font-size: 13px;
      transition: background 0.1s;
    }
    .context-menu-item:hover {
      background: var(--day-hover);
    }
    .context-menu-item.danger {
      color: var(--danger);
    }
    .context-menu-item.danger:hover {
      background: #fef2f2;
    }
    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 6px 0;
    }
    
    /* Daily Reminder Modal */
    .reminder-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 600;
      padding: 20px;
    }
    .reminder-modal.open {
      display: flex;
    }
    .reminder-card {
      background: var(--card);
      border-radius: 20px;
      padding: 28px;
      max-width: 500px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      text-align: center;
    }
    #eventAlertModal .reminder-card {
      background: linear-gradient(180deg, rgba(102, 126, 234, 0.12), var(--card));
      border: 1px solid rgba(102, 126, 234, 0.2);
      animation: alertPop 0.25s ease-out;
    }
    @keyframes alertPop {
      from { opacity: 0; transform: translateY(8px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .reminder-card h2 {
      font-size: 24px;
      margin-bottom: 8px;
      color: var(--text);
    }
    .reminder-card .reminder-date {
      color: var(--muted);
      font-size: 14px;
      margin-bottom: 20px;
    }
    .reminder-section {
      text-align: right;
      margin-bottom: 16px;
    }
    .reminder-section h3 {
      font-size: 14px;
      color: var(--accent);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .reminder-task-item {
      padding: 12px;
      background: var(--day-other);
      border-radius: 10px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: right;
    }
    .reminder-task-item .task-priority-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .reminder-task-item .task-info {
      flex: 1;
    }
    .reminder-task-item .task-title {
      font-weight: 600;
      color: var(--text);
      font-size: 14px;
    }
    .reminder-task-item .task-time {
      font-size: 12px;
      color: var(--muted);
    }
    .reminder-empty {
      color: var(--muted);
      font-size: 14px;
      padding: 12px;
    }
    .reminder-actions {
      margin-top: 20px;
    }
    
    /* Natural Language Input Hint */
    .nl-hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      direction: rtl;
      line-height: 1.6;
    }
    .nl-hint code {
      background: var(--day-other);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: inherit;
      color: var(--accent);
      font-weight: 500;
    }
    .nl-hint-toggle {
      color: var(--accent);
      cursor: pointer;
      text-decoration: underline;
      margin-right: 8px;
    }
    .nl-hint-examples {
      display: none;
      margin-top: 12px;
      padding: 16px;
      background: var(--day-other);
      border-radius: 10px;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      direction: rtl;
    }
    .nl-hint-examples.show {
      display: block;
    }
    .nl-hint-examples div {
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .nl-hint-examples div:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }
    .nl-hint-examples .example-input {
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
      padding: 6px 10px;
      background: var(--card);
      border-radius: 6px;
      border-right: 3px solid var(--accent);
    }
    .nl-hint-examples .example-result {
      color: var(--muted);
      font-size: 11px;
      padding-right: 16px;
    }
    
    
    
    /* (duplicate .add-subject-btn removed) */
    
    
    
    .task-calendar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      gap: 10px;
    }
    
    .task-calendar-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    
    .task-calendar-nav {
      display: flex;
      gap: 8px;
    }
    
    
    
    /* Subject Modal */
    .subject-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 500;
      padding: 20px;
    }
    .subject-modal.open {
      display: flex;
    }
    .subject-modal-card {
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .subject-modal-card h3 {
      font-size: 20px;
      margin-bottom: 20px;
      color: var(--text);
    }
    .subject-modal-card input {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid var(--border);
      border-radius: 10px;
      font-size: 15px;
      background: var(--input-bg);
      color: var(--text);
      outline: none;
      margin-bottom: 16px;
    }
    .subject-modal-card input:focus {
      border-color: var(--accent);
    }
    .subject-color-picker {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .subject-color-option {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: all 0.15s;
    }
    .subject-color-option:hover {
      transform: scale(1.15);
    }
    .subject-color-option.selected {
      border-color: var(--text);
      box-shadow: 0 0 0 2px var(--card);
    }
    .subject-modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .subject-modal-actions .btn {
      padding: 12px 20px;
    }
    
    /* Subject badge in task item */
    .task-subject-badge {
      font-size: 11px;
      font-weight: 600;
      padding: 3px 10px;
      border-radius: 12px;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 6px;
      background: color-mix(in srgb, var(--subject-color, #667eea) 28%, transparent);
      color: var(--subject-color, #667eea);
      border: 1px solid color-mix(in srgb, var(--subject-color, #667eea) 45%, transparent);
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--subject-color, #667eea) 12%, transparent);
    }
    .task-subject-badge::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--subject-color, #667eea);
      flex-shrink: 0;
    }
    .task-subject-badge .badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    
    /* Subject selector in quick add */
    .subject-selector {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .subject-selector-option {
      padding: 6px 14px;
      border: 2px solid var(--border);
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .subject-selector-option:hover {
      border-color: var(--accent);
    }
    .subject-selector-option.selected {
      border-color: var(--text);
      background: var(--day-hover);
    }
    .subject-selector-option .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    
    /* Edit subject button */
    .edit-subject-btn {
      padding: 4px 8px;
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-left: 4px;
    }
    .edit-subject-btn:hover {
      background: var(--day-hover);
      color: var(--text);
    }

    /* Notification permission button */
    @media (max-width: 1100px) {
      .sidebar {
        position: relative;
        box-shadow: none;
      }
      .sidebar.hidden {
        transform: translateX(100%);
      }

      /* Fix for Task Manager Calendar Sidebar visibility */
      #taskRightSidebar {
        z-index: 350; /* Must be higher than task-manager-overlay (300) */
      }
      #taskRightSidebar.calendar-expanded {
        width: 100%;
        min-width: 0;
      }
      
      @media (max-width: 1100px) {
        #taskRightSidebar {
          position: absolute; /* Override fixed positioning from generic .sidebar */
          height: 100%;
        }
      }
    }

    @media (max-width: 640px) {
      .main-content { padding: 12px; padding-top: 70px; }
      .header { margin-bottom: 20px; }
      .header h1 { font-size: 22px; }
      .header p { font-size: 13px; }

      .fixed-header-bar {
        height: 50px;
        padding: 0 12px;
        gap: 8px;
      }
      .header-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
      .header-btn.icon-only {
        width: 36px;
        height: 36px;
      }
      body {
        padding-top: 50px;
      }
      .app-layout {
        height: calc(100vh - 50px);
      }

      .task-manager-header {
        padding: 12px 16px;
      }
      .task-manager-title {
        font-size: 18px;
      }
      .task-search-bar {
        order: 10;
        max-width: 100%;
        flex-basis: 100%;
      }
      .quick-add-task {
        margin: 0 0 24px 0;
      }
      .task-item {
        flex-wrap: wrap;
      }
      .task-main {
        width: 100%;
        order: 2;
      }
      .task-actions {
        order: 3;
        width: 100%;
        justify-content: center;
        padding-top: 12px;
        border-top: 1px solid var(--border);
        margin-top: 12px;
      }

      .input-panel { padding: 14px; }
      .input-row { 
        flex-direction: column;
        gap: 10px;
      }
      .input-row input { 
        width: 100%;
        padding: 12px 14px;
        font-size: 16px;
      }
      .input-row .reminder-select {
        width: 100%;
        padding: 12px 14px;
        font-size: 16px;
      }
      .input-row .btn {
        width: 100%;
        padding: 12px;
      }
      .input-row-notes textarea {
        font-size: 16px;
      }

      .event-row { 
        flex-direction: column;
        align-items: stretch;
        padding: 14px;
        gap: 12px;
      }
      .color-dot { display: none; }
      .event-info {
        order: 1;
        text-align: center;
      }
      .event-name { font-size: 16px; }
      .timer { 
        order: 2;
        width: 100%;
        justify-content: center;
        gap: 6px;
      }
      .time-unit { 
        min-width: 50px;
        padding: 8px 6px;
        flex: 1;
      }
      .time-val { font-size: 18px; }
      .time-label { font-size: 9px; }
      .badge {
        order: 3;
        align-self: center;
      }
      .event-actions {
        order: 4;
        display: flex;
        justify-content: center;
        gap: 16px;
        padding-top: 8px;
        border-top: 1px solid var(--border);
        width: 100%;
      }
      .star-btn, .edit-btn, .delete-btn {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      .sidebar {
        width: 100%;
      }
      
      /* Task manager sidebar on mobile */
      .task-manager-layout {
        flex-direction: column;
      }
      
      .task-manager-sidebar {
        width: 100%;
        max-height: 200px;
        border-left: none;
        border-bottom: 1px solid var(--border);
      }
      
      .task-manager-sidebar-content {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px;
      }
      
      .smart-views-list {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      
      .smart-view-item {
        padding: 6px 10px;
        font-size: 12px;
      }
      
      .subjects-list-title {
        display: none;
      }
      
      .subjects-list {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }
      
      .subject-list-item {
        margin-bottom: 0;
      }
      
      .subject-list-header {
        padding: 6px 10px;
      }
      
      .subject-list-children {
        position: absolute;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: var(--shadow);
        padding: 8px;
        z-index: 100;
        padding-right: 0;
        margin-top: 0;
      }
      
      .add-subject-sidebar-btn {
        padding: 6px 10px;
        font-size: 12px;
        margin-top: 0;
      }
      
      .calendar-day { min-height: 48px; padding: 6px; }
      .calendar-day-number { font-size: 12px; }
      .calendar-event-chip { font-size: 9px; padding: 2px 4px; }
      .calendar-grid { gap: 4px; }

      .modal-card { padding: 16px; }
      .modal-actions { flex-direction: column; }
      .modal-actions .btn { width: 100%; }
    }
  </style>
</head>
<body>
  <!-- Fixed Header Bar -->
  <div class="fixed-header-bar">
    <button class="header-btn active" id="toggleCountdown">‚è±Ô∏è ◊°◊§◊ô◊®◊î ◊ú◊ê◊ó◊ï◊®</button>
    <button class="header-btn" id="toggleTasks">üìù ◊û◊©◊ô◊û◊ï◊™</button>
    <button class="header-btn" id="togglePomodoro">üçÖ ◊§◊ï◊û◊ï◊ì◊ï◊®◊ï</button>
    <div class="header-spacer"></div>
    <button class="header-btn" id="toggleSidebar">üìÖ ◊ú◊ï◊ó</button>
    <span class="sync-badge hidden" id="syncBadge"><span class="sync-dot"></span><span class="sync-text">Syncing‚Ä¶</span></span>
    <button class="header-btn icon-only" id="helpShortcuts" aria-label="Keyboard shortcuts" title="◊ß◊ô◊¶◊ï◊®◊ô◊ù (H)">?</button>
    <button class="header-btn icon-only" id="themeToggle" aria-label="Toggle dark mode">üåô</button>
    <button class="header-btn" id="userBtn" style="margin-left:8px; border:1px solid var(--accent); color:var(--accent);">üë§ Guest</button>
  </div>

  <!-- Task Manager Fullscreen -->
  <div class="task-manager-overlay" id="taskManagerOverlay">
    <div class="task-manager-header">
      <div class="task-manager-title">üìù Task Manager</div>
        <button class="header-btn" id="toggleTaskSidebar" style="margin-right: 12px;">üìö ◊†◊ï◊©◊ê◊ô◊ù</button>
        <button class="task-manager-close" id="closeTaskManager" aria-label="Close task manager">√ó</button>
      <div class="task-search-bar">
        <input type="text" id="taskSearch" placeholder="◊ó◊ô◊§◊ï◊© ◊û◊©◊ô◊û◊ï◊™... / Search tasks..." />
      </div>
      <div class="task-filters">
        <button class="filter-pill active" data-filter="all">◊î◊õ◊ú</button>
        <button class="filter-pill" data-filter="active">◊§◊¢◊ô◊ú</button>
        <button class="filter-pill" data-filter="completed">◊î◊ï◊©◊ú◊ù</button>
        <button class="header-btn" id="toggleTaskCalendar">üìÖ ◊ú◊ï◊ó</button>
      </div>
    </div>
    
    <!-- Task Manager Layout with Sidebar -->
    <div class="task-manager-layout" style="display: flex; height: 100%; overflow: hidden; position: relative;">
      <!-- Sidebar -->
      <div class="task-manager-sidebar" id="taskSidebar" style="transition: margin-right 0.2s;">
        <div class="task-manager-sidebar-header">
          <h3>üìö ◊†◊ï◊©◊ê◊ô◊ù</h3>
          <button class="add-subject-btn" id="addSubjectBtn" title="◊î◊ï◊°◊£ ◊†◊ï◊©◊ê">+</button>
        </div>
        <div class="task-manager-sidebar-content">
          <!-- Smart Views -->
          <div class="smart-views-list" id="smartViewsList">
            <div class="smart-view-item" data-view="all">
              <span class="view-icon">üìã</span>
              <span class="view-name">◊õ◊ú ◊î◊û◊©◊ô◊û◊ï◊™</span>
              <span class="view-count" id="countAll">0</span>
            </div>
            <div class="smart-view-item" data-view="today">
              <span class="view-icon">üìÖ</span>
              <span class="view-name">◊î◊ô◊ï◊ù</span>
              <span class="view-count" id="countToday">0</span>
            </div>
            <div class="smart-view-item" data-view="week">
              <span class="view-icon">üìÜ</span>
              <span class="view-name">7 ◊ô◊û◊ô◊ù ◊î◊ë◊ê◊ô◊ù</span>
              <span class="view-count" id="countWeek">0</span>
            </div>
            <div class="smart-view-item" data-view="overdue">
              <span class="view-icon">‚ö†Ô∏è</span>
              <span class="view-name">◊ë◊ê◊ô◊ó◊ï◊®</span>
              <span class="view-count" id="countOverdue">0</span>
            </div>
            <div class="smart-view-item" data-view="nodate">
              <span class="view-icon">üì≠</span>
              <span class="view-name">◊ú◊ú◊ê ◊™◊ê◊®◊ô◊ö</span>
              <span class="view-count" id="countNoDate">0</span>
            </div>
          </div>
          
          <!-- Subjects List -->
          <div class="subjects-list-title">◊†◊ï◊©◊ê◊ô◊ù</div>
          <div class="subjects-list" id="subjectsList"></div>
          <button class="add-subject-sidebar-btn" id="addSubjectSidebarBtn">
            <span>+</span>
            <span>◊î◊ï◊°◊£ ◊†◊ï◊©◊ê</span>
          </button>
          
          
        </div>
      </div>
      
      <!-- Main Content -->
      <div class="task-manager-body">
      <div class="quick-add-task" id="quickAddTask">
        <input type="text" id="newTaskTitle" placeholder="◊î◊ï◊°◊£ ◊û◊©◊ô◊û◊î... (◊ú◊ì◊ï◊í◊û◊î: ◊ú◊î◊í◊ô◊© ◊™◊®◊í◊ô◊ú ◊û◊ó◊® 23:00 #◊û◊™◊û◊ò◊ô◊ß◊î ◊ì◊ó◊ï◊£)" dir="auto" />
        <div class="nl-hint">
          üí° <strong>◊ß◊¶◊®◊™ ◊ì◊®◊ö:</strong> ◊õ◊™◊ï◊ë ◊ë◊©◊§◊î ◊ò◊ë◊¢◊ô◊™ ◊ï◊ú◊ó◊• Enter!
          <span class="nl-hint-toggle" onclick="document.getElementById('nlExamples').classList.toggle('show')">◊ì◊ï◊í◊û◊ê◊ï◊™ ‚ñº</span>
          <div class="nl-hint-examples" id="nlExamples">
            <div style="border-bottom: 2px solid var(--accent); padding-bottom: 12px; margin-bottom: 12px;">
              <strong style="color: var(--accent); font-size: 13px;">üìÖ ◊™◊ê◊®◊ô◊õ◊ô◊ù ◊ï◊©◊¢◊ï◊™:</strong>
            </div>
            <div>
              <div class="example-input">◊ú◊î◊í◊ô◊© ◊™◊®◊í◊ô◊ú ◊û◊ó◊® 23:59 #◊û◊™◊û◊ò◊ô◊ß◊î ◊ì◊ó◊ï◊£</div>
              <div class="example-result">‚Üí ◊û◊ó◊® ◊ë-23:59, ◊†◊ï◊©◊ê: ◊û◊™◊û◊ò◊ô◊ß◊î, ◊¢◊ì◊ô◊§◊ï◊™: ◊ì◊ó◊ï◊£</div>
            </div>
            <div>
              <div class="example-input">◊§◊í◊ô◊©◊î ◊¢◊ù ◊ô◊ï◊¢◊• ◊ë◊ô◊ï◊ù ◊©◊ú◊ô◊©◊ô 14:30</div>
              <div class="example-result">‚Üí ◊ô◊ï◊ù ◊©◊ú◊ô◊©◊ô ◊î◊ß◊®◊ï◊ë ◊ë-14:30</div>
            </div>
            <div>
              <div class="example-input">◊û◊ë◊ó◊ü ◊î◊ô◊ï◊ù 16:00 ◊í◊ë◊ï◊î</div>
              <div class="example-result">‚Üí ◊î◊ô◊ï◊ù ◊ë-16:00, ◊¢◊ì◊ô◊§◊ï◊™: ◊í◊ë◊ï◊î</div>
            </div>
            <div>
              <div class="example-input">◊®◊ï◊§◊ê ◊ë-25/12 ◊ë◊©◊¢◊î 10:30</div>
              <div class="example-result">‚Üí 25 ◊ë◊ì◊¶◊û◊ë◊® ◊ë-10:30</div>
            </div>
            
            <div style="border-bottom: 2px solid var(--accent); padding-bottom: 12px; margin-bottom: 12px; margin-top: 16px;">
              <strong style="color: var(--accent); font-size: 13px;">üìö ◊†◊ï◊©◊ê◊ô◊ù (◊õ◊ï◊ú◊ú ◊™◊™-◊†◊ï◊©◊ê◊ô◊ù):</strong>
            </div>
            <div>
              <div class="example-input">◊ú◊ß◊®◊ï◊ê ◊§◊®◊ß 5 #◊û◊™◊û◊ò◊ô◊ß◊î/◊ê◊ú◊í◊ë◊®◊î</div>
              <div class="example-result">‚Üí ◊†◊ï◊©◊ê: ◊û◊™◊û◊ò◊ô◊ß◊î ‚Üí ◊ê◊ú◊í◊ë◊®◊î (◊™◊™-◊†◊ï◊©◊ê)</div>
            </div>
            <div>
              <div class="example-input">◊°◊ô◊õ◊ï◊ù ◊©◊ô◊¢◊ï◊® #"◊î◊ô◊°◊ò◊ï◊®◊ô◊î ◊û◊ï◊ì◊®◊†◊ô◊™"</div>
              <div class="example-result">‚Üí ◊†◊ï◊©◊ê ◊¢◊ù ◊®◊ï◊ï◊ó◊ô◊ù (◊ë◊í◊®◊©◊ô◊ô◊ù)</div>
            </div>
            <div>
              <div class="example-input">◊§◊®◊ï◊ô◊ô◊ß◊ò ◊í◊û◊® #◊¢◊ë◊ï◊ì◊î/◊§◊ô◊™◊ï◊ó/frontend</div>
              <div class="example-result">‚Üí ◊¢◊ë◊ï◊ì◊î ‚Üí ◊§◊ô◊™◊ï◊ó ‚Üí frontend (3 ◊®◊û◊ï◊™!)</div>
            </div>
            <div>
              <div class="example-input">◊™◊®◊í◊ô◊ú ◊ë◊ô◊™ #◊û◊ì◊¢◊ô_◊î◊û◊ó◊©◊ë</div>
              <div class="example-result">‚Üí ◊†◊ï◊©◊ê ◊¢◊ù ◊ß◊ï ◊™◊ó◊™◊ï◊ü ◊ë◊û◊ß◊ï◊ù ◊®◊ï◊ï◊ó</div>
            </div>
            <div>
              <div class="example-input">◊™◊®◊í◊ô◊ú #◊ê◊ú◊í◊ë◊®◊î</div>
              <div class="example-result">‚Üí ◊ô◊©◊ô◊®◊ï◊™ ◊ú◊™◊™-◊†◊ï◊©◊ê ◊ê◊ú◊í◊ë◊®◊î (◊ë◊ú◊ô ◊î◊ï◊®◊î!)</div>
            </div>
            <div>
              <div class="example-input">◊§◊í◊ô◊©◊î #frontend</div>
              <div class="example-result">‚Üí ◊ô◊©◊ô◊®◊ï◊™ ◊ú◊™◊™-◊†◊ï◊©◊ê frontend</div>
            </div>
            <div>
              <div class="example-input">◊ß◊†◊ô◊ï◊™ ◊ú◊©◊ë◊™ ◊§◊ô◊ñ◊ô◊ß◊î</div>
              <div class="example-result">‚Üí ◊ñ◊ô◊î◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊©◊ú ◊†◊ï◊©◊ê ◊ë◊ú◊ô # (◊ê◊ù ◊ß◊ô◊ô◊ù)</div>
            </div>
            
            <div style="border-bottom: 2px solid var(--accent); padding-bottom: 12px; margin-bottom: 12px; margin-top: 16px;">
              <strong style="color: var(--accent); font-size: 13px;">üö® ◊¢◊ì◊ô◊§◊ï◊ô◊ï◊™:</strong>
            </div>
            <div>
              <div class="example-input">◊ú◊î◊í◊ô◊© ◊¢◊ë◊ï◊ì◊î ◊ì◊ó◊ï◊£ !!!</div>
              <div class="example-result">‚Üí ◊¢◊ì◊ô◊§◊ï◊™: ◊ì◊ó◊ï◊£ (!!!, ◊ì◊ó◊ï◊£, ◊û◊ô◊ô◊ì◊ô, urgent, asap)</div>
            </div>
            <div>
              <div class="example-input">◊û◊ë◊ó◊ü ◊ó◊©◊ï◊ë ◊û◊ó◊® !</div>
              <div class="example-result">‚Üí ◊¢◊ì◊ô◊§◊ï◊™: ◊í◊ë◊ï◊î (!, ◊í◊ë◊ï◊î, ◊ó◊©◊ï◊ë, high, important)</div>
            </div>
            <div>
              <div class="example-input">◊ú◊ß◊®◊ï◊ê ◊û◊ê◊û◊® ◊†◊û◊ï◊ö</div>
              <div class="example-result">‚Üí ◊¢◊ì◊ô◊§◊ï◊™: ◊†◊û◊ï◊ö (◊†◊û◊ï◊ö, ◊ú◊ê ◊ì◊ó◊ï◊£, low)</div>
            </div>
            
            <div style="border-bottom: none; padding-top: 16px; color: var(--text); background: var(--day-other); padding: 12px; border-radius: 8px; margin-top: 12px;">
              <strong style="display: block; margin-bottom: 8px; color: var(--accent);">üìñ ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó:</strong>
              <div style="line-height: 1.8; font-size: 11px;">
                <div><strong>üìÖ ◊™◊ê◊®◊ô◊õ◊ô◊ù:</strong> ◊î◊ô◊ï◊ù, ◊û◊ó◊®, ◊û◊ó◊®◊™◊ô◊ô◊ù, ◊ë◊¢◊ï◊ì X ◊ô◊û◊ô◊ù, ◊î◊©◊ë◊ï◊¢, ◊ë◊©◊ë◊ï◊¢ ◊î◊ë◊ê, ◊ë◊ô◊ï◊ù ◊®◊ê◊©◊ï◊ü/◊©◊†◊ô/..., DD/MM</div>
                <div><strong>‚è∞ ◊©◊¢◊ï◊™:</strong> 14:30, ◊ë◊©◊¢◊î 9:00, ◊ë-23:59, 2:30 PM</div>
                <div><strong>üè∑Ô∏è ◊†◊ï◊©◊ê◊ô◊ù:</strong> #◊†◊ï◊©◊ê, #◊†◊ï◊©◊ê_◊¢◊ù_◊ß◊ï_◊™◊ó◊™◊ï◊ü, #"◊†◊ï◊©◊ê ◊¢◊ù ◊®◊ï◊ï◊ó◊ô◊ù", #◊î◊ï◊®◊î/◊ô◊ú◊ì, #◊î◊ï◊®◊î/◊ô◊ú◊ì/◊†◊õ◊ì</div>
                <div><strong>üö® ◊¢◊ì◊ô◊§◊ï◊™:</strong> ◊ì◊ó◊ï◊£ (!!!), ◊í◊ë◊ï◊î (!), ◊ë◊ô◊†◊ï◊†◊ô, ◊†◊û◊ï◊ö</div>
              </div>
            </div>
            
            <div style="padding-top: 12px; color: var(--muted); font-size: 11px; text-align: center;">
              <strong>üí° ◊ò◊ô◊§:</strong> ◊ê◊§◊©◊® ◊ú◊©◊ú◊ë ◊î◊õ◊ú! ◊ú◊ì◊ï◊í◊û◊î: "◊ú◊î◊í◊ô◊© ◊§◊®◊ï◊ô◊ß◊ò ◊û◊ó◊® 23:59 #◊¢◊ë◊ï◊ì◊î/◊§◊ô◊™◊ï◊ó ◊ì◊ó◊ï◊£ !!"
            </div>
          </div>
        </div>
        <div class="quick-add-row" id="quickAddRow" style="display: none;">
          <div class="priority-selector" id="taskPriorityPicker">
            <div class="priority-option" data-priority="urgent">üî¥ ◊ì◊ó◊ï◊£</div>
            <div class="priority-option" data-priority="high">üü† ◊í◊ë◊ï◊î</div>
            <div class="priority-option selected" data-priority="medium">üü° ◊ë◊ô◊†◊ï◊†◊ô</div>
            <div class="priority-option" data-priority="low">üü¢ ◊†◊û◊ï◊ö</div>
            <div class="priority-option" data-priority="none">‚ö™ ◊ú◊ú◊ê</div>
          </div>
          <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap; width: 100%;">
            <div class="label-input-wrapper" style="flex-shrink: 0;">
              <span>üìÅ</span>
              <select id="newTaskSubject" style="border: none; background: transparent; color: var(--text); font-size: 13px; outline: none; cursor: pointer;">
                <option value="">◊ú◊ú◊ê ◊†◊ï◊©◊ê</option>
              </select>
            </div>
            <div class="label-input-wrapper">
              <span>üìÖ</span>
              <input type="datetime-local" id="newTaskDue" style="width: 180px; border: none; background: transparent; color: var(--text);" />
            </div>
            <div class="label-input-wrapper">
              <span>üîÅ</span>
              <select id="newTaskRecurrence" style="border: none; background: transparent; color: var(--text); font-size: 13px; outline: none; cursor: pointer;">
                <option value="none">◊ú◊ú◊ê ◊ó◊ñ◊®◊î</option>
                <option value="daily">◊ô◊ï◊û◊ô</option>
                <option value="weekly">◊©◊ë◊ï◊¢◊ô</option>
                <option value="monthly">◊ó◊ï◊ì◊©◊ô</option>
              </select>
            </div>
            <div class="label-input-wrapper">
              <span>üé®</span>
              <div class="task-color-picker compact" id="quickTaskColorPicker">
                <div class="task-color-option none selected" data-color="">x</div>
                <div class="task-color-option subject disabled" data-color="subject" title="Use subject color">S</div>
                <div class="task-color-option" data-color="#667eea" style="background: #667eea;"></div>
                <div class="task-color-option" data-color="#ef4444" style="background: #ef4444;"></div>
                <div class="task-color-option" data-color="#f97316" style="background: #f97316;"></div>
                <div class="task-color-option" data-color="#eab308" style="background: #eab308;"></div>
                <div class="task-color-option" data-color="#22c55e" style="background: #22c55e;"></div>
                <div class="task-color-option" data-color="#06b6d4" style="background: #06b6d4;"></div>
                <div class="task-color-option" data-color="#8b5cf6" style="background: #8b5cf6;"></div>
                <div class="task-color-option" data-color="#0ea5e9" style="background: #0ea5e9;"></div>
                <div class="task-color-option" data-color="#14b8a6" style="background: #14b8a6;"></div>
                <div class="task-color-option" data-color="#84cc16" style="background: #84cc16;"></div>
                <div class="task-color-option" data-color="#f43f5e" style="background: #f43f5e;"></div>
              </div>
            </div>
            <button class="btn btn-primary" id="addTaskBtn">◊î◊ï◊°◊£</button>
          </div>
        </div>
      </div>
      
      <div class="task-sections" id="taskSections">
        <!-- Active Tasks -->
        <div id="activeSection">
          <div class="task-section-title">üìã ◊û◊©◊ô◊û◊ï◊™ ◊§◊¢◊ô◊ú◊ï◊™</div>
          <div class="task-list" id="activeTasks"></div>
        </div>
        
        <!-- Completed Tasks -->
        <div id="completedSection" style="display: none;">
          <div class="task-section-title">‚úÖ ◊î◊ï◊©◊ú◊û◊ï</div>
          <div class="task-list" id="completedTasks"></div>
        </div>
        
        <!-- Empty State -->
        <div class="tasks-empty" id="tasksEmpty" style="display: none;">
          <div class="tasks-empty-icon">üìù</div>
          <h3>◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊¢◊ì◊ô◊ô◊ü</h3>
          <p>◊î◊ï◊°◊£ ◊û◊©◊ô◊û◊î ◊®◊ê◊©◊ï◊†◊î ◊ú◊û◊¢◊ú◊î ◊õ◊ì◊ô ◊ú◊î◊™◊ó◊ô◊ú!</p>
        </div>
      </div>
    </div>
      
      <!-- Right Sidebar for Task Calendar -->
      <aside class="sidebar hidden" id="taskRightSidebar">
        <div class="calendar-container">
          <div class="calendar-header">
            <div class="calendar-nav">
              <button id="prevTaskMonth">‚Äπ</button>
              <button id="todayTaskBtn">‚óè</button>
              <button id="nextTaskMonth">‚Ä∫</button>
              <button id="toggleTaskCalendarSize" title="◊î◊í◊ì◊ú/◊î◊ß◊ò◊ü" aria-label="◊î◊í◊ì◊ú/◊î◊ß◊ò◊ü">‚§¢</button>
            </div>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: flex-end;">
              <div class="calendar-title" id="taskCalendarTitle"></div>
              <div class="calendar-view-toggle" id="taskCalendarViewToggle" aria-label="Calendar view">
                <button data-view="month" class="active">◊ó◊ï◊ì◊©</button>
                <button data-view="week">◊©◊ë◊ï◊¢</button>
                <button data-view="day">◊ô◊ï◊ù</button>
              </div>
            </div>
          </div>
          <div class="calendar-grid" id="taskCalendarGrid"></div>
        </div>
        
        <div class="sidebar-section">
          <div class="sidebar-section-title" id="taskMonthEventsTitle">◊û◊©◊ô◊û◊ï◊™ ◊î◊ó◊ï◊ì◊©</div>
          <div class="month-events" id="taskMonthEvents">
            <div class="no-events-msg">◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊î◊ó◊ï◊ì◊©</div>
          </div>
        </div>
      </aside>
    </div><!-- close task-manager-layout -->
  </div>
  
  <!-- Task Edit Modal -->
  <div class="task-edit-modal" id="taskEditModal">
    <div class="task-edit-card" id="taskEditCard">
      <input type="text" id="editTaskTitle" placeholder="Task title..." />
      <textarea id="editTaskContent" placeholder="Add notes..."></textarea>
      
      <div class="task-edit-section">
        <div class="task-edit-section-title">Subject</div>
        <select id="editTaskSubject" style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px; cursor: pointer;">
          <option value="">No Subject</option>
        </select>
      </div>
      
      <div class="task-edit-section">
        <div class="task-edit-section-title">Priority</div>
        <div class="priority-selector" id="editTaskPriority">
          <div class="priority-option" data-priority="urgent">üî¥ Urgent</div>
          <div class="priority-option" data-priority="high">üü† High</div>
          <div class="priority-option" data-priority="medium">üü° Medium</div>
          <div class="priority-option" data-priority="low">üü¢ Low</div>
          <div class="priority-option" data-priority="none">‚ö™ None</div>
        </div>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Color</div>
        <div class="task-color-picker" id="taskColorPicker">
          <div class="task-color-option none selected" data-color="">x</div>
          <div class="task-color-option subject disabled" data-color="subject" title="Use subject color">S</div>
          <div class="task-color-option" data-color="#667eea" style="background: #667eea;"></div>
          <div class="task-color-option" data-color="#ef4444" style="background: #ef4444;"></div>
          <div class="task-color-option" data-color="#f97316" style="background: #f97316;"></div>
          <div class="task-color-option" data-color="#eab308" style="background: #eab308;"></div>
          <div class="task-color-option" data-color="#22c55e" style="background: #22c55e;"></div>
          <div class="task-color-option" data-color="#06b6d4" style="background: #06b6d4;"></div>
          <div class="task-color-option" data-color="#8b5cf6" style="background: #8b5cf6;"></div>
          <div class="task-color-option" data-color="#0ea5e9" style="background: #0ea5e9;"></div>
          <div class="task-color-option" data-color="#14b8a6" style="background: #14b8a6;"></div>
          <div class="task-color-option" data-color="#84cc16" style="background: #84cc16;"></div>
          <div class="task-color-option" data-color="#f43f5e" style="background: #f43f5e;"></div>
        </div>
      </div>
      
      <div class="task-edit-section">
        <div class="task-edit-section-title">Due Date</div>
        <input type="datetime-local" id="editTaskDue" style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px;" />
        <button class="btn" id="clearDueBtn" style="margin-left: 8px; padding: 10px 14px; background: var(--day-other); color: var(--muted);">Clear</button>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Recurrence</div>
        <select id="editTaskRecurrence" style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px; cursor: pointer;">
          <option value="none">◊ú◊ú◊ê ◊ó◊ñ◊®◊î</option>
          <option value="daily">◊ô◊ï◊û◊ô</option>
          <option value="weekly">◊©◊ë◊ï◊¢◊ô</option>
          <option value="monthly">◊ó◊ï◊ì◊©◊ô</option>
        </select>
      </div>
      
      <div class="task-edit-section">
        <div class="task-edit-section-title">Subtasks / Checklist</div>
        <div class="task-checklist" id="editTaskChecklist"></div>
        <div class="checklist-add">
          <input type="text" id="newChecklistItem" placeholder="Add subtask..." />
          <button class="btn btn-primary" id="addChecklistItem" style="padding: 10px 16px;" aria-label="◊î◊ï◊°◊£ ◊§◊®◊ô◊ò">+</button>
        </div>
      </div>
      
      <div class="task-edit-footer">
        <div style="display: flex; gap: 8px;">
          <button class="task-action-btn" id="duplicateTaskBtn" title="Duplicate" aria-label="◊©◊õ◊§◊ú ◊û◊©◊ô◊û◊î">‚ßâ</button>
          <button class="task-action-btn delete" id="deleteTaskBtn" title="Delete" aria-label="◊û◊ó◊ß ◊û◊©◊ô◊û◊î">üóëÔ∏è</button>
        </div>
        <button class="btn btn-primary" id="saveTaskBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Pomodoro Overlay -->
  <div class="pomodoro-overlay" id="pomodoroOverlay">
    <div class="pomodoro-header-bar">
      <div class="pomodoro-header-title">üçÖ Pomodoro Timer</div>
      <label class="pomodoro-option" style="margin: 0; background: transparent;">
        <input type="checkbox" id="pomodoroMiniToggle" />
        <span style="font-size: 13px;">◊î◊¶◊í ◊û◊ô◊†◊ô</span>
      </label>
    </div>
    
    <div class="pomodoro-content">
      <div class="pomodoro-container">
        <div class="pomodoro-card" id="pomodoroCard">
          
          <!-- Timer Circle -->
          <div class="pomodoro-timer-wrap">
            <div class="pomodoro-timer-ring" id="pomodoroRing" style="--progress: 0%;"></div>
            <div class="pomodoro-timer">
              <div class="pomodoro-time" id="pomodoroDisplay">25:00</div>
              <div class="pomodoro-mode">
                <span class="pomodoro-mode-dot"></span>
                <span id="pomodoroMode">◊û◊¶◊ë ◊û◊ô◊ß◊ï◊ì</span>
              </div>
              <div class="pomodoro-next" id="pomodoroNext">◊î◊ë◊ê: ◊î◊§◊°◊ß◊î ◊ß◊¶◊®◊î</div>
            </div>
          </div>

          <!-- Controls -->
          <div class="pomodoro-controls">
            <button class="pomodoro-btn" id="pomodoroReset" title="◊ê◊§◊°">üîÑ</button>
            <button class="pomodoro-btn primary" id="pomodoroStart" title="◊î◊™◊ó◊ú">‚ñ∂Ô∏è</button>
            <button class="pomodoro-btn" id="pomodoroSkip" title="◊ì◊ú◊í">‚è≠Ô∏è</button>
          </div>

          <div id="pomodoroProgress" style="display:none;"></div>

          <!-- Presets -->
          <div class="pomodoro-presets">
            <button class="pomodoro-preset" data-preset="classic">25/5 ◊ß◊ú◊ê◊°◊ô</button>
            <button class="pomodoro-preset" data-preset="flow">50/10 Flow</button>
            <button class="pomodoro-preset" data-preset="ultradian">90/20 Ultra</button>
            <button class="pomodoro-preset" data-preset="perfect">52/17 ◊û◊ï◊©◊ú◊ù</button>
            <button class="pomodoro-preset" data-preset="custom">‚öôÔ∏è ◊û◊ï◊™◊ê◊ù</button>
          </div>

          <!-- Settings Panel -->
          <div class="pomodoro-settings-panel">
            <div class="pomodoro-field">
              <label>◊û◊ô◊ß◊ï◊ì</label>
              <input type="number" min="5" max="240" id="pomodoroFocus" value="25" />
            </div>
            <div class="pomodoro-field">
              <label>◊î◊§◊°◊ß◊î</label>
              <input type="number" min="3" max="60" id="pomodoroBreak" value="5" />
            </div>
            <div class="pomodoro-field">
              <label>◊ê◊®◊ï◊õ◊î</label>
              <input type="number" min="5" max="90" id="pomodoroLong" value="15" />
            </div>
            <div class="pomodoro-field">
              <label>◊õ◊ú X</label>
              <input type="number" min="1" max="8" id="pomodoroLongEvery" value="4" />
            </div>
          </div>

          <!-- Options -->
          <div class="pomodoro-options">
            <label class="pomodoro-option">
              <input type="checkbox" id="pomodoroAutoContinue" />
              <span>◊î◊û◊©◊ö ◊ê◊ï◊ò◊ï◊û◊ò◊ô</span>
            </label>
            <select class="pomodoro-sound-select" id="pomodoroSound">
              <option value="chime">üéµ ◊¶◊ú◊¶◊ï◊ú ◊¢◊ì◊ô◊ü</option>
              <option value="soft">üßò ◊û◊ì◊ô◊ò◊¶◊ô◊î</option>
              <option value="bell">üîî ◊§◊¢◊û◊ï◊ü</option>
              <option value="digital">üì± ◊ì◊ô◊í◊ô◊ò◊ú◊ô</option>
              <option value="glass">‚ú® ◊ß◊®◊ô◊°◊ò◊ú</option>
              <option value="success">üéâ ◊§◊†◊§◊®◊î</option>
            </select>
            <button class="pomodoro-preview-btn" id="pomodoroPreviewSound">‚ñ∂Ô∏è ◊†◊°◊î</button>
          </div>

          <!-- Task Select -->
          <select class="pomodoro-task-select" id="pomodoroTaskSelect">
            <option value="">üìã ◊ë◊ó◊® ◊û◊©◊ô◊û◊î ◊ú◊î◊™◊û◊ß◊ì...</option>
          </select>

          <!-- Stats -->
          <div class="pomodoro-stats">
            <div class="pomodoro-stat">
              <div class="label">◊û◊ó◊ñ◊ï◊®◊ô◊ù</div>
              <div class="value" id="pomodoroSessionCount">0</div>
            </div>
            <div class="pomodoro-stat">
              <div class="label">◊ì◊ß◊ï◊™ ◊û◊ô◊ß◊ï◊ì</div>
              <div class="value" id="pomodoroFocusMinutes">0</div>
            </div>
            <div class="pomodoro-stat">
              <div class="label">◊®◊¶◊£ ◊ô◊û◊ô◊ù</div>
              <div class="value" id="pomodoroStreak">0</div>
            </div>
          </div>

          <!-- Daily Progress -->
          <div class="pomodoro-daily">
            <div class="pomodoro-daily-bar">
              <div class="pomodoro-daily-fill" id="pomodoroDayProgress"></div>
            </div>
            <div class="pomodoro-daily-label" id="pomodoroDayLabel">0/8 ◊û◊ó◊ñ◊ï◊®◊ô ◊û◊ô◊ß◊ï◊ì ◊ú◊î◊ô◊ï◊ù</div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Pomodoro Mini Player -->
  <div class="pomodoro-mini" id="pomodoroMini">
    <div>
      <div class="pomodoro-mini-time" id="pomodoroMiniTime">25:00</div>
      <div class="pomodoro-mini-mode" id="pomodoroMiniMode">◊û◊ô◊ß◊ï◊ì</div>
    </div>
    <button class="pomodoro-mini-close" id="pomodoroMiniClose" aria-label="◊°◊í◊ï◊®">√ó</button>
  </div>
  
  <!-- Subject Modal -->
  <div class="subject-modal" id="subjectModal">
    <div class="subject-modal-card">
      <h3 id="subjectModalTitle">◊î◊ï◊°◊£ ◊†◊ï◊©◊ê ◊ó◊ì◊©</h3>
      <input type="text" id="subjectNameInput" placeholder="◊©◊ù ◊î◊†◊ï◊©◊ê (◊ú◊ì◊ï◊í◊û◊î: ◊û◊™◊û◊ò◊ô◊ß◊î, ◊¢◊ë◊ï◊ì◊î, ◊ê◊ô◊©◊ô)" dir="auto" />
      
      <div class="task-edit-section-title" style="margin: 16px 0 10px 0;">◊†◊ï◊©◊ê ◊ê◊ë (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô)</div>
      <select id="parentSubjectSelect" style="width: 100%; padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; cursor: pointer; margin-bottom: 16px;">
        <option value="">◊ú◊ú◊ê (◊†◊ï◊©◊ê ◊®◊ê◊©◊ô)</option>
      </select>
      
      <div class="task-edit-section-title" style="margin-bottom: 10px;">◊¶◊ë◊¢</div>
      <div class="subject-color-picker" id="subjectColorPicker">
        <div class="subject-color-option selected" style="background: #667eea;" data-color="#667eea"></div>
        <div class="subject-color-option" style="background: #ef4444;" data-color="#ef4444"></div>
        <div class="subject-color-option" style="background: #f97316;" data-color="#f97316"></div>
        <div class="subject-color-option" style="background: #eab308;" data-color="#eab308"></div>
        <div class="subject-color-option" style="background: #22c55e;" data-color="#22c55e"></div>
        <div class="subject-color-option" style="background: #06b6d4;" data-color="#06b6d4"></div>
        <div class="subject-color-option" style="background: #8b5cf6;" data-color="#8b5cf6"></div>
        <div class="subject-color-option" style="background: #ec4899;" data-color="#ec4899"></div>
        <div class="subject-color-option" style="background: #0ea5e9;" data-color="#0ea5e9"></div>
        <div class="subject-color-option" style="background: #14b8a6;" data-color="#14b8a6"></div>
        <div class="subject-color-option" style="background: #84cc16;" data-color="#84cc16"></div>
        <div class="subject-color-option" style="background: #f43f5e;" data-color="#f43f5e"></div>
      </div>
      <div class="subject-modal-actions">
        <button class="btn" id="cancelSubjectBtn" style="background: var(--day-other); color: var(--muted);">◊ë◊ô◊ò◊ï◊ú</button>
        <button class="btn btn-danger" id="deleteSubjectBtn" style="display: none;">◊û◊ó◊ß</button>
        <button class="btn btn-primary" id="saveSubjectBtn">◊©◊û◊ï◊®</button>
      </div>
    </div>
  </div>

  <!-- Context Menu for Subjects -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" data-action="edit">‚úèÔ∏è ◊¢◊®◊ô◊õ◊î</div>
    <div class="context-menu-item" data-action="add-sub">‚ûï ◊î◊ï◊°◊£ ◊™◊™-◊†◊ï◊©◊ê</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" data-action="delete">üóëÔ∏è ◊û◊ó◊ß</div>
  </div>
  
  <!-- Context Menu for Countdown Events -->
  <div class="context-menu" id="eventContextMenu">
    <div class="context-menu-item" data-action="pin">üìå ◊†◊¢◊• ◊ú◊û◊¢◊ú◊î</div>
    <div class="context-menu-item" data-action="star">‚≠ê ◊°◊û◊ü ◊õ◊û◊ï◊¢◊ì◊£</div>
    <div class="context-menu-item" data-action="edit">‚úèÔ∏è ◊¢◊®◊ô◊õ◊î</div>
    <div class="context-menu-item" data-action="duplicate">üìã ◊©◊õ◊§◊ú</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" data-action="delete">üóëÔ∏è ◊û◊ó◊ß</div>
  </div>
  
  <!-- Context Menu for Adding New Event -->
  <div class="context-menu" id="addEventContextMenu">
    <div class="context-menu-item" data-action="add">‚ûï ◊î◊ï◊°◊£ ◊ê◊ô◊®◊ï◊¢ ◊ó◊ì◊©</div>
    <div class="context-menu-item" data-action="add-tomorrow">üìÖ ◊ê◊ô◊®◊ï◊¢ ◊ú◊û◊ó◊®</div>
    <div class="context-menu-item" data-action="add-week">üìÜ ◊ê◊ô◊®◊ï◊¢ ◊ú◊©◊ë◊ï◊¢ ◊î◊ë◊ê</div>
  </div>

  <!-- Daily Reminder Modal -->
  <div class="reminder-modal" id="reminderModal">
    <div class="reminder-card">
      <h2>‚òÄÔ∏è ◊ë◊ï◊ß◊® ◊ò◊ï◊ë!</h2>
      <div class="reminder-date" id="reminderDate"></div>
      
      <div class="reminder-section" id="todayTasksSection">
        <h3>üìÖ ◊û◊©◊ô◊û◊ï◊™ ◊ú◊î◊ô◊ï◊ù</h3>
        <div id="todayTasksList"></div>
      </div>
      
      <div class="reminder-section" id="tomorrowTasksSection">
        <h3>üìÜ ◊û◊©◊ô◊û◊ï◊™ ◊ú◊û◊ó◊®</h3>
        <div id="tomorrowTasksList"></div>
      </div>
      
      <div class="reminder-actions">
        <button class="btn btn-primary" id="closeReminderBtn" style="width: 100%;">◊î◊ë◊†◊™◊ô, ◊™◊ï◊ì◊î! üëç</button>
      </div>
    </div>
  </div>
  
  <div class="reminder-modal" id="eventAlertModal" role="dialog" aria-modal="true" aria-labelledby="alertTitle">
    <div class="reminder-card" style="border-top: 5px solid var(--accent);">
      <div style="font-size: 40px; margin-bottom: 10px;">‚è∞</div>
      <h2 id="alertTitle">Reminder!</h2>
      <p id="alertMessage" style="font-size: 18px; margin: 10px 0; color: var(--text);">Event is starting soon</p>
      <div class="reminder-actions">
        <button class="btn btn-primary" id="closeAlertBtn" style="width: 100%;">Dismiss</button>
      </div>
    </div>
  </div>

  <div class="app-layout">
    <div class="main-content">
      <div class="container">
        <header class="header">
          <h1>‚è±Ô∏è Shared Event Countdowns</h1>
          <p>Events sync live across all devices</p>
        </header>

        <div class="input-panel" id="inputPanel">
          <div class="input-row">
            <input type="text" id="eventName" placeholder="Event name..." autocomplete="off" aria-label="Event name" />
            <input type="datetime-local" id="eventDate" aria-label="Event date and time" max="9999-12-31T23:59" />
            <select id="eventReminder" class="reminder-select" aria-label="Reminder time">
              <option value="0">üîï No Reminder</option>
              <option value="5">5 minutes before</option>
              <option value="15">15 minutes before</option>
              <option value="30">30 minutes before</option>
              <option value="60">1 hour before</option>
              <option value="1440">1 day before</option>
            </select>
            <button class="btn btn-primary" id="addBtn">Add Event</button>
            <button class="btn btn-cancel" id="cancelBtn">Cancel</button>
            <button class="btn btn-ghost" id="clearBtn">Clear All</button>
          </div>
          <div class="input-row-notes">
            <textarea id="eventNotes" placeholder="Notes (optional)..." aria-label="Event notes"></textarea>
          </div>
        </div>

        <div class="event-list loading" id="eventList" role="list">
          <div class="event-skeleton">
            <div class="event-skeleton-row"></div>
            <div class="event-skeleton-row"></div>
            <div class="event-skeleton-row"></div>
          </div>
        </div>

        <div class="empty-state" id="emptyState">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <p>No events yet. Add your first countdown above! üéâ</p>
        </div>
      </div>
    </div>

    <aside class="sidebar hidden" id="sidebar">
      <div class="calendar-container">
        <div class="calendar-header">
          <div class="calendar-nav">
            <button id="prevMonth" aria-label="◊ó◊ï◊ì◊© ◊ß◊ï◊ì◊ù">‚Äπ</button>
            <button id="todayBtn" aria-label="◊î◊ô◊ï◊ù" title="◊î◊ô◊ï◊ù">‚óè</button>
            <button id="nextMonth" aria-label="◊ó◊ï◊ì◊© ◊î◊ë◊ê">‚Ä∫</button>
          </div>
          <div class="calendar-title" id="calendarTitle"></div>
        </div>
        <div class="calendar-grid" id="calendarGrid"></div>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title" id="monthEventsTitle">◊ê◊ô◊®◊ï◊¢◊ô ◊î◊ó◊ï◊ì◊©</div>
        <div class="month-events" id="monthEvents">
          <div class="no-events-msg">◊ê◊ô◊ü ◊ê◊ô◊®◊ï◊¢◊ô◊ù ◊î◊ó◊ï◊ì◊©</div>
        </div>
      </div>
    </aside>
  </div>

  <div class="modal-backdrop" id="clearModal" role="dialog" aria-modal="true" aria-labelledby="clearModalTitle" aria-describedby="clearModalDesc">
    <div class="modal-card">
      <h3 id="clearModalTitle">Clear all shared events?</h3>
      <p id="clearModalDesc">This removes every event for everyone. Do you want to continue?</p>
      <div class="modal-actions">
        <button class="btn btn-danger" id="confirmClearBtn">Yes, clear everything</button>
        <button class="btn btn-cancel" id="cancelClearModalBtn" style="display:inline-block;">Keep events</button>
      </div>
    </div>
  </div>

  <div class="shortcuts-backdrop" id="shortcutsModal" role="dialog" aria-modal="true" aria-labelledby="shortcutsTitle">
    <div class="shortcuts-card">
      <div class="shortcuts-hero">
        <div>
          <div class="shortcuts-eyebrow">‚å®Ô∏è ◊ß◊ô◊¶◊ï◊®◊ô ◊û◊ß◊ú◊ì◊™</div>
          <div class="shortcuts-title" id="shortcutsTitle">Shortcut Command Center</div>
          <div class="shortcuts-subtitle">H ◊ú◊§◊™◊ô◊ó◊î/◊°◊í◊ô◊®◊î</div>
        </div>
        <button class="shortcuts-close" id="shortcutsClose" aria-label="Close shortcuts">√ó</button>
      </div>
      <div class="shortcuts-body">
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">◊ô◊¶◊ô◊®◊î ◊û◊î◊ô◊®◊î</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">◊§◊ï◊ß◊ï◊° ◊¢◊ú ◊î◊ï◊°◊§◊î ◊û◊î◊ô◊®◊î</div>
              <div class="shortcut-keys"><span class="keycap">N</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊§◊™◊ó/◊°◊í◊ï◊® ◊ó◊ú◊ï◊ü ◊ß◊ô◊¶◊ï◊®◊ô◊ù</div>
              <div class="shortcut-keys"><span class="keycap">H</span></div>
            </div>
          </div>
        </div>
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">◊†◊ô◊ï◊ï◊ò ◊ï◊™◊¶◊ï◊í◊ï◊™</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">◊ß◊§◊ô◊¶◊î ◊ú◊¥◊î◊ô◊ï◊ù◊¥</div>
              <div class="shortcut-keys"><span class="keycap">T</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊§◊™◊ó ◊§◊ï◊û◊ï◊ì◊ï◊®◊ï</div>
              <div class="shortcut-keys"><span class="keycap">P</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊î◊¶◊í/◊î◊°◊™◊® ◊ú◊ï◊ó ◊©◊†◊î</div>
              <div class="shortcut-keys"><span class="keycap">C</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊û◊¢◊ë◊® ◊ú◊û◊©◊ô◊û◊ï◊™</div>
              <div class="shortcut-keys"><span class="keycap">M</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊ó◊ñ◊®◊î ◊ú◊°◊§◊ô◊®◊î ◊ú◊ê◊ó◊ï◊®</div>
              <div class="shortcut-keys"><span class="keycap">G</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊ó◊ô◊§◊ï◊© ◊û◊©◊ô◊û◊ï◊™</div>
              <div class="shortcut-keys"><span class="keycap">/</span></div>
            </div>
          </div>
        </div>
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">◊û◊¢◊®◊õ◊™</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">◊°◊í◊ï◊® ◊û◊ï◊ì◊ê◊ú◊ô◊ù/◊ó◊ú◊ï◊†◊ï◊™</div>
              <div class="shortcut-keys"><span class="keycap wide">Esc</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊û◊¶◊ë ◊õ◊î◊î/◊ë◊î◊ô◊®</div>
              <div class="shortcut-keys"><span class="keycap">D</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">◊ß◊ú◊ô◊ß ◊ô◊û◊†◊ô ◊ë◊®◊©◊ô◊û◊™ ◊ê◊ô◊®◊ï◊¢◊ô◊ù</div>
              <div class="shortcut-keys"><span class="keycap wide">‚ûï</span></div>
            </div>
          </div>
        </div>
        <div class="shortcut-note">◊ò◊ô◊§: ◊î◊ß◊ô◊¶◊ï◊®◊ô◊ù ◊§◊ï◊¢◊ú◊ô◊ù ◊®◊ß ◊õ◊©◊ú◊ê ◊û◊ß◊ú◊ô◊ì◊ô◊ù ◊ë◊™◊ï◊ö ◊©◊ì◊î ◊ò◊ß◊°◊ò.</div>
      </div>
    </div>
  </div>

  <!-- Day Drawer -->
  <div class="day-drawer-backdrop" id="dayDrawer" role="dialog" aria-modal="true" aria-labelledby="dayDrawerTitle">
    <div class="day-drawer">
      <div class="day-drawer-header">
        <div>
          <div class="day-drawer-title" id="dayDrawerTitle"></div>
          <div class="day-drawer-subtitle" id="dayDrawerSubtitle"></div>
        </div>
        <button class="day-drawer-close" id="closeDayDrawer" aria-label="◊°◊í◊ï◊®">√ó</button>
      </div>
      <div class="day-drawer-content">
        <div class="day-drawer-section" id="dayDrawerEvents">
          <div class="day-drawer-section-title">
            üìÖ ◊ê◊ô◊®◊ï◊¢◊ô◊ù <span class="count" id="dayEventsCount">0</span>
          </div>
          <div id="dayEventsList"></div>
        </div>
        <div class="day-drawer-section" id="dayDrawerTasks">
          <div class="day-drawer-section-title">
            ‚úÖ ◊û◊©◊ô◊û◊ï◊™ <span class="count" id="dayTasksCount">0</span>
          </div>
          <div id="dayTasksList"></div>
        </div>
      </div>
      <div class="day-drawer-actions">
        <button class="btn btn-primary" id="addEventToDay">üìÖ ◊î◊ï◊°◊£ ◊ê◊ô◊®◊ï◊¢</button>
        <button class="btn" id="addTaskToDay" style="background: var(--btn-secondary-bg); color: var(--text);">‚úÖ ◊î◊ï◊°◊£ ◊û◊©◊ô◊û◊î</button>
      </div>
    </div>
  </div>

  <div class="undo-toast" id="undoToast" role="status" aria-live="polite">
    <span id="undoToastMsg">Event deleted</span>
    <button id="undoToastUndo" aria-label="Undo delete">Undo</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getDatabase, ref, set, onValue, push, remove, onChildAdded, onChildChanged, onChildRemoved } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB_IflOD8CwVLQQjqtz_ZKWzbfgCiOm2Js",
    authDomain: "countdown-463de.firebaseapp.com",
    databaseURL: "https://countdown-463de-default-rtdb.firebaseio.com",
    projectId: "countdown-463de",
    storageBucket: "countdown-463de.firebasestorage.app",
    messagingSenderId: "1016385864732",
    appId: "1:1016385864732:web:8a82e771e1f4be567a8bd9"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const eventsRef = ref(db, 'events');

  // 2. USER AUTHENTICATION LOGIC
  const userBtn = document.getElementById('userBtn');
  let currentUser = localStorage.getItem('countdown_username');

  // Function to sanitize username (remove special chars)
  const cleanUsername = (name) => {
    return (name || '').trim().toLowerCase().replace(/[^a-z0-9_-]/g, '');
  };

  // Login Process
  if (!currentUser) {
    const input = prompt("üëã Welcome! \nEnter a username to access your private tasks:\n(e.g., 'john123', 'sarah_work')");
    currentUser = cleanUsername(input);
    
    if (!currentUser) {
      currentUser = 'guest_' + Math.floor(Math.random() * 1000);
      alert("No name entered. You are logged in as: " + currentUser);
    }
    localStorage.setItem('countdown_username', currentUser);
  }

  // Update UI
  if(userBtn) userBtn.textContent = `üë§ ${currentUser}`;

  // 3. PRIVATE REFERENCES (Scoped to the user)
  const tasksRef = ref(db, `users/${currentUser}/tasks`);
  const subjectsRef = ref(db, `users/${currentUser}/subjects`);

  // 4. LOGOUT / SWITCH USER FUNCTION
  if(userBtn) {
    userBtn.onclick = () => {
      const switchUser = confirm(`You are logged in as "${currentUser}".\n\nDo you want to switch users?`);
      if (switchUser) {
        localStorage.removeItem('countdown_username');
        location.reload(); // Reload page to reset references
      }
    };
  }

  const COLORS = ['#667eea','#f59e0b','#10b981','#ec4899','#8b5cf6','#06b6d4','#ef4444','#84cc16'];
  const HEBREW_DAYS = ['◊ê◊≥', '◊ë◊≥', '◊í◊≥', '◊ì◊≥', '◊î◊≥', '◊ï◊≥', '◊©◊≥'];
  const HEBREW_MONTHS = ['◊ô◊†◊ï◊ê◊®', '◊§◊ë◊®◊ï◊ê◊®', '◊û◊®◊•', '◊ê◊§◊®◊ô◊ú', '◊û◊ê◊ô', '◊ô◊ï◊†◊ô', '◊ô◊ï◊ú◊ô', '◊ê◊ï◊í◊ï◊°◊ò', '◊°◊§◊ò◊û◊ë◊®', '◊ê◊ï◊ß◊ò◊ï◊ë◊®', '◊†◊ï◊ë◊û◊ë◊®', '◊ì◊¶◊û◊ë◊®'];

  const escapeHtml = (str) => String(str || '').replace(/[&<>"']/g, (c) => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  })[c]);

  const $ = id => document.getElementById(id);
  const eventList = $("eventList");
  const emptyState = $("emptyState");
  const eventName = $("eventName");
  const eventDate = $("eventDate");
  const eventReminder = $("eventReminder");
  const eventAlertModal = $("eventAlertModal");
  const closeAlertBtn = $("closeAlertBtn");
  const alertTitle = $("alertTitle");
  const alertMessage = $("alertMessage");
  const inputPanel = $("inputPanel");
  const addBtn = $("addBtn");
  const cancelBtn = $("cancelBtn");
  const clearBtn = $("clearBtn");
  const toggleSidebar = $("toggleSidebar");
  const sidebar = $("sidebar");
  const calendarGrid = $("calendarGrid");
  const calendarTitle = $("calendarTitle");
  const monthEventsEl = $("monthEvents");
  const monthEventsTitle = $("monthEventsTitle");
  const clearModal = $("clearModal");
  const confirmClearBtn = $("confirmClearBtn");
  const cancelClearModalBtn = $("cancelClearModalBtn");
const themeToggle = $("themeToggle");
  const togglePomodoro = $("togglePomodoro");
  const pomodoroOverlay = $("pomodoroOverlay");
  
  
  
  const eventNotes = $("eventNotes");
  const undoToast = $("undoToast");
  const undoToastMsg = $("undoToastMsg");
  const shortcutsModal = $("shortcutsModal");
  const shortcutsClose = $("shortcutsClose");
  const helpShortcuts = $("helpShortcuts");
  let shortcutsLastFocus = null;

  // Event delegation for main calendar: single handler instead of per-chip listeners
  if (calendarGrid) {
    calendarGrid.addEventListener('click', (e) => {
      const chip = e.target.closest('.calendar-event-chip');
      if (chip) {
        e.stopPropagation();
        const eventId = chip.dataset.eventId;
        if (eventId) {
          const eventRow = document.querySelector(`.event-row[data-id="${eventId}"]`);
          if (eventRow) {
            eventRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            eventRow.style.transition = 'background 0.3s';
            eventRow.style.background = 'var(--accent)';
            setTimeout(() => { eventRow.style.background = ''; }, 800);
          }
        }
        return;
      }

      const day = e.target.closest('.calendar-day:not(.other-month)');
      if (day) {
        const dateKey = day.dataset.date;
        if (!dateKey) return;
        openDayDrawer(dateKey);
      }
    });
  }
  const undoToastUndo = $("undoToastUndo");
  const pomodoroCard = $("pomodoroCard");
  const pomodoroTaskSelect = $("pomodoroTaskSelect");
  const pomodoroPresetsEls = Array.from(document.querySelectorAll('.pomodoro-preset'));
  const pomodoroFocusInput = $("pomodoroFocus");
  const pomodoroBreakInput = $("pomodoroBreak");
  const pomodoroLongInput = $("pomodoroLong");
  const pomodoroLongEveryInput = $("pomodoroLongEvery");
  const pomodoroAutoContinueEl = $("pomodoroAutoContinue");
  const pomodoroSoundEl = $("pomodoroSound");
  const pomodoroDisplay = $("pomodoroDisplay");
  const pomodoroMode = $("pomodoroMode");
  const pomodoroNext = $("pomodoroNext");
    const pomodoroProgress = $("pomodoroProgress");
    const pomodoroStart = $("pomodoroStart");
  const pomodoroSkip = $("pomodoroSkip");
  const pomodoroReset = $("pomodoroReset");
  const pomodoroSessionCount = $("pomodoroSessionCount");
  const pomodoroFocusMinutes = $("pomodoroFocusMinutes");
  const pomodoroStreak = $("pomodoroStreak");
  const pomodoroDayProgress = $("pomodoroDayProgress");
  const pomodoroDayLabel = $("pomodoroDayLabel");

  const STORAGE_KEYS = {
    THEME: 'countdown-theme',
    SIDEBAR_WIDTH: 'countdown-sidebar-width'
  };
  const CACHE_KEYS = {
    EVENTS: 'countdown-events-cache-v1',
    TASKS_PREFIX: 'countdown-tasks-cache-v1:',
    SUBJECTS_PREFIX: 'countdown-subjects-cache-v1:'
  };

  let editingId = null;
  let events = [];
  let eventsLoaded = false;
  let hasEventsCache = false;
  const eventsById = new Map();
  const refs = new Map();
  let tickerHandle = null;
  function getEventById(id) { return eventsById.get(id); }
  function upsertLocalEvent(id, data) {
    const existing = eventsById.get(id);
    if (existing) Object.assign(existing, data);
    else {
      const evt = { id, ...data };
      events.push(evt);
      eventsById.set(id, evt);
    }
  }
  let calendarRenderTimer = null;
  function scheduleCalendarRender() {
    if (calendarRenderTimer) return;
    const run = () => {
      calendarRenderTimer = null;
      renderCalendar();
    };
    if ('requestIdleCallback' in window) {
      calendarRenderTimer = requestIdleCallback(run, { timeout: 200 });
    } else {
      calendarRenderTimer = setTimeout(run, 0);
    }
  }
  let currentMonth = new Date();
  const pendingDeletes = new Map();
  let lastDeletedId = null;
  const DELETE_TIMEOUT_MS = 10000;
  const notifiedEvents = new Map();
  let pendingEventAlert = null;
  const reminderAudio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-software-interface-start-2574.mp3');
  reminderAudio.preload = 'auto';
  reminderAudio.volume = 0.6;

  const getActiveEvents = () => events.filter(evt => !pendingDeletes.has(evt.id));

  const readCache = (key) => {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items)) return null;
      return parsed.items;
    } catch (e) {
      return null;
    }
  };

  const writeCache = (key, items, limit) => {
    try {
      const payload = { ts: Date.now(), items: items.slice(0, limit) };
      localStorage.setItem(key, JSON.stringify(payload));
    } catch (e) {}
  };
  
  function requestNotificationPermission() {
    if (!("Notification" in window)) {
      console.warn("This browser does not support desktop notifications");
    } else if (Notification.permission === "default") {
      Notification.requestPermission();
    }
  }
  requestNotificationPermission();

  const setEventsLoading = (isLoading) => {
    if (!eventList) return;
    eventList.classList.toggle('loading', isLoading);
  };

  const syncBadge = $("syncBadge");
  const syncState = { events: false, tasks: false, subjects: false };
  const syncCacheUsed = { events: false, tasks: false, subjects: false };
  const updateSyncBadge = () => {
    if (!syncBadge) return;
    const hasCache = Object.values(syncCacheUsed).some(Boolean);
    const ready = syncState.events && syncState.tasks && syncState.subjects;
    const total = Object.keys(syncState).length;
    const readyCount = Object.values(syncState).filter(Boolean).length;
    const percent = Math.round((readyCount / total) * 100);
    const syncText = syncBadge.querySelector('.sync-text');
    if (syncText) syncText.textContent = ready ? 'Synced' : `Syncing ${percent}%`;
    syncBadge.classList.toggle('hidden', !hasCache || ready);
  };
  const markSyncReady = (key) => {
    syncState[key] = true;
    updateSyncBadge();
  };

  const showUndoToast = (name, id) => {
    undoToastMsg.textContent = `${name} deleted`;
    lastDeletedId = id;
    undoToast.classList.add('show');
  };

  const hideUndoToast = () => {
    lastDeletedId = null;
    undoToast.classList.remove('show');
  };
  
  const closeEventAlert = () => {
    if (eventAlertModal) eventAlertModal.classList.remove('open');
  };
  
  if (closeAlertBtn) {
    closeAlertBtn.onclick = closeEventAlert;
  }
  if (eventAlertModal) {
    eventAlertModal.addEventListener('click', (e) => {
      if (e.target === eventAlertModal) closeEventAlert();
    });
  }
  
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && pendingEventAlert) {
      showEventAlert(pendingEventAlert.title, pendingEventAlert.message, true);
      pendingEventAlert = null;
    }
  });

  undoToastUndo.onclick = () => {
    if (!lastDeletedId) return;
    const pending = pendingDeletes.get(lastDeletedId);
    if (pending) {
      clearTimeout(pending.timer);
      pendingDeletes.delete(lastDeletedId);
      render();
    }
    hideUndoToast();
  };

  function getEventColor(id) {

      const charCode = id.charCodeAt(id.length - 1);

      return COLORS[charCode % COLORS.length];

    }

  

    $("toggleSidebar").onclick = () => {

      const wasHidden = sidebar.classList.contains("hidden");

      sidebar.classList.toggle("hidden");

      // Reset to current month when opening sidebar

      if (wasHidden) {

        currentMonth = new Date();

        renderCalendar();

      }

    };

  

    // Dark mode toggle

    const initTheme = () => {

      const saved = localStorage.getItem(STORAGE_KEYS.THEME);

      if (saved === 'dark' || (!saved && window.matchMedia('(prefers-color-scheme: dark)').matches)) {

        document.body.classList.add('dark');

        themeToggle.textContent = '‚òÄÔ∏è';

      }

    };

    initTheme();

  themeToggle.onclick = () => {
    document.body.classList.toggle('dark');
    const isDark = document.body.classList.contains('dark');
    themeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    localStorage.setItem(STORAGE_KEYS.THEME, isDark ? 'dark' : 'light');
  };

  // Persist sidebar width
  const savedWidth = localStorage.getItem(STORAGE_KEYS.SIDEBAR_WIDTH);
  if (savedWidth) sidebar.style.width = savedWidth;

  const resizeObserver = new ResizeObserver(() => {
    localStorage.setItem(STORAGE_KEYS.SIDEBAR_WIDTH, sidebar.style.width || sidebar.offsetWidth + 'px');
  });
  resizeObserver.observe(sidebar);

  function parseLocal(value) {
    const match = String(value || "").match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})$/);
    if (!match) return null;
    const [, Y, Mo, D, H, Mi] = match;
    return new Date(+Y, +Mo - 1, +D, +H, +Mi, 0, 0);
  }

  function toLocalDatetime(isoString) {
    const d = new Date(isoString);
    const pad = n => String(n).padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  function toDateKey(date) {
    const d = new Date(date);
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }

  const cachedEvents = readCache(CACHE_KEYS.EVENTS);
  if (cachedEvents && cachedEvents.length) {
    events = cachedEvents;
    eventsById.clear();
    events.forEach(e => eventsById.set(e.id, e));
    hasEventsCache = true;
    syncCacheUsed.events = true;
    eventsLoaded = true;
    setEventsLoading(false);
    updateSyncBadge();
    render();
    scheduleCalendarRender();
    startTicker();
  }
  if (!hasEventsCache) setEventsLoading(true);

  function getMonthEvents() {
    const year = currentMonth.getFullYear();
    const month = currentMonth.getMonth();
    return getActiveEvents().filter(evt => {
      const d = new Date(evt.date);
      return d.getFullYear() === year && d.getMonth() === month;
    }).sort((a, b) => new Date(a.date) - new Date(b.date));
  }

  function renderMonthEventsList() {
    const monthEvents = getMonthEvents();
    monthEventsTitle.textContent = `◊ê◊ô◊®◊ï◊¢◊ô ${HEBREW_MONTHS[currentMonth.getMonth()]}`;

    if (monthEvents.length === 0) {
      monthEventsEl.innerHTML = '<div class="no-events-msg">◊ê◊ô◊ü ◊ê◊ô◊®◊ï◊¢◊ô◊ù ◊î◊ó◊ï◊ì◊©</div>';
      return;
    }

    monthEventsEl.innerHTML = monthEvents.map(evt => {
      const color = getEventColor(evt.id);
      const d = new Date(evt.date);
      const dateStr = `${d.getDate()}/${d.getMonth()+1} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      return `
        <div class="month-event-item" style="border-right-color: ${color}">
          <div class="month-event-color" style="background: ${color}"></div>
          <div class="month-event-info">
            <div class="month-event-name">${escapeHtml(evt.name)}</div>
            <div class="month-event-date">${dateStr}</div>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderCalendar() {
    const year = currentMonth.getFullYear();
    const month = currentMonth.getMonth();

    calendarTitle.textContent = `${HEBREW_MONTHS[month]} ${year}`;

    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDay = firstDay.getDay();
    const daysInMonth = lastDay.getDate();

    const today = new Date();
    const todayKey = toDateKey(today);

    // Build event map by date
    const eventsByDate = {};
    getActiveEvents().forEach(evt => {
      const key = toDateKey(evt.date);
      if (!eventsByDate[key]) eventsByDate[key] = [];
      eventsByDate[key].push(evt);
    });

    let html = '';

    // Day names
    for (let i = 0; i < 7; i++) {
      html += `<div class="calendar-day-name">${HEBREW_DAYS[i]}</div>`;
    }

    // Previous month days
    const prevMonth = new Date(year, month, 0);
    const prevDays = prevMonth.getDate();
    for (let i = startDay - 1; i >= 0; i--) {
      const day = prevDays - i;
      html += `<div class="calendar-day other-month"><div class="calendar-day-number">${day}</div></div>`;
    }

    // Current month days
    for (let day = 1; day <= daysInMonth; day++) {
      const dateKey = `${year}-${String(month+1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
      const isToday = dateKey === todayKey;
      const dayEvents = eventsByDate[dateKey] || [];

      let classes = 'calendar-day';
      if (isToday) classes += ' today';

      let eventsHtml = '<div class="calendar-day-events">';
      const maxShow = 2;
      const showTime = dayEvents.length > 1; // Show time when multiple events on same day
      dayEvents.slice(0, maxShow).forEach(evt => {
        const color = getEventColor(evt.id);
        const safeName = escapeHtml(evt.name);
        const evtDate = new Date(evt.date);
        const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2,'0')}:${String(evtDate.getMinutes()).padStart(2,'0')} ` : '';
        const displayText = timeStr + safeName;
        eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-event-id="${evt.id}">${displayText}</div>`;
      });
      if (dayEvents.length > maxShow) {
        eventsHtml += `<div class="calendar-more">+${dayEvents.length - maxShow} ◊¢◊ï◊ì</div>`;
      }
      eventsHtml += '</div>';

      html += `<div class="${classes}" data-date="${dateKey}">
        <div class="calendar-day-number">${day}</div>
        ${eventsHtml}
      </div>`;
    }

    // Next month days
    const totalCells = startDay + daysInMonth;
    const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
    for (let i = 1; i <= remainingCells; i++) {
      html += `<div class="calendar-day other-month"><div class="calendar-day-number">${i}</div></div>`;
    }

    calendarGrid.innerHTML = html;
    renderMonthEventsList();
  }
  
  // Day Drawer functionality
  const dayDrawer = $("dayDrawer");
  const dayDrawerTitle = $("dayDrawerTitle");
  const dayDrawerSubtitle = $("dayDrawerSubtitle");
  const dayEventsList = $("dayEventsList");
  const dayTasksList = $("dayTasksList");
  const dayEventsCount = $("dayEventsCount");
  const dayTasksCount = $("dayTasksCount");
  const closeDayDrawerBtn = $("closeDayDrawer");
  const addEventToDay = $("addEventToDay");
  const addTaskToDay = $("addTaskToDay");
  
  let selectedDayKey = null;
  
  function openDayDrawer(dateKey) {
    selectedDayKey = dateKey;
    const [year, month, day] = dateKey.split('-').map(Number);
    const date = new Date(year, month - 1, day);
    
    // Format title (Hebrew day + date)
    const dayOfWeek = date.getDay();
    const hebrewDayNames = ['◊ô◊ï◊ù ◊®◊ê◊©◊ï◊ü', '◊ô◊ï◊ù ◊©◊†◊ô', '◊ô◊ï◊ù ◊©◊ú◊ô◊©◊ô', '◊ô◊ï◊ù ◊®◊ë◊ô◊¢◊ô', '◊ô◊ï◊ù ◊ó◊û◊ô◊©◊ô', '◊ô◊ï◊ù ◊©◊ô◊©◊ô', '◊©◊ë◊™'];
    dayDrawerTitle.textContent = hebrewDayNames[dayOfWeek];
    dayDrawerSubtitle.textContent = `${day} ◊ë${HEBREW_MONTHS[month - 1]} ${year}`;
    
    // Get events for this day
    const dayEvents = getActiveEvents().filter(evt => toDateKey(evt.date) === dateKey)
      .sort((a, b) => new Date(a.date) - new Date(b.date));
    
    // Get tasks due this day (need to access tasks array from task manager scope)
    const allTasks = (typeof tasks !== 'undefined' && Array.isArray(tasks)) ? tasks : [];
    const dayTasks = allTasks.filter(task => {
      if (!task.dueDate) return false;
      return toDateKey(task.dueDate) === dateKey;
    }).sort((a, b) => {
      // Sort by completed, then priority
      if (a.completed !== b.completed) return a.completed ? 1 : -1;
      const PRIORITY_ORDER = { urgent: 0, high: 1, medium: 2, low: 3, none: 4 };
      return (PRIORITY_ORDER[a.priority] || 4) - (PRIORITY_ORDER[b.priority] || 4);
    });
    
    // Update counts
    dayEventsCount.textContent = dayEvents.length;
    dayTasksCount.textContent = dayTasks.length;
    
    // Render events
    if (dayEvents.length === 0) {
      dayEventsList.innerHTML = '<div class="day-drawer-empty">◊ê◊ô◊ü ◊ê◊ô◊®◊ï◊¢◊ô◊ù ◊ë◊ô◊ï◊ù ◊ñ◊î</div>';
    } else {
      dayEventsList.innerHTML = dayEvents.map(evt => {
        const color = getEventColor(evt.id);
        const evtDate = new Date(evt.date);
        const timeStr = `${String(evtDate.getHours()).padStart(2,'0')}:${String(evtDate.getMinutes()).padStart(2,'0')}`;
        return `
          <div class="day-drawer-item" data-event-id="${evt.id}">
            <div class="day-drawer-item-color" style="background: ${color}"></div>
            <div class="day-drawer-item-info">
              <div class="day-drawer-item-name">${escapeHtml(evt.name)}</div>
              <div class="day-drawer-item-time">üïê ${timeStr}</div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Render tasks
    if (dayTasks.length === 0) {
      dayTasksList.innerHTML = '<div class="day-drawer-empty">◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊ë◊ô◊ï◊ù ◊ñ◊î</div>';
    } else {
      const PRIORITY_COLORS = { urgent: '#ef4444', high: '#f97316', medium: '#eab308', low: '#22c55e', none: '#6b7280' };
      const PRIORITY_BG = { urgent: 'rgba(239,68,68,0.15)', high: 'rgba(249,115,22,0.15)', medium: 'rgba(234,179,8,0.15)', low: 'rgba(34,197,94,0.15)', none: 'var(--day-other)' };
      const PRIORITY_LABELS_HE = { urgent: '◊ì◊ó◊ï◊£', high: '◊í◊ë◊ï◊î', medium: '◊ë◊ô◊†◊ï◊†◊ô', low: '◊†◊û◊ï◊ö', none: '' };
      
      dayTasksList.innerHTML = dayTasks.map(task => {
        const priority = task.priority || 'none';
        const priorityLabel = PRIORITY_LABELS_HE[priority];
        const completedClass = task.completed ? 'task-completed' : '';
        const due = task.dueDate ? new Date(task.dueDate) : null;
        const timeStr = due ? `${String(due.getHours()).padStart(2,'0')}:${String(due.getMinutes()).padStart(2,'0')}` : '';
        
        return `
          <div class="day-drawer-item ${completedClass}" data-task-id="${task.id}">
            <div class="day-drawer-item-color" style="background: ${PRIORITY_COLORS[priority]}"></div>
            <div class="day-drawer-item-info">
              <div class="day-drawer-item-name">${escapeHtml(task.title)}</div>
              ${timeStr ? `<div class="day-drawer-item-time">üïê ${timeStr}</div>` : ''}
            </div>
            ${priorityLabel ? `<div class="day-drawer-item-priority" style="background: ${PRIORITY_BG[priority]}; color: ${PRIORITY_COLORS[priority]}">${priorityLabel}</div>` : ''}
          </div>
        `;
      }).join('');
    }
    
    // Add click handlers for items
    dayEventsList.querySelectorAll('.day-drawer-item').forEach(item => {
      item.addEventListener('click', () => {
        const eventId = item.dataset.eventId;
        if (eventId) {
          closeDayDrawer();
          // Scroll to event in main list
          setTimeout(() => {
            const eventRow = document.querySelector(`.event-row[data-id="${eventId}"]`);
            if (eventRow) {
              eventRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
              eventRow.style.transition = 'background 0.3s';
              eventRow.style.background = 'var(--accent)';
              setTimeout(() => { eventRow.style.background = ''; }, 800);
            }
          }, 200);
        }
      });
    });
    
    dayTasksList.querySelectorAll('.day-drawer-item').forEach(item => {
      item.addEventListener('click', () => {
        const taskId = item.dataset.taskId;
        if (taskId) {
          closeDayDrawer();
          // Open task manager and highlight task
          setTimeout(() => {
            if (typeof showView === 'function' && currentView !== 'tasks') {
              showView('tasks');
            } else {
              const tmOverlay = $("taskManagerOverlay");
              if (tmOverlay && !tmOverlay.classList.contains('open')) {
                tmOverlay.classList.add('open');
                if (typeof renderSubjectsSidebar === 'function') renderSubjectsSidebar();
                if (typeof renderTasks === 'function') renderTasks();
                if (typeof startTaskTicker === 'function') startTaskTicker();
              }
            }
            setTimeout(() => {
              const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
              if (taskItem) {
                taskItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                taskItem.style.transition = 'box-shadow 0.3s';
                taskItem.style.boxShadow = '0 0 0 3px var(--accent)';
                setTimeout(() => { taskItem.style.boxShadow = ''; }, 1000);
              }
            }, 300);
          }, 200);
        }
      });
    });
    
    dayDrawer.classList.add('open');
  }
  
  function closeDayDrawer() {
    dayDrawer.classList.remove('open');
    selectedDayKey = null;
  }
  
  closeDayDrawerBtn.onclick = closeDayDrawer;
  
  // Close on backdrop click
  dayDrawer.addEventListener('click', (e) => {
    if (e.target === dayDrawer) closeDayDrawer();
  });
  
  // Add event to selected day
  addEventToDay.onclick = () => {
    if (!selectedDayKey) return;
    const dateToUse = selectedDayKey; // Save before closing
    closeDayDrawer();
    eventDate.value = dateToUse + 'T12:00';
    eventName.focus();
    inputPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  };
  
  // Add task to selected day
  addTaskToDay.onclick = () => {
    if (!selectedDayKey) return;
    const dateToUse = selectedDayKey; // Save before closing
    closeDayDrawer();
    // Open task manager
    if (typeof showView === 'function' && currentView !== 'tasks') {
      showView('tasks');
    } else {
      const tmOverlay = $("taskManagerOverlay");
      if (tmOverlay) {
        tmOverlay.classList.add('open');
        if (typeof renderSubjectsSidebar === 'function') renderSubjectsSidebar();
        if (typeof renderTasks === 'function') renderTasks();
        if (typeof startTaskTicker === 'function') startTaskTicker();
      }
    }
    // Pre-fill the due date
    setTimeout(() => {
      const taskDueInput = $("newTaskDue");
      const taskTitleInput = $("newTaskTitle");
      const quickRow = $("quickAddRow");
      if (taskDueInput) taskDueInput.value = dateToUse + 'T23:59';
      if (taskTitleInput) taskTitleInput.focus();
      if (quickRow) quickRow.style.display = 'flex';
    }, 200);
  };

  $("prevMonth").onclick = () => {
    currentMonth.setMonth(currentMonth.getMonth() - 1);
    renderCalendar();
  };

  $("nextMonth").onclick = () => {
    currentMonth.setMonth(currentMonth.getMonth() + 1);
    renderCalendar();
  };
  
  // Today button - jump to current month
  const todayBtn = $("todayBtn");
  if (todayBtn) {
    todayBtn.onclick = () => {
      currentMonth = new Date();
      renderCalendar();
    };
  }

  onValue(eventsRef, (snapshot) => {
    const data = snapshot.val();
    eventsById.clear();
    if (data) {
      events = Object.keys(data).map(key => ({ id: key, ...data[key] }));
      events.forEach(e => eventsById.set(e.id, e));
    } else {
      events = [];
    }
    eventsLoaded = true;
    markSyncReady('events');
    writeCache(CACHE_KEYS.EVENTS, events, 300);
    setEventsLoading(false);
    render();
    startTicker();
    // Defer heavy calendar render so list paints first
    scheduleCalendarRender();
  }, (error) => {
    console.error('Events sync error:', error);
    eventsLoaded = true;
    markSyncReady('events');
    setEventsLoading(false);
    updateSyncBadge();
  });

  const saveToCloud = async (eventData) => {
    const newEventRef = push(eventsRef);
    const id = newEventRef.key;

    // Optimistic UI
    upsertLocalEvent(id, eventData);
    render();
    scheduleCalendarRender();
    startTicker();
    writeCache(CACHE_KEYS.EVENTS, events, 300);

    try {
      await set(newEventRef, eventData);
    } catch (err) {
      // Rollback on failure
      events = events.filter(e => e.id !== id);
      eventsById.delete(id);
      render();
      scheduleCalendarRender();
      console.error(err);
      alert("Save failed (check connection).");
    }
  };

  const updateInCloud = async (id, data) => {
    const { id: _ignore, ...payload } = data;
    const prev = eventsById.get(id) ? { ...eventsById.get(id) } : null;

    // Optimistic UI
    upsertLocalEvent(id, payload);
    render();
    scheduleCalendarRender();
    writeCache(CACHE_KEYS.EVENTS, events, 300);

    try {
      await set(ref(db, 'events/' + id), payload);
    } catch (err) {
      // Rollback
      if (prev) upsertLocalEvent(id, prev);
      render();
      scheduleCalendarRender();
      console.error(err);
      alert("Update failed (check connection).");
    }
  };

  const deleteFromCloud = (id) => {
    remove(ref(db, 'events/' + id));
  };

  const clearAllCloud = () => {
    set(eventsRef, null);
  };

  function formatDate(iso) {
    return new Date(iso).toLocaleString(undefined, {
      weekday: 'short', month: 'short', day: 'numeric',
      hour: '2-digit', minute: '2-digit'
    });
  }
  
  function formatReminderOffset(minutes) {
    if (minutes >= 1440) {
      const days = Math.round(minutes / 1440);
      return days === 1 ? '1 day' : `${days} days`;
    }
    if (minutes >= 60) {
      const hours = Math.round(minutes / 60);
      return hours === 1 ? '1 hour' : `${hours} hours`;
    }
    return minutes === 1 ? '1 minute' : `${minutes} minutes`;
  }
  
  function playReminderSound() {
    if (!reminderAudio) return;
    reminderAudio.currentTime = 0;
    reminderAudio.play().catch(() => {
      console.log("Audio play failed (interaction needed)");
    });
  }
  
  function showEventAlert(title, message, playSound = false) {
    if (!eventAlertModal) return;
    if (alertTitle) alertTitle.textContent = title;
    if (alertMessage) alertMessage.textContent = message;
    eventAlertModal.classList.add('open');
    if (playSound) playReminderSound();
  }
  
  function triggerAlert(evt) {
    const reminderMinutes = parseInt(evt.reminder, 10) || 0;
    const timeString = formatReminderOffset(reminderMinutes);
    const msg = `${evt.name} starts in ${timeString}!`;
    
    if (document.hidden) {
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification("Event Reminder ‚è∞", {
          body: msg,
          icon: "https://cdn-icons-png.flaticon.com/512/2693/2693507.png"
        });
      }
      pendingEventAlert = { title: evt.name, message: `Starting in ${timeString}` };
      return;
    }
    
    showEventAlert(evt.name, `Starting in ${timeString}`, true);
  }

  function calcTime(target) {
    const diff = Math.max(0, new Date(target).getTime() - Date.now());
    return {
      ended: diff === 0,
      d: Math.floor(diff / 86400000),
      h: Math.floor((diff % 86400000) / 3600000),
      m: Math.floor((diff % 3600000) / 60000),
      s: Math.floor((diff % 60000) / 1000)
    };
  }

  function startEdit(id) {
    const evt = events.find(e => e.id === id);
    if (!evt) return;

    editingId = id;
    eventName.value = evt.name;
    eventDate.value = toLocalDatetime(evt.date);
    eventNotes.value = evt.notes || '';
    if (eventReminder) eventReminder.value = evt.reminder || 0;
    addBtn.textContent = "Save";
    cancelBtn.style.display = "block";
    clearBtn.style.display = "none";
    inputPanel.classList.add("editing");
    eventName.focus();
  }

  function cancelEdit() {
    editingId = null;
    eventName.value = "";
    eventDate.value = "";
    eventNotes.value = "";
    if (eventReminder) eventReminder.value = 0;
    addBtn.textContent = "Add Event";
    cancelBtn.style.display = "none";
    clearBtn.style.display = "block";
    inputPanel.classList.remove("editing");
  }

  function render() {
    refs.clear();
    const frag = document.createDocumentFragment();
    // Use getActiveEvents() to account for pending deletes
    emptyState.style.display = getActiveEvents().length ? "none" : "block";

    const now = Date.now();

    const sorted = [...events].filter(e => !pendingDeletes.has(e.id)).sort((a, b) => {
      // First sort by pinned status
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      
      // Then by time
      const aTime = new Date(a.date).getTime();
      const bTime = new Date(b.date).getTime();
      const aEnded = aTime <= now;
      const bEnded = bTime <= now;

      if (!aEnded && bEnded) return -1;
      if (aEnded && !bEnded) return 1;
      return aTime - bTime;
    });

    const conflicts = findConflictingEvents(sorted);

    sorted.forEach((evt) => {
      const color = getEventColor(evt.id);
      const t = calcTime(evt.date);
      const hasConflict = conflicts.has(evt.id);

      const row = document.createElement("div");
      row.className = `event-row ${evt.highlighted ? 'highlighted' : ''}`;
      row.dataset.id = evt.id;

      if (evt.highlighted) {
        row.style.background = color + '12';
        row.style.borderColor = color;
      }

      const dot = document.createElement("span");
      dot.className = "color-dot";
      dot.style.background = color;

      const info = document.createElement("div");
      info.className = "event-info";

      const name = document.createElement("div");
      name.className = "event-name";
      name.textContent = evt.name;

      const date = document.createElement("div");
      date.className = "event-date";
      date.dataset.iso = evt.date;
      date.textContent = formatDate(evt.date);

      info.appendChild(name);
      info.appendChild(date);

      if (hasConflict) {
        const conflict = document.createElement("div");
        conflict.className = "conflict-badge";
        conflict.innerHTML = `<span class="conflict-dot"></span><span>◊ó◊§◊ô◊§◊î ◊¢◊ù ◊ê◊ô◊®◊ï◊¢ ◊ß◊®◊ï◊ë</span>`;
        info.appendChild(conflict);
      }

      if (evt.notes) {
        const notes = document.createElement("div");
        notes.className = "event-notes";
        notes.textContent = evt.notes;
        info.appendChild(notes);
        if (evt.notes.length > 60 || evt.notes.includes('\n')) {
          const toggle = document.createElement("span");
          toggle.className = "notes-toggle";
          toggle.textContent = "◊î◊¶◊í ◊¢◊ï◊ì";
          toggle.onclick = (e) => {
            e.stopPropagation();
            notes.classList.toggle('expanded');
            toggle.textContent = notes.classList.contains('expanded') ? "◊î◊°◊™◊®" : "◊î◊¶◊í ◊¢◊ï◊ì";
          };
          info.appendChild(toggle);
        }
      }

      const timer = document.createElement("div");
      timer.className = "timer";

      const units = [
        { key: 'd', label: 'Days' },
        { key: 'h', label: 'Hrs' },
        { key: 'm', label: 'Min' },
        { key: 's', label: 'Sec' }
      ];

      units.forEach(({ key, label }) => {
        const unit = document.createElement("div");
        unit.className = "time-unit";

        const val = document.createElement("span");
        val.className = `time-val time-${key}`;
        val.style.color = color;
        val.textContent = key === 'd' ? t[key] : String(t[key]).padStart(2, '0');

        const lbl = document.createElement("div");
        lbl.className = "time-label";
        lbl.textContent = label;

        unit.appendChild(val);
        unit.appendChild(lbl);
        timer.appendChild(unit);
      });

      const badge = document.createElement("span");
      badge.className = `badge ${t.ended ? 'badge-ended' : 'badge-upcoming'}`;
      badge.textContent = t.ended ? 'Ended' : 'Upcoming';

      const starBtn = document.createElement("button");
      starBtn.className = `star-btn ${evt.highlighted ? 'active' : ''}`;
      starBtn.textContent = "‚òÜ";

      const pinBtn = document.createElement("button");
      pinBtn.className = `pin-btn ${evt.pinned ? 'pinned' : ''}`;
      pinBtn.textContent = "üìå";
      pinBtn.title = evt.pinned ? "Unpin" : "Pin to top";

      const editBtn = document.createElement("button");
      editBtn.className = "edit-btn";
      editBtn.textContent = "‚úé";
      editBtn.title = "Edit";

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-btn";
      deleteBtn.textContent = "√ó";

      const actions = document.createElement("div");
      actions.className = "event-actions";
      actions.appendChild(pinBtn);
      actions.appendChild(starBtn);
      actions.appendChild(editBtn);
      actions.appendChild(deleteBtn);

      row.appendChild(dot);
      row.appendChild(timer);
      row.appendChild(badge);
      row.appendChild(info);
      row.appendChild(actions);

      enableInlineEventTitle(name, evt.id);
      enableInlineEventDate(date, evt.id);
      
      // Right-click context menu for events
      row.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showEventContextMenu(e.clientX, e.clientY, evt.id);
      });

      refs.set(evt.id, {
        row,
        dEl: row.querySelector(".time-d"),
        hEl: row.querySelector(".time-h"),
        mEl: row.querySelector(".time-m"),
        sEl: row.querySelector(".time-s"),
        badge: badge,
        target: new Date(evt.date).getTime()
      });

      frag.appendChild(row);
    });

    eventList.replaceChildren(frag);

    tick();
  }

  function findConflictingEvents(list, thresholdMinutes = 30) {
    if (!Array.isArray(list) || list.length < 2) return new Set();
    const thresholdMs = thresholdMinutes * 60000;
    // Assume `list` is already sorted by date (render() prepares a sorted list)
    const conflicts = new Set();
    for (let i = 0; i < list.length - 1; i++) {
      const current = list[i];
      const next = list[i + 1];
      const diff = Math.abs(new Date(next.date) - new Date(current.date));
      if (diff < thresholdMs) {
        conflicts.add(current.id);
        conflicts.add(next.id);
      }
    }
    return conflicts;
  }

  function inlineEdit(el, { type = 'text', value = '', className = 'inline-edit-input', step, onSave }) {
    el.style.cursor = 'text';
    el.addEventListener('click', (e) => {
      e.stopPropagation();
      if (el.dataset.editing === '1') return;
      el.dataset.editing = '1';

      const input = document.createElement('input');
      input.type = type;
      input.value = value;
      input.className = className;
      if (step) input.step = step;

      const original = el.textContent;
      el.replaceWith(input);
      input.focus();
      input.select();

      let cancelled = false;
      const finish = (commit) => {
        if (input.parentElement) input.replaceWith(el);
        delete el.dataset.editing;
        if (commit && typeof onSave === 'function') onSave(input.value, original, el);
      };

      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') finish(true);
        else if (ev.key === 'Escape') {
          cancelled = true;
          finish(false);
        }
      });
      input.addEventListener('blur', () => finish(!cancelled));
    });
  }

  function enableInlineEventTitle(el, eventId) {
    inlineEdit(el, {
      value: el.textContent.trim(),
      onSave: (val, original) => {
        const newName = val.trim();
        const evt = events.find(e => e.id === eventId);
        if (!evt || !newName) {
          el.textContent = original;
          return;
        }
        el.textContent = newName;
        updateInCloud(eventId, { ...evt, name: newName });
      }
    });
  }

  function enableInlineEventDate(el, eventId) {
    inlineEdit(el, {
      type: 'datetime-local',
      value: toLocalDatetime(el.dataset.iso || events.find(e => e.id === eventId)?.date || new Date().toISOString()),
      className: 'inline-edit-input small',
      step: 60,
      onSave: (val, original) => {
        const parsed = parseLocal(val);
        const evt = events.find(e => e.id === eventId);
        if (!evt || !parsed || isNaN(parsed.getTime())) {
          el.textContent = original;
          return;
        }
        const iso = parsed.toISOString();
        el.textContent = formatDate(iso);
        el.dataset.iso = iso;
        updateInCloud(eventId, { ...evt, date: iso });
      }
    });
  }

  function tick() {
    const now = Date.now();

    refs.forEach((ref) => {
      const diff = Math.max(0, ref.target - now);
      const ended = diff === 0;

      const d = Math.floor(diff / 86400000);
      const h = Math.floor((diff % 86400000) / 3600000);
      const m = Math.floor((diff % 3600000) / 60000);
      const s = Math.floor((diff % 60000) / 1000);

      ref.dEl.textContent = d;
      ref.hEl.textContent = String(h).padStart(2, '0');
      ref.mEl.textContent = String(m).padStart(2, '0');
      ref.sEl.textContent = String(s).padStart(2, '0');

      ref.badge.className = `badge ${ended ? 'badge-ended' : 'badge-upcoming'}`;
      ref.badge.textContent = ended ? 'Ended' : 'Upcoming';
    });

    const nowMs = now;
    getActiveEvents().forEach(evt => {
      const reminderMinutes = parseInt(evt.reminder, 10) || 0;
      if (!reminderMinutes) return;
      const reminderKey = `${evt.date || ''}|${reminderMinutes}`;
      if (notifiedEvents.get(evt.id) === reminderKey) return;
      const eventTime = new Date(evt.date).getTime();
      if (!Number.isFinite(eventTime)) return;
      const triggerTime = eventTime - (reminderMinutes * 60000);
      if (nowMs >= triggerTime && nowMs < triggerTime + 60000) {
        triggerAlert(evt);
        notifiedEvents.set(evt.id, reminderKey);
      }
    });
  }

  function startTicker() {
    if (tickerHandle) return; // already running
    const loop = () => {
      tick();
      const msToNext = 1000 - (Date.now() % 1000);
      tickerHandle = setTimeout(loop, msToNext);
    };
    loop();
  }

  addBtn.onclick = () => {
    const name = eventName.value.trim();
    const dateValue = eventDate.value;
    const notes = eventNotes.value.trim();
    const reminderVal = parseInt(eventReminder?.value, 10) || 0;

    if (!name || !dateValue) {
      alert("Please enter both event name and date");
      return;
    }

    const parsedDate = parseLocal(dateValue);
    if (!parsedDate || isNaN(parsedDate.getTime())) {
      alert("Invalid date");
      return;
    }

    if (editingId) {
      const evt = events.find(e => e.id === editingId);
      updateInCloud(editingId, {
        name,
        date: parsedDate.toISOString(),
        notes: notes || null,
        reminder: reminderVal,
        highlighted: evt ? evt.highlighted : false,
        pinned: evt ? evt.pinned : false
      });
      cancelEdit();
    } else {
      saveToCloud({
        name,
        date: parsedDate.toISOString(),
        notes: notes || null,
        reminder: reminderVal,
        highlighted: false,
        pinned: false
      });
      eventName.value = "";
      eventDate.value = "";
      eventNotes.value = "";
      if (eventReminder) eventReminder.value = 0;
      eventName.focus();
    }
  };

  cancelBtn.onclick = cancelEdit;

  eventName.onkeypress = e => {
    if (e.key === 'Enter') addBtn.click();
  };

  eventDate.onkeypress = e => {
    if (e.key === 'Enter') addBtn.click();
  };

  // Auto-advance: when datetime-local value is complete, focus stays for time editing
  eventDate.addEventListener('input', () => {
    const val = eventDate.value;
    // datetime-local format: YYYY-MM-DDTHH:MM
    if (val && val.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/)) {
      // Value is complete - user can now adjust time or press Enter
      // No action needed, browser handles focus within datetime-local
    }
  });

  const openClearModal = () => {
    if (!events.length) return;
    clearModal.classList.add("open");
  };

  const closeClearModal = () => {
    clearModal.classList.remove("open");
  };

  clearBtn.onclick = openClearModal;
  cancelClearModalBtn.onclick = closeClearModal;
  confirmClearBtn.onclick = () => {
    clearAllCloud();
    closeClearModal();
  };

  clearModal.addEventListener("click", (e) => {
    if (e.target === clearModal) closeClearModal();
  });

  const isEditableTarget = (el) => {
    if (!el) return false;
    const tag = el.tagName;
    return el.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
  };

  const openShortcuts = () => {
    if (!shortcutsModal) return;
    shortcutsLastFocus = document.activeElement;
    shortcutsModal.classList.add('open');
  };

  const closeShortcuts = () => {
    if (!shortcutsModal) return;
    shortcutsModal.classList.remove('open');
    if (shortcutsLastFocus && typeof shortcutsLastFocus.focus === 'function') {
      shortcutsLastFocus.focus();
    }
    shortcutsLastFocus = null;
  };

  const toggleShortcuts = () => {
    if (!shortcutsModal) return;
    shortcutsModal.classList.contains('open') ? closeShortcuts() : openShortcuts();
  };

  if (shortcutsClose) shortcutsClose.onclick = closeShortcuts;
  if (shortcutsModal) {
    shortcutsModal.addEventListener('click', (e) => {
      if (e.target === shortcutsModal) closeShortcuts();
    });
  }
  if (helpShortcuts) helpShortcuts.onclick = openShortcuts;

  const focusQuickAdd = () => {
    if (currentView === 'tasks') {
      if (quickAddRow) quickAddRow.style.display = 'flex';
      if (newTaskTitle) {
        newTaskTitle.focus();
        if (typeof newTaskTitle.select === 'function') newTaskTitle.select();
      }
      return;
    }
    if (typeof showView === 'function' && currentView !== 'countdown') showView('countdown');
    if (eventName) {
      eventName.focus();
      if (typeof eventName.select === 'function') eventName.select();
    }
    if (inputPanel) inputPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  };

  const goToToday = () => {
    if (currentView === 'tasks') {
      currentTaskMonth = new Date();
      if (typeof renderTaskCalendar === 'function') renderTaskCalendar();
      return;
    }
    if (typeof showView === 'function' && currentView !== 'countdown') showView('countdown');
    currentMonth = new Date();
    renderCalendar();
  };

  const openPomodoro = () => {
    if (typeof showView === 'function') showView('pomodoro');
  };

  const toggleCalendarSidebar = () => {
    if (typeof showView === 'function' && currentView !== 'countdown') showView('countdown');
    const toggleBtn = $("toggleSidebar");
    if (toggleBtn) toggleBtn.click();
  };

  const openTasksView = () => {
    if (typeof showView === 'function') showView('tasks');
  };

  const openCountdownView = () => {
    if (typeof showView === 'function') showView('countdown');
  };

  const focusTaskSearch = () => {
    if (typeof showView === 'function' && currentView !== 'tasks') showView('tasks');
    if (taskSearch) {
      taskSearch.focus();
      if (typeof taskSearch.select === 'function') taskSearch.select();
    }
  };

  const toggleTheme = () => {
    if (themeToggle) themeToggle.click();
  };

  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'h' && !isEditableTarget(e.target)) {
      e.preventDefault();
      toggleShortcuts();
      return;
    }
    if (e.metaKey || e.ctrlKey || e.altKey) return;
    if (isEditableTarget(e.target)) return;
    const key = e.key.toLowerCase();
    if (key === 'n') {
      e.preventDefault();
      focusQuickAdd();
    } else if (key === 't') {
      e.preventDefault();
      goToToday();
    } else if (key === 'p') {
      e.preventDefault();
      openPomodoro();
    } else if (key === 'c') {
      e.preventDefault();
      toggleCalendarSidebar();
    } else if (key === 'm') {
      e.preventDefault();
      openTasksView();
    } else if (key === 'g') {
      e.preventDefault();
      openCountdownView();
    } else if (key === '/') {
      e.preventDefault();
      focusTaskSearch();
    } else if (key === 'd') {
      e.preventDefault();
      toggleTheme();
    }
  });

  // Escape key handler (consolidated)
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (shortcutsModal && shortcutsModal.classList.contains('open')) {
        closeShortcuts();
        return;
      }
      // Close context menus first (highest priority)
      if (typeof hideContextMenu === 'function') hideContextMenu();
      if (typeof hideAddEventContextMenu === 'function') hideAddEventContextMenu();
      if (typeof hideEventContextMenu === 'function') hideEventContextMenu();
      
      // Task edit modal (check first since it's on top)
      const tEditModal = $("taskEditModal");
      if (tEditModal && tEditModal.classList.contains('open')) {
        if (typeof closeTaskEditModal === 'function') closeTaskEditModal();
        return;
      }
      // Task manager overlay - go back to countdown
      const tmOverlay = $("taskManagerOverlay");
      if (tmOverlay && tmOverlay.classList.contains('open')) {
        if (typeof showView === 'function') showView('countdown');
        return;
      }
      // Pomodoro overlay - go back to countdown
      const pOverlay = $("pomodoroOverlay");
      if (pOverlay && pOverlay.classList.contains('open')) {
        if (typeof showView === 'function') showView('countdown');
        return;
      }
      if (eventAlertModal && eventAlertModal.classList.contains('open')) {
        closeEventAlert();
        return;
      }
      // Day drawer
      if (dayDrawer.classList.contains('open')) {
        closeDayDrawer();
        return;
      }
      // Clear modal
      if (clearModal.classList.contains('open')) {
        closeClearModal();
        return;
      }
      // Event editing
      if (editingId) {
        cancelEdit();
        return;
      }
    }
  });

  eventList.onclick = e => {
    const row = e.target.closest(".event-row");
    if (!row) return;
    const id = row.dataset.id;

    if (e.target.classList.contains("delete-btn")) {
      if (editingId === id) cancelEdit();
      const existing = pendingDeletes.get(id);
      if (existing) clearTimeout(existing.timer);
      const evt = events.find(evt => evt.id === id);
      const timer = setTimeout(() => {
        deleteFromCloud(id);
        pendingDeletes.delete(id);
        if (lastDeletedId === id) hideUndoToast();
      }, DELETE_TIMEOUT_MS);
      pendingDeletes.set(id, { timer });
      render();
      showUndoToast(evt ? evt.name : 'Event', id);
    } else if (e.target.classList.contains("edit-btn")) {
      startEdit(id);
    } else if (e.target.classList.contains("star-btn")) {
      const evt = events.find(evt => evt.id === id);
      if (evt) {
        updateInCloud(id, { ...evt, highlighted: !evt.highlighted });
      }
    } else if (e.target.classList.contains("pin-btn")) {
      const evt = events.find(evt => evt.id === id);
      if (evt) {
        updateInCloud(id, { ...evt, pinned: !evt.pinned });
      }
    }
  };

  renderCalendar();
  startTicker();

  

  // ============ TASK MANAGER ============

  const taskManagerOverlay = $("taskManagerOverlay");
  
    const closeTaskManager = $("closeTaskManager");
  
    const toggleTasks = $("toggleTasks");
  const taskSearch = $("taskSearch");
  const quickAddTask = $("quickAddTask");
  const quickAddRow = $("quickAddRow");
  const newTaskTitle = $("newTaskTitle");
  const newTaskDue = $("newTaskDue");
  const newTaskRecurrence = $("newTaskRecurrence");
  const newTaskSubject = $("newTaskSubject");
  const addTaskBtn = $("addTaskBtn");
  const taskPriorityPicker = $("taskPriorityPicker");
  const activeTasks = $("activeTasks");
  const completedTasks = $("completedTasks");
  const activeSection = $("activeSection");
  const completedSection = $("completedSection");
  const tasksEmpty = $("tasksEmpty");
  const taskEditModal = $("taskEditModal");
  const editTaskTitle = $("editTaskTitle");
  const editTaskContent = $("editTaskContent");
  const editTaskChecklist = $("editTaskChecklist");
  const newChecklistItem = $("newChecklistItem");
  const addChecklistItem = $("addChecklistItem");
  const editTaskPriority = $("editTaskPriority");
  const editTaskDue = $("editTaskDue");
  const editTaskRecurrence = $("editTaskRecurrence");
  const editTaskSubject = $("editTaskSubject");
  const clearDueBtn = $("clearDueBtn");
  const duplicateTaskBtn = $("duplicateTaskBtn");
  const deleteTaskBtn = $("deleteTaskBtn");
  const saveTaskBtn = $("saveTaskBtn");
  const quickTaskColorPicker = $("quickTaskColorPicker");
  const taskColorPicker = $("taskColorPicker");
  
  // Limit year input to 4 digits for all datetime-local inputs
  const dateInputs = [eventDate, newTaskDue, editTaskDue];
  dateInputs.forEach(input => {
    if (!input) return;
    
    input.addEventListener('input', (e) => {
      const value = e.target.value;
      if (!value) return;
      
      // Check if year exceeds 4 digits
      const yearMatch = value.match(/^(\d+)-/);
      if (yearMatch && yearMatch[1].length > 4) {
        // Truncate to 4 digits
        const truncatedYear = yearMatch[1].substring(0, 4);
        e.target.value = value.replace(/^\d+-/, truncatedYear + '-');
      }
    });
    
    // Also set max attribute
    input.setAttribute('max', '9999-12-31T23:59');
  });
  
  let tasks = [];
  let tasksLoaded = false;
  let hasTasksCache = false;
  let editingTaskId = null;
  let editingTask = null;
  let selectedTaskPriority = 'medium';
  let selectedTaskColor = '';
  let currentFilter = 'all';
  let taskTickerHandle = null;
  let subjects = [];
  let currentSubject = 'all';
  let currentSmartView = null; // 'today', 'week', 'overdue', 'nodate'
  let editingSubjectId = null;
  let selectedSubjectColor = '#667eea';
  let contextMenuTarget = null;
  let eventContextMenuTarget = null;
  let expandedSubjects = new Set(); // Track which subjects are expanded
  
  const PRIORITY_ORDER = { urgent: 0, high: 1, medium: 2, low: 3, none: 4 };
  const PRIORITY_LABELS = { urgent: 'Urgent', high: 'High', medium: 'Medium', low: 'Low', none: '' };
  const RECURRENCE_LABELS = { daily: '◊ô◊ï◊û◊ô', weekly: '◊©◊ë◊ï◊¢◊ô', monthly: '◊ó◊ï◊ì◊©◊ô' };
  
  function getDefaultSubjectId() {
    if (currentSmartView) return '';
    if (currentSubject && currentSubject !== 'all') return currentSubject;
    return '';
  }
  
  function syncQuickAddSubject() {
    if (!newTaskSubject) return;
    const defaultSubject = getDefaultSubjectId();
    if (defaultSubject) {
      newTaskSubject.value = defaultSubject;
    } else if (!newTaskSubject.value) {
      newTaskSubject.value = '';
    }
    updateQuickAddSubjectColorOption();
  }

  function getSubjectColorById(subjectId) {
    if (!subjectId) return '';
    return subjects.find(s => s.id === subjectId)?.color || '';
  }

  function updateQuickAddSubjectColorOption() {
    if (!newTaskSubject || !quickTaskColorPicker) return;
    const subjectColor = getSubjectColorById(newTaskSubject.value);
    updateSubjectColorOption(quickTaskColorPicker, subjectColor);
    if (!subjectColor && selectedTaskColor === 'subject') {
      selectedTaskColor = '';
      setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
    }
  }

  function setTaskColorSelection(picker, color) {
    if (!picker) return;
    const target = color || '';
    picker.querySelectorAll('.task-color-option').forEach(opt => {
      const optColor = opt.dataset.color || '';
      opt.classList.toggle('selected', optColor === target);
    });
  }

  function getTaskColorFromPicker(picker) {
    if (!picker) return '';
    const selected = picker.querySelector('.task-color-option.selected');
    return selected ? (selected.dataset.color || '') : '';
  }

  function bindTaskColorPicker(picker, onChange) {
    if (!picker) return;
    picker.addEventListener('click', (e) => {
      const option = e.target.closest('.task-color-option');
      if (!option) return;
      if (option.classList.contains('disabled')) return;
      const color = option.dataset.color || '';
      setTaskColorSelection(picker, color);
      if (typeof onChange === 'function') onChange(color);
    });
  }
  
  function updateSubjectColorOption(picker, subjectColor) {
    if (!picker) return;
    const option = picker.querySelector('.task-color-option.subject');
    if (!option) return;
    if (subjectColor) {
      option.style.background = subjectColor;
      option.classList.remove('disabled');
      option.title = 'Use subject color';
    } else {
      option.style.background = '';
      option.classList.add('disabled');
      option.title = 'Select a subject to use its color';
    }
  }
  
  function resolveTaskColor(task, subjectColor) {
    if (!task?.color) return '';
    if (task.color === 'subject') return subjectColor || '';
    return task.color;
  }
  
  function hasManualOrder(taskList = tasks) {
    return taskList.every(t => Number.isFinite(t.order));
  }
  
  function getNextTaskOrder(isCompleted = false) {
    const list = tasks.filter(t => !!t.completed === !!isCompleted);
    const maxOrder = list.reduce((max, t) => Number.isFinite(t.order) ? Math.max(max, t.order) : max, -1);
    return maxOrder + 1;
  }
  
  function normalizeRecurrence(value) {
    return value && value !== 'none' ? value : 'none';
  }
  
  function getNextRecurrenceDate(baseIso, recurrence) {
    const type = normalizeRecurrence(recurrence);
    if (type === 'none') return null;
    const now = new Date();
    let base = baseIso ? new Date(baseIso) : new Date();
    if (Number.isNaN(base.getTime())) return null;
    if (base < now) base = now;
    const next = new Date(base);
    if (type === 'daily') next.setDate(next.getDate() + 1);
    if (type === 'weekly') next.setDate(next.getDate() + 7);
    if (type === 'monthly') next.setMonth(next.getMonth() + 1);
    return next;
  }
  
  function buildTaskClone(task, overrides = {}) {
    const { id, ...clean } = task;
    const orderValue = hasManualOrder() ? getNextTaskOrder(false) : null;
    const clone = {
      ...clean,
      completed: false,
      createdAt: new Date().toISOString(),
      ...(Number.isFinite(orderValue) ? { order: orderValue } : {})
    };
    return { ...clone, ...overrides };
  }
  
  function pushTaskClone(task, overrides = {}) {
    if (!task) return;
    const newTaskRef = push(tasksRef);
    set(newTaskRef, buildTaskClone(task, overrides));
  }
  
  function maybeCreateRecurringTask(task) {
    const recurrence = normalizeRecurrence(task?.recurrence);
    if (recurrence === 'none') return;
    const nextDate = getNextRecurrenceDate(task?.dueDate, recurrence);
    if (!nextDate) return;
    pushTaskClone(task, { dueDate: nextDate.toISOString(), completed: false });
  }

  // ============ POMODORO MODULE (self-contained) ============
  const Pomodoro = (() => {
    const refs = {
      card: document.getElementById('pomodoroCard'),
      taskSelect: document.getElementById('pomodoroTaskSelect'),
      presets: Array.from(document.querySelectorAll('.pomodoro-preset')),
      focusInput: document.getElementById('pomodoroFocus'),
      breakInput: document.getElementById('pomodoroBreak'),
      longInput: document.getElementById('pomodoroLong'),
      longEveryInput: document.getElementById('pomodoroLongEvery'),
      autoContinue: document.getElementById('pomodoroAutoContinue'),
      soundSelect: document.getElementById('pomodoroSound'),
      previewBtn: document.getElementById('pomodoroPreviewSound'),
      display: document.getElementById('pomodoroDisplay'),
      mode: document.getElementById('pomodoroMode'),
      next: document.getElementById('pomodoroNext'),
      progress: document.getElementById('pomodoroRing'),
      startBtn: document.getElementById('pomodoroStart'),
      skipBtn: document.getElementById('pomodoroSkip'),
      resetBtn: document.getElementById('pomodoroReset'),
      sessionCount: document.getElementById('pomodoroSessionCount'),
      focusMinutes: document.getElementById('pomodoroFocusMinutes'),
      streak: document.getElementById('pomodoroStreak'),
      dayProgress: document.getElementById('pomodoroDayProgress'),
      dayLabel: document.getElementById('pomodoroDayLabel'),
      // Mini player refs
      mini: document.getElementById('pomodoroMini'),
      miniTime: document.getElementById('pomodoroMiniTime'),
      miniMode: document.getElementById('pomodoroMiniMode'),
      miniToggle: document.getElementById('pomodoroMiniToggle'),
      miniClose: document.getElementById('pomodoroMiniClose')
    };

    const KEYS = {
      STATS: 'pomodoro-stats-v1',
      PRESET: 'pomodoro-preset-v1',
      CUSTOM: 'pomodoro-custom-v1',
      SETTINGS: 'pomodoro-settings-v1'
    };

    const presets = {
      classic: { focus: 25, shortBreak: 5, longBreak: 15, longEvery: 4, label: '25/5 ◊ß◊ú◊ê◊°◊ô' },
      flow: { focus: 50, shortBreak: 10, longBreak: 20, longEvery: 3, label: '50/10 Flow' },
      ultradian: { focus: 90, shortBreak: 20, longBreak: 25, longEvery: 1, label: '90/20 Ultradian' },
      perfect: { focus: 52, shortBreak: 17, longBreak: 20, longEvery: 3, label: '52/17' }
    };

    const clampNum = (val, min, max, fallback) => {
      const n = Number(val);
      if (Number.isFinite(n)) return Math.min(max, Math.max(min, n));
      return fallback;
    };

    const getTodayKey = () => new Date().toISOString().slice(0, 10);
    const daysBetween = (a, b) => Math.round((new Date(b) - new Date(a)) / 86400000);

    const loadCustom = () => {
      try {
        const raw = localStorage.getItem(KEYS.CUSTOM);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return null;
        return {
          focus: clampNum(parsed.focus, 5, 240, 25),
          shortBreak: clampNum(parsed.shortBreak, 3, 60, 5),
          longBreak: clampNum(parsed.longBreak, 5, 90, 15),
          longEvery: clampNum(parsed.longEvery, 1, 8, 4)
        };
      } catch (e) { return null; }
    };

    const saveCustom = (config) => {
      try { localStorage.setItem(KEYS.CUSTOM, JSON.stringify(config)); } catch (e) {}
    };

    const loadStats = () => {
      const today = getTodayKey();
      try {
        const raw = localStorage.getItem(KEYS.STATS);
        if (!raw) return { date: today, sessions: 0, focusMinutes: 0, streak: 0, lastActiveDate: null };
        const parsed = JSON.parse(raw);
        if (!parsed) return { date: today, sessions: 0, focusMinutes: 0, streak: 0, lastActiveDate: null };
        if (parsed.date !== today) {
          const carry = parsed.focusMinutes > 0 && daysBetween(parsed.date, today) === 1;
          const streak = carry ? (parsed.streak || 0) + 1 : (parsed.focusMinutes > 0 ? 1 : 0);
          return { date: today, sessions: 0, focusMinutes: 0, streak, lastActiveDate: parsed.lastActiveDate };
        }
        return parsed;
      } catch (e) {
        return { date: today, sessions: 0, focusMinutes: 0, streak: 0, lastActiveDate: null };
      }
    };

    const loadSettings = () => {
      try {
        const raw = localStorage.getItem(KEYS.SETTINGS);
        if (!raw) return { autoContinue: false, sound: 'chime' };
        const parsed = JSON.parse(raw);
        return { autoContinue: !!parsed.autoContinue, sound: parsed.sound || 'chime' };
      } catch (e) {
        return { autoContinue: false, sound: 'chime' };
      }
    };

    const saveSettings = () => {
      try { localStorage.setItem(KEYS.SETTINGS, JSON.stringify(settings)); } catch (e) {}
    };
    const saveStats = () => {
      try { localStorage.setItem(KEYS.STATS, JSON.stringify(stats)); } catch (e) {}
    };

    let config = loadCustom() || { ...presets.classic };
    let state = {
      mode: 'focus',
      remainingMs: (config.focus || 25) * 60000,
      running: false,
      cycle: 0,
      preset: localStorage.getItem(KEYS.PRESET) || 'classic',
      timerId: null
    };
    let stats = loadStats();
    let settings = loadSettings();
    let tasksCache = [];

    const getDuration = (mode) => {
      if (mode === 'focus') return config.focus;
      if (mode === 'long') return config.longBreak;
      return config.shortBreak;
    };

    const formatTime = (ms) => {
      const total = Math.max(0, Math.round(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    };

    const updatePresetButtons = () => {
      refs.presets.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.preset === state.preset);
      });
    };

    const renderStats = () => {
      if (!refs.sessionCount || !refs.focusMinutes || !refs.streak) return;
      refs.sessionCount.textContent = stats.sessions;
      refs.focusMinutes.textContent = stats.focusMinutes;
      refs.streak.textContent = stats.streak;
      const goal = 8;
      if (refs.dayProgress) {
        const pct = Math.min(100, Math.round((stats.sessions / goal) * 100));
        refs.dayProgress.style.width = pct + '%';
      }
      if (refs.dayLabel) {
        refs.dayLabel.textContent = `${Math.min(stats.sessions, goal)}/${goal} ◊û◊ó◊ñ◊ï◊®◊ô ◊û◊ô◊ß◊ï◊ì ◊ú◊î◊ô◊ï◊ù`;
      }
    };

    const render = () => {
      if (!refs.display) return;
      refs.display.textContent = formatTime(state.remainingMs);
      const modeLabel = state.mode === 'focus' ? '◊û◊¶◊ë ◊û◊ô◊ß◊ï◊ì' : (state.mode === 'long' ? '◊î◊§◊°◊ß◊î ◊ê◊®◊ï◊õ◊î' : '◊î◊§◊°◊ß◊î ◊ß◊¶◊®◊î');
      refs.mode.textContent = modeLabel;
      refs.next.textContent = `◊î◊ë◊ê: ${getNextLabel()}`;
      const totalMs = getDuration(state.mode) * 60000;
      const pct = Math.max(0, Math.min(100, 100 - (state.remainingMs / totalMs) * 100));
      if (refs.progress) refs.progress.style.setProperty('--progress', pct + '%');
      if (refs.startBtn) refs.startBtn.textContent = state.running ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
      // Update mini player
      if (refs.miniTime) refs.miniTime.textContent = formatTime(state.remainingMs);
      if (refs.miniMode) refs.miniMode.textContent = state.mode === 'focus' ? '◊û◊ô◊ß◊ï◊ì' : (state.mode === 'long' ? '◊î◊§◊°◊ß◊î ◊ê◊®◊ï◊õ◊î' : '◊î◊§◊°◊ß◊î');
    };

    const setMode = (mode) => {
      state.mode = mode;
      state.remainingMs = getDuration(mode) * 60000;
      render();
    };

    const getNextLabel = () => {
      if (state.mode === 'focus') {
        const nextIsLong = ((state.cycle + 1) % config.longEvery === 0);
        return nextIsLong ? '◊î◊§◊°◊ß◊î ◊ê◊®◊ï◊õ◊î' : '◊î◊§◊°◊ß◊î ◊ß◊¶◊®◊î';
      }
      return '◊û◊ô◊ß◊ï◊ì';
    };

    const clearTimer = () => {
      if (state.timerId) {
        clearInterval(state.timerId);
        state.timerId = null;
      }
    };

    const tick = () => {
      state.remainingMs -= 1000;
      if (state.remainingMs <= 0) advance(true);
      render();
    };

    const start = () => {
      if (state.running) return;
      state.running = true;
      clearTimer();
      state.timerId = setInterval(tick, 1000);
      render();
    };

    const pause = () => {
      state.running = false;
      clearTimer();
      render();
    };

    const reset = () => {
      state.running = false;
      clearTimer();
      state.mode = 'focus';
      state.remainingMs = config.focus * 60000;
      state.cycle = 0;
      render();
    };

    const recordFocus = () => {
      const today = getTodayKey();
      if (stats.date !== today) {
        const carry = stats.focusMinutes > 0 && daysBetween(stats.date, today) === 1;
        stats.streak = carry ? stats.streak + 1 : (stats.focusMinutes > 0 ? 1 : stats.streak || 0);
        stats.date = today;
        stats.sessions = 0;
        stats.focusMinutes = 0;
      }
      stats.sessions += 1;
      stats.focusMinutes += config.focus;
      stats.lastActiveDate = today;
      saveStats();
      renderStats();
    };

    // Enhanced sound patterns with distinct tones
    const tonePatterns = {
      // Gentle ascending chime - pleasant completion sound
      chime: [
        { f: 523, d: 0.15, type: 'sine', vol: 0.12 },
        { f: 659, d: 0.15, type: 'sine', vol: 0.14 },
        { f: 784, d: 0.25, type: 'sine', vol: 0.16 }
      ],
      // Soft meditation bowl - calming
      soft: [
        { f: 396, d: 0.4, type: 'sine', vol: 0.1 },
        { f: 528, d: 0.5, type: 'sine', vol: 0.08 }
      ],
      // Classic bell - clear and bright
      bell: [
        { f: 1047, d: 0.08, type: 'sine', vol: 0.18 },
        { f: 1319, d: 0.12, type: 'sine', vol: 0.14 },
        { f: 1568, d: 0.3, type: 'triangle', vol: 0.1 }
      ],
      // Digital beep - modern alert
      digital: [
        { f: 880, d: 0.1, type: 'square', vol: 0.06 },
        { f: 0, d: 0.05, type: 'sine', vol: 0 },
        { f: 880, d: 0.1, type: 'square', vol: 0.06 },
        { f: 0, d: 0.05, type: 'sine', vol: 0 },
        { f: 1175, d: 0.2, type: 'square', vol: 0.08 }
      ],
      // Crystal glass - high clarity
      glass: [
        { f: 2093, d: 0.15, type: 'sine', vol: 0.08 },
        { f: 2637, d: 0.2, type: 'sine', vol: 0.06 },
        { f: 3136, d: 0.35, type: 'sine', vol: 0.04 }
      ],
      // Success fanfare - celebratory
      success: [
        { f: 523, d: 0.12, type: 'triangle', vol: 0.12 },
        { f: 659, d: 0.12, type: 'triangle', vol: 0.14 },
        { f: 784, d: 0.12, type: 'triangle', vol: 0.16 },
        { f: 1047, d: 0.3, type: 'triangle', vol: 0.18 }
      ]
    };

    let audioCtx = null;
    const playTonePattern = (pattern) => {
      if (!pattern) return;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      let t = audioCtx.currentTime;
      pattern.forEach(step => {
        if (step.f === 0) { t += step.d; return; } // silence gap
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = step.type || 'sine';
        osc.frequency.value = step.f;
        const vol = step.vol || 0.15;
        gain.gain.setValueAtTime(0.001, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.015);
        gain.gain.exponentialRampToValueAtTime(0.001, t + step.d);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t);
        osc.stop(t + step.d + 0.02);
        t += step.d + 0.02;
      });
    };

    const alert = () => {
      const pattern = tonePatterns[settings.sound] || tonePatterns.chime;
      playTonePattern(pattern);
      if (navigator.vibrate) navigator.vibrate([40, 80]);
    };

    const advance = (countFocus = false) => {
      const wasRunning = state.running;
      clearTimer();
      state.running = false;
      if (state.mode === 'focus') {
        if (countFocus) recordFocus();
        state.cycle += 1;
        const useLong = config.longEvery > 0 && (state.cycle % config.longEvery === 0);
        setMode(useLong ? 'long' : 'short');
      } else {
        setMode('focus');
      }
      render();
      alert();
      if (settings.autoContinue || wasRunning) start();
    };

    const applyConfig = (cfg, presetKey) => {
      config = { ...cfg };
      state.preset = presetKey;
      refs.focusInput.value = config.focus;
      refs.breakInput.value = config.shortBreak;
      refs.longInput.value = config.longBreak;
      refs.longEveryInput.value = config.longEvery;
      state.mode = 'focus';
      state.remainingMs = config.focus * 60000;
      state.cycle = 0;
      updatePresetButtons();
      render();
    };

    const selectPreset = (key) => {
      const base = key === 'custom' ? (loadCustom() || config) : presets[key];
      if (!base) return;
      localStorage.setItem(KEYS.PRESET, key);
      if (key === 'custom') saveCustom(base);
      applyConfig(base, key);
    };

    const handleCustomChange = () => {
      const cfg = {
        focus: clampNum(refs.focusInput.value, 5, 240, config.focus),
        shortBreak: clampNum(refs.breakInput.value, 3, 60, config.shortBreak),
        longBreak: clampNum(refs.longInput.value, 5, 90, config.longBreak),
        longEvery: clampNum(refs.longEveryInput.value, 1, 8, config.longEvery)
      };
      saveCustom(cfg);
      selectPreset('custom');
    };

    const updateTaskOptions = () => {
      if (!refs.taskSelect) return;
      const prev = refs.taskSelect.value;
      refs.taskSelect.innerHTML = '<option value="">◊ë◊ó◊® ◊û◊©◊ô◊û◊î ◊ú◊î◊™◊û◊ß◊ì (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô)</option>';
      const active = (tasksCache || []).filter(t => !t.completed).slice(0, 50);
      active.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t.id;
        opt.textContent = t.title || '◊ú◊ú◊ê ◊©◊ù';
        refs.taskSelect.appendChild(opt);
      });
      if (prev && active.some(t => t.id === prev)) refs.taskSelect.value = prev;
    };

    const init = () => {
      if (!refs.card) return;
      const savedPreset = localStorage.getItem(KEYS.PRESET) || 'classic';
      const baseConfig = savedPreset === 'custom' ? (loadCustom() || presets.classic) : (presets[savedPreset] || presets.classic);
      applyConfig(baseConfig, savedPreset);
      renderStats();

      if (refs.autoContinue) {
        refs.autoContinue.checked = settings.autoContinue;
        refs.autoContinue.addEventListener('change', () => {
          settings.autoContinue = refs.autoContinue.checked;
          saveSettings();
        });
      }

      if (refs.soundSelect) {
        refs.soundSelect.value = settings.sound;
        refs.soundSelect.addEventListener('change', () => {
          settings.sound = refs.soundSelect.value;
          saveSettings();
        });
      }

      if (refs.previewBtn) {
        refs.previewBtn.addEventListener('click', () => {
          const key = (refs.soundSelect && refs.soundSelect.value) || settings.sound || 'chime';
          if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
          playTonePattern(tonePatterns[key] || tonePatterns.chime);
        });
      }

      refs.presets.forEach(btn => btn.addEventListener('click', () => selectPreset(btn.dataset.preset)));

      [refs.focusInput, refs.breakInput, refs.longInput, refs.longEveryInput].forEach(input => {
        if (!input) return;
        input.addEventListener('change', handleCustomChange);
        input.addEventListener('input', () => state.preset = 'custom');
      });

      if (refs.startBtn) refs.startBtn.onclick = () => { state.running ? pause() : start(); };
      if (refs.skipBtn) refs.skipBtn.onclick = () => advance(false);
      if (refs.resetBtn) refs.resetBtn.onclick = reset;

      // Mini player setup
      const MINI_KEY = 'pomodoro-mini-enabled';
      const miniEnabled = localStorage.getItem(MINI_KEY) === 'true';
      if (refs.miniToggle) {
        refs.miniToggle.checked = miniEnabled;
        if (refs.mini) refs.mini.classList.toggle('visible', miniEnabled);
      }
      if (refs.miniToggle) {
        refs.miniToggle.addEventListener('change', () => {
          const enabled = refs.miniToggle.checked;
          localStorage.setItem(MINI_KEY, enabled ? 'true' : 'false');
          if (refs.mini) refs.mini.classList.toggle('visible', enabled);
        });
      }
      if (refs.miniClose) {
        refs.miniClose.addEventListener('click', () => {
          if (refs.miniToggle) refs.miniToggle.checked = false;
          localStorage.setItem(MINI_KEY, 'false');
          if (refs.mini) refs.mini.classList.remove('visible');
        });
      }
      // Click on mini player opens Pomodoro overlay
      if (refs.mini) {
        refs.mini.addEventListener('click', (e) => {
          if (e.target === refs.miniClose) return;
          const overlay = document.getElementById('pomodoroOverlay');
          if (overlay) overlay.classList.add('open');
        });
      }

      updatePresetButtons();
      render();
      updateTaskOptions();
    };

    const updateTasks = (tasks = []) => {
      tasksCache = tasks;
      updateTaskOptions();
    };

    return { init, updateTasks };
  })();

  // Toggle overlays - menu buttons switch between views
  // Three main views: Countdown (app-layout), Tasks (taskManagerOverlay), Pomodoro (pomodoroOverlay)
  const toggleCountdown = document.getElementById('toggleCountdown');
  const appLayout = document.querySelector('.app-layout');
  // Ensure current view state and commonly used DOM refs exist before showView
  let currentView = 'countdown';
  const subjectsList = $("subjectsList");

  function updateHeaderButtons() {
    try {
      ['toggleCountdown','toggleTasks','togglePomodoro'].forEach(id => {
        const el = $(id);
        if (el) el.classList.remove('active');
      });
      if (currentView === 'countdown') {
        const el = $('toggleCountdown'); if (el) el.classList.add('active');
      } else if (currentView === 'tasks') {
        const el = $('toggleTasks'); if (el) el.classList.add('active');
      } else if (currentView === 'pomodoro') {
        const el = $('togglePomodoro'); if (el) el.classList.add('active');
      }
    } catch (e) {
      console.warn('updateHeaderButtons error', e);
    }
  }
  
  
  
  
  
  
  const showView = (view) => {
    // Hide all views
    appLayout.style.display = 'none';
    taskManagerOverlay.classList.remove('open');
    pomodoroOverlay.classList.remove('open');
    stopTaskTicker();
    
    // Show calendar button only for countdown view
    toggleSidebar.style.display = view === 'countdown' ? '' : 'none';
    
    // Show selected view
    if (view === 'countdown') {
      appLayout.style.display = '';
    } else if (view === 'tasks') {
      taskManagerOverlay.classList.add('open');
      renderSubjectsSidebar();
      renderTasks();
      startTaskTicker();
      if (typeof setupTaskCalendar === 'function') setupTaskCalendar();
      if (typeof renderTaskCalendar === 'function') renderTaskCalendar();
    } else if (view === 'pomodoro') {
      pomodoroOverlay.classList.add('open');
    }
    
    currentView = view;
    updateHeaderButtons();
  };
  
  toggleCountdown.onclick = () => showView('countdown');
  toggleTasks.onclick = () => showView('tasks');
  togglePomodoro.onclick = () => showView('pomodoro');

  // Close task manager button
  if (closeTaskManager) {
    closeTaskManager.onclick = () => {
      taskManagerOverlay.classList.remove('open');
      stopTaskTicker();
      showView('countdown');
    };
  }
  
  // Initialize header button states
  updateHeaderButtons();
  newTaskTitle.addEventListener('focus', () => {
    quickAddRow.style.display = 'flex';
    syncQuickAddSubject();
  });
  
  // Collapse quick add when clicking outside
  taskManagerOverlay.addEventListener('click', (e) => {
    if (!quickAddTask.contains(e.target) && !newTaskTitle.value.trim()) {
      quickAddRow.style.display = 'none';
    }
  });
  
  // Priority picker in quick add
  taskPriorityPicker.addEventListener('click', (e) => {
    const option = e.target.closest('.priority-option');
    if (!option) return;
    taskPriorityPicker.querySelectorAll('.priority-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedTaskPriority = option.dataset.priority;
  });

  bindTaskColorPicker(quickTaskColorPicker, (color) => {
    selectedTaskColor = color;
  });
  setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
  updateQuickAddSubjectColorOption();
  if (newTaskSubject) {
    newTaskSubject.addEventListener('change', () => {
      updateQuickAddSubjectColorOption();
    });
  }
  if (editTaskSubject) {
    editTaskSubject.addEventListener('change', () => {
      const subjectColor = getSubjectColorById(editTaskSubject.value);
      updateSubjectColorOption(taskColorPicker, subjectColor);
      if (!subjectColor && getTaskColorFromPicker(taskColorPicker) === 'subject') {
        setTaskColorSelection(taskColorPicker, '');
        if (editingTask) editingTask.color = '';
      }
    });
  }
  
  // ============ UNIFIED ADD TASK FUNCTION ============
  function addTask() {
    const title = newTaskTitle.value.trim();
    if (!title) return;
    
    const dueValue = newTaskDue.value;
    const dueDate = dueValue ? parseLocal(dueValue) : null;
    const recurrence = newTaskRecurrence ? newTaskRecurrence.value : 'none';
    
    const defaultSubjectId = getDefaultSubjectId();
    const selectedSubjectId = newTaskSubject ? (newTaskSubject.value || defaultSubjectId) : defaultSubjectId;
    const orderValue = hasManualOrder() ? getNextTaskOrder(false) : null;
    
    const taskData = {
      title,
      content: '',
      priority: selectedTaskPriority,
      dueDate: dueDate ? dueDate.toISOString() : null,
      subject: selectedSubjectId || '',
      checklist: [],
      completed: false,
      createdAt: new Date().toISOString(),
      ...(Number.isFinite(orderValue) ? { order: orderValue } : {}),
      ...(selectedTaskColor ? { color: selectedTaskColor } : {}),
      ...(recurrence && recurrence !== 'none' ? { recurrence } : {})
    };
    
    const newTaskRef = push(tasksRef);
    set(newTaskRef, taskData);
    
    // Reset form
    newTaskTitle.value = '';
    newTaskDue.value = '';
    if (newTaskRecurrence) newTaskRecurrence.value = 'none';
    if (newTaskSubject) newTaskSubject.value = '';
    if (quickAddRow) quickAddRow.style.display = 'none';
    selectedTaskPriority = 'medium';
    taskPriorityPicker.querySelectorAll('.priority-option').forEach(o => o.classList.remove('selected'));
    taskPriorityPicker.querySelector('[data-priority="medium"]').classList.add('selected');
    selectedTaskColor = '';
    setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
    syncQuickAddSubject();
    const taskSections = $("taskSections");
    if (taskSections) {
      taskSections.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }
  
  // Hook button to unified function
  addTaskBtn.onclick = addTask;
  
  // Filter pills
  document.querySelectorAll('.filter-pill').forEach(pill => {
    pill.addEventListener('click', () => {
      document.querySelectorAll('.filter-pill').forEach(p => p.classList.remove('active'));
      pill.classList.add('active');
      currentFilter = pill.dataset.filter;
      renderTasks();
    });
  });
  
  // Search
  taskSearch.addEventListener('input', () => {
    renderTasks();
  });

  const tasksEmptyDefaults = tasksEmpty ? {
    icon: tasksEmpty.querySelector('.tasks-empty-icon')?.textContent || 'üìù',
    title: tasksEmpty.querySelector('h3')?.textContent || '◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊¢◊ì◊ô◊ô◊ü',
    desc: tasksEmpty.querySelector('p')?.textContent || '◊î◊ï◊°◊£ ◊û◊©◊ô◊û◊î ◊®◊ê◊©◊ï◊†◊î ◊ú◊û◊¢◊ú◊î ◊õ◊ì◊ô ◊ú◊î◊™◊ó◊ô◊ú!'
  } : null;

  const setTasksEmptyMessage = (icon, title, desc) => {
    if (!tasksEmpty) return;
    const iconEl = tasksEmpty.querySelector('.tasks-empty-icon');
    const titleEl = tasksEmpty.querySelector('h3');
    const descEl = tasksEmpty.querySelector('p');
    if (iconEl) iconEl.textContent = icon;
    if (titleEl) titleEl.textContent = title;
    if (descEl) descEl.textContent = desc;
  };

  const showTasksLoading = () => {
    activeSection.style.display = 'none';
    completedSection.style.display = 'none';
    tasksEmpty.style.display = 'block';
    setTasksEmptyMessage('‚è≥', '◊ò◊ï◊¢◊ü ◊û◊©◊ô◊û◊ï◊™...', '◊û◊°◊†◊õ◊®◊ü ◊û◊©◊ô◊û◊ï◊™ ◊û◊î◊¢◊†◊ü');
  };

  const resetTasksEmptyMessage = () => {
    if (!tasksEmptyDefaults) return;
    setTasksEmptyMessage(tasksEmptyDefaults.icon, tasksEmptyDefaults.title, tasksEmptyDefaults.desc);
  };

  const cachedTasksKey = `${CACHE_KEYS.TASKS_PREFIX}${currentUser}`;
  const cachedTasks = readCache(cachedTasksKey);
  if (cachedTasks && cachedTasks.length) {
    tasks = cachedTasks;
    hasTasksCache = true;
    syncCacheUsed.tasks = true;
    updateSyncBadge();
    Pomodoro.updateTasks(tasks);
    if (taskManagerOverlay.classList.contains('open')) {
      renderTasks();
      renderSubjectsSidebar();
    }
  }

  // Listen to tasks from Firebase
  onValue(tasksRef, (snapshot) => {
    const data = snapshot.val();
    if (data) {
      tasks = Object.keys(data).map(key => ({ id: key, ...data[key] }));
    } else {
      tasks = [];
    }
    tasksLoaded = true;
    markSyncReady('tasks');
    writeCache(cachedTasksKey, tasks, 500);
    resetTasksEmptyMessage();
    Pomodoro.updateTasks(tasks);
    if (taskManagerOverlay.classList.contains('open')) {
      renderTasks();
    }
    // Update task calendar if visible
    const trSidebar = $("taskRightSidebar");
    if (trSidebar && !trSidebar.classList.contains('hidden')) {
      renderTaskCalendar();
    }
  }, (error) => {
    console.error('Tasks sync error:', error);
    tasksLoaded = true;
    markSyncReady('tasks');
    resetTasksEmptyMessage();
    updateSyncBadge();
  });
  
  function getFilteredTasks() {
    let filtered = [...tasks];
    
    // Apply search filter
    const searchTerm = taskSearch.value.trim().toLowerCase();
    if (searchTerm) {
      filtered = filtered.filter(t => 
        t.title.toLowerCase().includes(searchTerm) ||
        (t.content && t.content.toLowerCase().includes(searchTerm))
      );
    }
    
    // Apply status filter
    if (currentFilter === 'active') {
      filtered = filtered.filter(t => !t.completed);
    } else if (currentFilter === 'completed') {
      filtered = filtered.filter(t => t.completed);
    }
    
    // Apply date filter for calendar selection
    if (currentSmartView === 'date-filter' && window.taskFilterDate) {
      const dateStr = window.taskFilterDate.toDateString();
      filtered = filtered.filter(t => {
        if (!t.dueDate) return false;
        return new Date(t.dueDate).toDateString() === dateStr;
      });
    }
    
    return filtered;
  }
  
  function sortTasksDefault(taskList) {
    // Sort by: priority first (urgent first), then by due date (soonest first), then by created date (newest first)
    return taskList.sort((a, b) => {
      // Priority comparison
      const priorityA = PRIORITY_ORDER[a.priority || 'none'];
      const priorityB = PRIORITY_ORDER[b.priority || 'none'];
      if (priorityA !== priorityB) return priorityA - priorityB;
      
      // Due date comparison (tasks with due dates come first, soonest first)
      if (a.dueDate && !b.dueDate) return -1;
      if (!a.dueDate && b.dueDate) return 1;
      if (a.dueDate && b.dueDate) {
        const dueDiff = new Date(a.dueDate) - new Date(b.dueDate);
        if (dueDiff !== 0) return dueDiff;
      }
      
      // Created date (newest first)
      return new Date(b.createdAt) - new Date(a.createdAt);
    });
  }
  
  function sortTasks(taskList) {
    const hasManualOrder = taskList.length > 0 && taskList.every(t => Number.isFinite(t.order));
    if (hasManualOrder) {
      return taskList.sort((a, b) => {
        const aOrder = Number.isFinite(a.order) ? a.order : Number.MAX_SAFE_INTEGER;
        const bOrder = Number.isFinite(b.order) ? b.order : Number.MAX_SAFE_INTEGER;
        if (aOrder !== bOrder) return aOrder - bOrder;
        return new Date(b.createdAt) - new Date(a.createdAt);
      });
    }
    return sortTasksDefault(taskList);
  }
  
  function calcTaskCountdown(dueDate) {
    if (!dueDate) return null;
    const now = Date.now();
    const due = new Date(dueDate).getTime();
    const diff = due - now;
    
    if (diff <= 0) {
      return { overdue: true, text: 'Overdue', urgency: 'overdue' };
    }
    
    const days = Math.floor(diff / 86400000);
    const hours = Math.floor((diff % 86400000) / 3600000);
    const mins = Math.floor((diff % 3600000) / 60000);
    
    let text = '';
    let urgency = '';
    
    if (days > 0) {
      text = `${days}d ${hours}h`;
    } else if (hours > 0) {
      text = `${hours}h ${mins}m`;
    } else {
      text = `${mins}m`;
    }
    
    // Urgency levels for styling
    if (days === 0 && hours < 6) {
      urgency = 'soon';
    } else if (days === 0) {
      urgency = 'today';
    }
    
    return { overdue: false, text, urgency, days, hours, mins };
  }
  
  function renderTasks() {
    if (!tasksLoaded && !hasTasksCache) {
      showTasksLoading();
      return;
    }
    const filtered = getFilteredTasks();
    const active = filtered.filter(t => !t.completed);
    const completed = filtered.filter(t => t.completed);
    
    // Update sidebar counts
    updateSmartViewCounts();
    renderSubjectsSidebar();
    
    // Update title for date filter
    const viewNameDisplay = document.querySelector('.task-manager-title');
    if (currentSmartView === 'date-filter' && window.taskFilterDate && viewNameDisplay) {
      const options = { weekday: 'long', day: 'numeric', month: 'long' };
      viewNameDisplay.textContent = `üìÖ ${window.taskFilterDate.toLocaleDateString('he-IL', options)}`;
    } else if (viewNameDisplay && !currentSmartView) {
      // Reset to default title if not in a smart view
      const subjectName = currentSubject ? subjects.find(s => s.id === currentSubject)?.name : null;
      viewNameDisplay.textContent = subjectName || '◊õ◊ú ◊î◊û◊©◊ô◊û◊ï◊™';
    }
    
    // Sort tasks
    sortTasks(active);
    sortTasks(completed);
    
    // Check if showing suggested tasks for empty sub-subject
    const showingSuggested = window.showingSuggestedTasks;
    
    // Active tasks section
    if (active.length > 0 || currentFilter === 'all' || currentFilter === 'active') {
      activeSection.style.display = 'block';
      let suggestedBanner = '';
      if (showingSuggested && active.length > 0) {
        suggestedBanner = `
          <div class="suggested-tasks-banner">
            <span class="suggested-icon">üí°</span>
            <span>◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊ë◊™◊™-◊†◊ï◊©◊ê ◊ñ◊î. ◊û◊ï◊¶◊í◊ï◊™ ◊û◊©◊ô◊û◊ï◊™ ◊ì◊ó◊ï◊§◊ï◊™ ◊û◊õ◊ú ◊î◊†◊ï◊©◊ê◊ô◊ù:</span>
          </div>
        `;
      }
      activeTasks.innerHTML = suggestedBanner + active.map(t => renderTaskItem(t, showingSuggested)).join('');
    } else {
      activeSection.style.display = 'none';
    }
    
    // Completed tasks section
    if (completed.length > 0 && (currentFilter === 'all' || currentFilter === 'completed') && !showingSuggested) {
      completedSection.style.display = 'block';
      completedTasks.innerHTML = completed.map(t => renderTaskItem(t)).join('');
    } else {
      completedSection.style.display = 'none';
    }
    
    // Empty state
    if (filtered.length === 0 && !showingSuggested) {
      tasksEmpty.style.display = 'block';
      activeSection.style.display = 'none';
    } else {
      tasksEmpty.style.display = 'none';
    }

    Pomodoro.updateTasks(tasks);
    
    // Event delegation is set up once below, no need to call attachTaskEventHandlers
  }
  
  function renderTaskItem(task, showSubjectTag = false) {
    const priority = task.priority || 'none';
    const countdown = calcTaskCountdown(task.dueDate);
    
    let dueDateHtml = `<span class="task-due add" data-due-iso="">+ ◊™◊ê◊®◊ô◊ö</span>`;
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      const dateStr = dueDate.toLocaleDateString('he-IL', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const urgencyClass = countdown?.overdue ? 'overdue' : (countdown?.urgency === 'soon' ? 'soon' : '');
      dueDateHtml = `<span class="task-due ${urgencyClass}" data-due-iso="${task.dueDate}">üìÖ ${dateStr}</span>`;
    }
    
    let countdownHtml = '';
    if (countdown) {
      const countdownClass = countdown.overdue ? 'overdue' : (countdown.urgency === 'soon' ? 'soon' : '');
      countdownHtml = `<span class="task-countdown ${countdownClass}" data-due="${task.dueDate}">${countdown.text}</span>`;
    }
    
    let recurrenceHtml = '';
    const recurrence = normalizeRecurrence(task.recurrence);
    if (recurrence !== 'none') {
      const label = RECURRENCE_LABELS[recurrence] || recurrence;
      recurrenceHtml = `<span class="task-recurrence">üîÅ ${label}</span>`;
    }
    
    const subjectData = task.subject ? subjects.find(s => s.id === task.subject) : null;
    const subjectColor = subjectData ? subjectData.color : '';
    const resolvedTaskColor = resolveTaskColor(task, subjectColor);
    const styleParts = [];
    if (subjectColor) {
      styleParts.push(`--subject-color: ${subjectColor};`);
      styleParts.push(`--subject-tint: ${subjectColor}26;`);
    }
    if (resolvedTaskColor) {
      styleParts.push(`--task-color: ${resolvedTaskColor};`);
      styleParts.push(`--task-tint: ${resolvedTaskColor}22;`);
    }
    const taskStyle = styleParts.length ? ` style="${styleParts.join(' ')}"` : '';
    const taskColorDot = resolvedTaskColor ? `<span class="task-color-dot" style="background: ${resolvedTaskColor};"></span>` : '';

    // Subject badge - show when viewing "all" OR when explicitly requested (suggested tasks)
    let subjectHtml = '';
    if (subjectData) {
      const shouldShow = (currentSubject === 'all') || showSubjectTag;
      if (shouldShow) {
        // If it's a sub-subject and showing tag, show parent > child
        let displayName = subjectData.name;
        if (showSubjectTag && subjectData.parentId) {
          const parent = subjects.find(s => s.id === subjectData.parentId);
          if (parent) {
            displayName = `${parent.name} ‚Ä∫ ${subjectData.name}`;
          }
        }
        subjectHtml = `<span class="task-subject-badge" style="--subject-color: ${subjectData.color};">${escapeHtml(displayName)}</span>`;
      }
    }
    
    let subtasksHtml = '';
    if (task.checklist && task.checklist.length > 0) {
      const checked = task.checklist.filter(c => c.checked).length;
      const total = task.checklist.length;
      const maxShow = 3;
      const items = task.checklist.slice(0, maxShow);
      
      subtasksHtml = `
        <div class="task-subtasks">
          <div class="task-subtask-progress">${checked}/${total} completed</div>
          ${items.map((item, i) => `
            <div class="task-subtask ${item.checked ? 'checked' : ''}">
              <input type="checkbox" ${item.checked ? 'checked' : ''} data-index="${i}" />
              <span>${escapeHtml(item.text)}</span>
            </div>
          `).join('')}
          ${task.checklist.length > maxShow ? `<div style="font-size: 12px; color: var(--muted);">+${task.checklist.length - maxShow} more</div>` : ''}
        </div>
      `;
    }
    
    const priorityBadge = `<span class="task-priority-badge ${priority === 'none' ? 'muted' : ''}" data-priority="${priority}">${priority === 'none' ? '◊ß◊ë◊¢ ◊¢◊ì◊ô◊§◊ï◊™' : PRIORITY_LABELS[priority]}</span>`;
    
    return `
      <div class="task-item priority-${priority} ${task.completed ? 'completed' : ''}" data-id="${task.id}" draggable="true"${taskStyle}>
        <div class="task-checkbox" data-action="toggle">${task.completed ? '‚úì' : ''}</div>
        <div class="task-main">
          <div class="task-title-row">
            <span class="task-title">${escapeHtml(task.title)}</span>
            ${taskColorDot}
            ${subjectHtml}
            ${priorityBadge}
          </div>
          <div class="task-meta">
            ${dueDateHtml}
            ${countdownHtml}
            ${recurrenceHtml}
          </div>
          ${subtasksHtml}
        </div>
        <div class="task-actions">
          <button class="task-action-btn" data-action="edit" title="Edit" aria-label="◊¢◊®◊ô◊õ◊î">‚úèÔ∏è</button>
          <button class="task-action-btn" data-action="duplicate" title="Duplicate" aria-label="◊©◊õ◊§◊ú">‚ßâ</button>
          <button class="task-action-btn delete" data-action="delete" title="Delete" aria-label="◊û◊ó◊ß">üóëÔ∏è</button>
        </div>
      </div>
    `;
  }

  function formatTaskDueDisplay(dueIso) {
    if (!dueIso) return '+ ◊™◊ê◊®◊ô◊ö';
    const dueDate = new Date(dueIso);
    return dueDate.toLocaleDateString('he-IL', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
  }

  function startInlineTaskTitleEdit(titleEl, task) {
    if (titleEl.dataset.editing === '1') return;
    titleEl.dataset.editing = '1';

    const input = document.createElement('input');
    input.type = 'text';
    input.value = task.title || '';
    input.className = 'inline-edit-input';
    titleEl.replaceWith(input);
    input.focus();
    input.select();

    const finish = (commit) => {
      input.replaceWith(titleEl);
      delete titleEl.dataset.editing;
      if (commit) {
        const newTitle = input.value.trim() || task.title;
        titleEl.textContent = newTitle;
        const { id, ...clean } = task;
        set(ref(db, `users/${currentUser}/tasks/${task.id}`), { ...clean, title: newTitle });
      }
    };

    input.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') finish(true);
      else if (ev.key === 'Escape') finish(false);
    });
    input.addEventListener('blur', () => finish(true));
  }

  function startInlineTaskDueEdit(dueEl, task) {
    if (dueEl.dataset.editing === '1') return;
    dueEl.dataset.editing = '1';

    const input = document.createElement('input');
    input.type = 'datetime-local';
    input.value = task.dueDate ? toLocalDatetime(task.dueDate) : '';
    input.className = 'inline-edit-input small';
    dueEl.replaceWith(input);
    input.focus();

    const finish = (commit) => {
      input.replaceWith(dueEl);
      delete dueEl.dataset.editing;
      if (commit) {
        let newDue = null;
        if (input.value) {
          const parsed = parseLocal(input.value);
          if (parsed && !isNaN(parsed.getTime())) {
            newDue = parsed.toISOString();
          } else {
            // invalid -> keep original display
            dueEl.textContent = dueEl.textContent || '+ ◊™◊ê◊®◊ô◊ö';
            return;
          }
        }
        const { id, ...clean } = task;
        set(ref(db, `users/${currentUser}/tasks/${task.id}`), { ...clean, dueDate: newDue });
        dueEl.dataset.dueIso = newDue || '';
        dueEl.textContent = newDue ? `üìÖ ${formatTaskDueDisplay(newDue)}` : '+ ◊™◊ê◊®◊ô◊ö';
        dueEl.classList.toggle('add', !newDue);
      }
    };

    input.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') finish(true);
      else if (ev.key === 'Escape') finish(false);
    });
    input.addEventListener('blur', () => finish(true));
  }

  let activePriorityPopover = null;

  function closePriorityPopover() {
    if (activePriorityPopover) {
      activePriorityPopover.remove();
      activePriorityPopover = null;
    }
  }

  function startInlineTaskPriorityEdit(badgeEl, task) {
    closePriorityPopover();

    const pop = document.createElement('div');
    pop.className = 'priority-popover';

    ['urgent', 'high', 'medium', 'low', 'none'].forEach(key => {
      const btn = document.createElement('button');
      btn.textContent = key === 'none' ? '◊ú◊ú◊ê ◊¢◊ì◊ô◊§◊ï◊™' : (PRIORITY_LABELS[key] || key);
      btn.dataset.priority = key;
      btn.onclick = (ev) => {
        ev.stopPropagation();
        const { id, ...clean } = task;
        set(ref(db, `users/${currentUser}/tasks/${task.id}`), { ...clean, priority: key });
        badgeEl.textContent = key === 'none' ? '◊ß◊ë◊¢ ◊¢◊ì◊ô◊§◊ï◊™' : (PRIORITY_LABELS[key] || key);
        badgeEl.dataset.priority = key;
        badgeEl.classList.toggle('muted', key === 'none');
        closePriorityPopover();
      };
      pop.appendChild(btn);
    });

    const rect = badgeEl.getBoundingClientRect();
    pop.style.top = `${rect.bottom + 8}px`;
    pop.style.left = `${Math.max(8, rect.left - 60)}px`;

    document.body.appendChild(pop);
    activePriorityPopover = pop;

    setTimeout(() => {
      const outsideHandler = (ev) => {
        if (!pop.contains(ev.target)) {
          closePriorityPopover();
          document.removeEventListener('click', outsideHandler);
        }
      };
      document.addEventListener('click', outsideHandler);
    }, 0);
  }
  
  // ============ EVENT DELEGATION FOR TASK LIST ============
  // Single click handler for all task interactions - much more efficient than per-item listeners
  function setupTaskEventDelegation() {
    const containers = [activeTasks, completedTasks];
    
    containers.forEach(container => {
      if (!container) return;
      
      container.addEventListener('click', (e) => {
        const taskItem = e.target.closest('.task-item');
        if (!taskItem) return;
        
        const taskId = taskItem.dataset.id;
        const task = tasks.find(t => t.id === taskId);
        if (!task) return;

        const titleEl = e.target.closest('.task-title');
        if (titleEl) {
          e.stopPropagation();
          startInlineTaskTitleEdit(titleEl, task);
          return;
        }

        const dueEl = e.target.closest('.task-due');
        if (dueEl) {
          e.stopPropagation();
          startInlineTaskDueEdit(dueEl, task);
          return;
        }

        const priorityEl = e.target.closest('.task-priority-badge');
        if (priorityEl) {
          e.stopPropagation();
          startInlineTaskPriorityEdit(priorityEl, task);
          return;
        }
        
        // Check what was clicked
        const action = e.target.closest('[data-action]')?.dataset.action;
        const isSubtaskCheckbox = e.target.closest('.task-subtask input[type="checkbox"]');
        const isMainArea = e.target.closest('.task-main') && !isSubtaskCheckbox;
        
        if (action === 'toggle' || e.target.closest('.task-checkbox')) {
          // Toggle complete
          e.stopPropagation();
          const nextCompleted = !task.completed;
          if (nextCompleted) {
            maybeCreateRecurringTask(task);
          }
          const { id, ...cleanTask } = task;
          set(ref(db, `users/${currentUser}/tasks/${taskId}`), { ...cleanTask, completed: nextCompleted });
        } else if (action === 'edit') {
          // Edit button
          e.stopPropagation();
          openTaskEditModal(taskId);
        } else if (action === 'duplicate') {
          // Duplicate button
          e.stopPropagation();
          pushTaskClone(task);
        } else if (action === 'delete') {
          // Delete button
          e.stopPropagation();
          remove(ref(db, `users/${currentUser}/tasks/${taskId}`));
        } else if (isSubtaskCheckbox) {
          // Subtask checkbox
          e.stopPropagation();
          const idx = parseInt(isSubtaskCheckbox.dataset.index);
          if (task.checklist && task.checklist[idx] !== undefined) {
            task.checklist[idx].checked = isSubtaskCheckbox.checked;
            const { id, ...cleanTask } = task;
            set(ref(db, `users/${currentUser}/tasks/${taskId}`), cleanTask);
          }
        } else if (isMainArea) {
          // Click on main area to edit
          openTaskEditModal(taskId);
        }
      });
    });
  }
  
  // Initialize event delegation once
  setupTaskEventDelegation();
  
  let draggingTaskId = null;
  let dragSourceContainer = null;
  
  function ensureTaskOrderInitialized() {
    if (hasManualOrder()) return;
    const activeList = tasks.filter(t => !t.completed);
    const completedList = tasks.filter(t => t.completed);
    sortTasksDefault(activeList);
    sortTasksDefault(completedList);
    
    const updates = [];
    activeList.forEach((task, index) => {
      if (task.order !== index) updates.push({ task, order: index });
    });
    completedList.forEach((task, index) => {
      if (task.order !== index) updates.push({ task, order: index });
    });
    
    updates.forEach(({ task, order }) => {
      task.order = order;
      const { id, ...cleanTask } = task;
      set(ref(db, `users/${currentUser}/tasks/${task.id}`), cleanTask);
    });
  }
  
  function updateTaskOrderFromContainer(container) {
    const items = Array.from(container.querySelectorAll('.task-item'));
    const updates = [];
    
    items.forEach((item, index) => {
      const taskId = item.dataset.id;
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      if (task.order !== index) {
        task.order = index;
        updates.push(task);
      }
    });
    
    updates.forEach((task) => {
      const { id, ...cleanTask } = task;
      set(ref(db, `users/${currentUser}/tasks/${task.id}`), cleanTask);
    });
  }
  
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];
    let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
    
    draggableElements.forEach(child => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        closest = { offset, element: child };
      }
    });
    
    return closest.element;
  }

  function clearTaskDragState() {
    document.querySelectorAll('.task-item.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('.subject-list-header.drag-over, .subject-child-item.drag-over').forEach(el => {
      el.classList.remove('drag-over');
    });
    draggingTaskId = null;
    dragSourceContainer = null;
  }

  function assignTaskToSubject(taskId, subjectId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.subject === subjectId) {
      clearTaskDragState();
      return;
    }
    const { id, ...cleanTask } = task;
    set(ref(db, `users/${currentUser}/tasks/${taskId}`), { ...cleanTask, subject: subjectId || '' });
    clearTaskDragState();
  }
  
  function setupTaskDragAndDrop() {
    const containers = [activeTasks, completedTasks];
    
    containers.forEach(container => {
      if (!container) return;
      
      container.addEventListener('dragstart', (e) => {
        const item = e.target.closest('.task-item');
        if (!item) return;
        if (e.target.closest('input, textarea, select, button, a')) {
          e.preventDefault();
          return;
        }
        draggingTaskId = item.dataset.id;
        dragSourceContainer = container;
        item.classList.add('dragging');
        ensureTaskOrderInitialized();
        if (e.dataTransfer) {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', draggingTaskId);
        }
      });
      
      container.addEventListener('dragover', (e) => {
        if (!draggingTaskId || dragSourceContainer !== container) return;
        e.preventDefault();
        const draggingEl = container.querySelector('.task-item.dragging');
        if (!draggingEl) return;
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
          container.appendChild(draggingEl);
        } else if (afterElement !== draggingEl) {
          container.insertBefore(draggingEl, afterElement);
        }
      });
      
      container.addEventListener('drop', (e) => {
        if (!draggingTaskId || dragSourceContainer !== container) return;
        e.preventDefault();
        updateTaskOrderFromContainer(container);
        clearTaskDragState();
      });
      
      container.addEventListener('dragend', () => {
        clearTaskDragState();
      });
    });
  }
  
  setupTaskDragAndDrop();
  
  // Task countdown ticker
  function startTaskTicker() {
    if (taskTickerHandle) return;
    const tick = () => {
      document.querySelectorAll('.task-countdown[data-due]').forEach(el => {
        const dueDate = el.dataset.due;
        const countdown = calcTaskCountdown(dueDate);
        if (countdown) {
          el.textContent = countdown.text;
          el.className = 'task-countdown ' + (countdown.overdue ? 'overdue' : (countdown.urgency === 'soon' ? 'soon' : ''));
        }
      });
    };
    tick();
    taskTickerHandle = setInterval(tick, 60000); // Update every minute
  }
  
  function stopTaskTicker() {
    if (taskTickerHandle) {
      clearInterval(taskTickerHandle);
      taskTickerHandle = null;
    }
  }
  
  // Task Edit Modal
  function openTaskEditModal(taskId) {
    editingTaskId = taskId;
    editingTask = JSON.parse(JSON.stringify(tasks.find(t => t.id === taskId)));
    if (!editingTask) return;
    
    editTaskTitle.value = editingTask.title || '';
    editTaskContent.value = editingTask.content || '';
    
    // Set priority
    editTaskPriority.querySelectorAll('.priority-option').forEach(o => {
      o.classList.toggle('selected', o.dataset.priority === (editingTask.priority || 'none'));
    });

    setTaskColorSelection(taskColorPicker, editingTask.color || '');
    updateSubjectColorOption(taskColorPicker, getSubjectColorById(editingTask.subject || ''));
    
    // Set due date
    if (editingTask.dueDate) {
      editTaskDue.value = toLocalDatetime(editingTask.dueDate);
    } else {
      editTaskDue.value = '';
    }
    
    if (editTaskRecurrence) {
      editTaskRecurrence.value = normalizeRecurrence(editingTask.recurrence);
    }
    
    // Render checklist
    renderEditChecklist();
    
    taskEditModal.classList.add('open');
  }
  
  function closeTaskEditModal() {
    taskEditModal.classList.remove('open');
    editingTaskId = null;
    editingTask = null;
  }
  
  taskEditModal.addEventListener('click', (e) => {
    if (e.target === taskEditModal) closeTaskEditModal();
  });
  
  // Edit modal priority picker
  editTaskPriority.addEventListener('click', (e) => {
    const option = e.target.closest('.priority-option');
    if (!option || !editingTask) return;
    editTaskPriority.querySelectorAll('.priority-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    editingTask.priority = option.dataset.priority;
  });

  bindTaskColorPicker(taskColorPicker, (color) => {
    if (editingTask) {
      editingTask.color = color || '';
    }
  });
  
  // Clear due date
  clearDueBtn.onclick = () => {
    editTaskDue.value = '';
    if (editingTask) editingTask.dueDate = null;
  };
  
  function renderEditChecklist() {
    if (!editingTask.checklist) editingTask.checklist = [];
    editTaskChecklist.innerHTML = editingTask.checklist.map((item, i) => `
      <div class="task-checklist-item ${item.checked ? 'checked' : ''}">
        <input type="checkbox" ${item.checked ? 'checked' : ''} data-index="${i}" />
        <span>${escapeHtml(item.text)}</span>
        <button class="task-action-btn delete" data-index="${i}" style="margin-left: auto;">√ó</button>
      </div>
    `).join('');
    
    // Add handlers
    editTaskChecklist.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.addEventListener('change', () => {
        const idx = parseInt(cb.dataset.index);
        editingTask.checklist[idx].checked = cb.checked;
        renderEditChecklist();
      });
    });
    
    editTaskChecklist.querySelectorAll('.task-action-btn.delete').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.dataset.index);
        editingTask.checklist.splice(idx, 1);
        renderEditChecklist();
      });
    });
  }
  
  addChecklistItem.onclick = () => {
    const text = newChecklistItem.value.trim();
    if (!text || !editingTask) return;
    editingTask.checklist.push({ text, checked: false });
    newChecklistItem.value = '';
    renderEditChecklist();
  };
  
  newChecklistItem.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') addChecklistItem.click();
  });
  
  // Delete task
  deleteTaskBtn.onclick = () => {
    if (!editingTaskId) return;
    remove(ref(db, `users/${currentUser}/tasks/${editingTaskId}`));
    closeTaskEditModal();
  };
  
  if (duplicateTaskBtn) {
    duplicateTaskBtn.onclick = () => {
      if (!editingTask) return;
      pushTaskClone(editingTask);
      closeTaskEditModal();
    };
  }
  
  // Save task
  saveTaskBtn.onclick = () => {
    if (!editingTaskId || !editingTask) return;
    
    editingTask.title = editTaskTitle.value.trim() || 'Untitled';
    editingTask.content = editTaskContent.value.trim();
    editingTask.subject = editTaskSubject.value || '';
    editingTask.color = getTaskColorFromPicker(taskColorPicker) || '';
    const recurrenceValue = editTaskRecurrence ? editTaskRecurrence.value : 'none';
    if (recurrenceValue && recurrenceValue !== 'none') {
      editingTask.recurrence = recurrenceValue;
    } else {
      delete editingTask.recurrence;
    }
    
    // Update due date
    const dueValue = editTaskDue.value;
    if (dueValue) {
      const parsedDue = parseLocal(dueValue);
      editingTask.dueDate = parsedDue ? parsedDue.toISOString() : null;
    } else {
      editingTask.dueDate = null;
    }
    
    // Remove id before saving to Firebase (id is the key, not data)
    const { id, ...cleanTask } = editingTask;
    set(ref(db, `users/${currentUser}/tasks/${editingTaskId}`), cleanTask);
    closeTaskEditModal();
  };

  // ============ SUBJECTS / CATEGORIES ============
  // subjectsRef is user-scoped (see auth block above)
  
  
  const addSubjectBtn = $("addSubjectBtn");
  const addSubjectSidebarBtn = $("addSubjectSidebarBtn");
  const smartViewsList = $("smartViewsList");
  const subjectModal = $("subjectModal");
  const subjectModalTitle = $("subjectModalTitle");
  const subjectNameInput = $("subjectNameInput");
  const subjectColorPicker = $("subjectColorPicker");
  const cancelSubjectBtn = $("cancelSubjectBtn");
  const deleteSubjectBtn = $("deleteSubjectBtn");
  const saveSubjectBtn = $("saveSubjectBtn");
  const parentSubjectSelect = $("parentSubjectSelect");
  const contextMenu = $("contextMenu");
  const eventContextMenu = $("eventContextMenu");
  const reminderModal = $("reminderModal");

  const cachedSubjectsKey = `${CACHE_KEYS.SUBJECTS_PREFIX}${currentUser}`;
  const cachedSubjects = readCache(cachedSubjectsKey);
  if (cachedSubjects && cachedSubjects.length) {
    subjects = cachedSubjects;
    syncCacheUsed.subjects = true;
    updateSyncBadge();
    renderSubjectsSidebar();
    updateSubjectSelectors();
    updateParentSubjectSelector();
  }
  
  // Listen to subjects from Firebase
  onValue(subjectsRef, (snapshot) => {
    const data = snapshot.val();
    if (data) {
      subjects = Object.keys(data).map(key => ({ id: key, ...data[key] }));
    } else {
      subjects = [];
    }
    writeCache(cachedSubjectsKey, subjects, 200);
    markSyncReady('subjects');
    renderSubjectsSidebar();
    updateSubjectSelectors();
    updateParentSubjectSelector();
  }, (error) => {
    console.error('Subjects sync error:', error);
    markSyncReady('subjects');
    updateSyncBadge();
  });
  
  // Get top-level subjects (no parent)
  function getTopLevelSubjects() {
    return subjects.filter(s => !s.parentId);
  }
  
  // Get children of a subject
  function getChildSubjects(parentId) {
    return subjects.filter(s => s.parentId === parentId);
  }
  
  // Count tasks for a subject including children
  function countSubjectTasks(subjectId, includeChildren = true) {
    let count = tasks.filter(t => t.subject === subjectId && !t.completed).length;
    if (includeChildren) {
      const children = getChildSubjects(subjectId);
      children.forEach(c => {
        count += tasks.filter(t => t.subject === c.id && !t.completed).length;
      });
    }
    return count;
  }
  
  // ============ SMART VIEWS COUNTS ============
  function updateSmartViewCounts() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const weekLater = new Date(today);
    weekLater.setDate(weekLater.getDate() + 7);
    
    const activeTasks = tasks.filter(t => !t.completed);
    
    const allCount = activeTasks.length;
    const todayCount = activeTasks.filter(t => {
      if (!t.dueDate) return false;
      const due = new Date(t.dueDate);
      return due >= today && due < tomorrow;
    }).length;
    const weekCount = activeTasks.filter(t => {
      if (!t.dueDate) return false;
      const due = new Date(t.dueDate);
      return due >= today && due < weekLater;
    }).length;
    const overdueCount = activeTasks.filter(t => {
      if (!t.dueDate) return false;
      const due = new Date(t.dueDate);
      return due < now; // Use 'now' for accurate overdue detection
    }).length;
    const noDateCount = activeTasks.filter(t => !t.dueDate).length;
    
    // Update counts
    const countAll = $('countAll');
    const countToday = $('countToday');
    const countWeek = $('countWeek');
    const countOverdue = $('countOverdue');
    const countNoDate = $('countNoDate');
    
    if (countAll) countAll.textContent = allCount;
    if (countToday) countToday.textContent = todayCount;
    if (countWeek) countWeek.textContent = weekCount;
    if (countOverdue) countOverdue.textContent = overdueCount;
    if (countNoDate) countNoDate.textContent = noDateCount;
  }
  
  // ============ TASK CALENDAR ============
  let currentTaskMonth = new Date();
  let taskCalendarExpanded = false;
  let taskCalendarView = 'month';
  let taskCalendarFocusDate = new Date();
  const taskCalendarGrid = $("taskCalendarGrid");
  const taskCalendarTitle = $("taskCalendarTitle");
  const taskMonthEvents = $("taskMonthEvents");
  const taskMonthEventsTitle = $("taskMonthEventsTitle");
  const toggleTaskCalendarSize = $("toggleTaskCalendarSize");
  const taskCalendarViewToggle = $("taskCalendarViewToggle");
  const taskRightSidebar = $("taskRightSidebar");

  // Event delegation for Task calendar in Task Manager
  if (taskCalendarGrid) {
    taskCalendarGrid.addEventListener('click', (e) => {
      const chip = e.target.closest('.calendar-event-chip');
      if (chip) {
        e.stopPropagation();
        const taskId = chip.dataset.taskId;
        if (taskId) {
          const taskRow = document.querySelector(`.task-item[data-id="${taskId}"]`);
          if (taskRow) {
            taskRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            taskRow.style.transition = 'box-shadow 0.3s';
            taskRow.style.boxShadow = '0 0 0 3px var(--accent)';
            setTimeout(() => { taskRow.style.boxShadow = ''; }, 800);
          }
        }
        return;
      }

      const day = e.target.closest('.calendar-day:not(.other-month)');
      if (day) {
        const dateKey = day.dataset.date;
        if (!dateKey) return;
        const focusDate = new Date(`${dateKey}T00:00`);
        if (!Number.isNaN(focusDate.getTime())) {
          setTaskCalendarFocus(focusDate);
        }
        const taskDueInput = $("newTaskDue");
        const taskTitleInput = $("newTaskTitle");
        const quickRow = $("quickAddRow");
        if (taskDueInput) taskDueInput.value = dateKey + 'T23:59';
        if (taskTitleInput) taskTitleInput.focus();
        if (quickRow) quickRow.style.display = 'flex';
        if (quickAddTask) {
          quickAddTask.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    });
  }

  function getTaskCalendarMaxShow() {
    if (taskCalendarView === 'day') return taskCalendarExpanded ? 12 : 8;
    if (taskCalendarView === 'week') return taskCalendarExpanded ? 7 : 4;
    return taskCalendarExpanded ? 7 : 3;
  }

  function updateTaskCalendarViewToggle() {
    if (!taskCalendarViewToggle) return;
    taskCalendarViewToggle.querySelectorAll('button').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.view === taskCalendarView);
    });
  }

  function updateTaskCalendarViewClasses() {
    if (!taskRightSidebar) return;
    taskRightSidebar.classList.toggle('calendar-view-week', taskCalendarView === 'week');
    taskRightSidebar.classList.toggle('calendar-view-day', taskCalendarView === 'day');
  }

  function setTaskCalendarView(view) {
    const prevView = taskCalendarView;
    taskCalendarView = view;
    if (taskCalendarView === 'month') {
      currentTaskMonth = new Date(taskCalendarFocusDate.getFullYear(), taskCalendarFocusDate.getMonth(), 1);
    } else if (prevView === 'month') {
      const base = new Date(currentTaskMonth.getFullYear(), currentTaskMonth.getMonth(), taskCalendarFocusDate.getDate() || 1);
      setTaskCalendarFocus(base);
    }
    updateTaskCalendarViewToggle();
    updateTaskCalendarViewClasses();
    renderTaskCalendar();
  }

  function setTaskCalendarFocus(date) {
    const d = new Date(date);
    if (Number.isNaN(d.getTime())) return;
    d.setHours(0, 0, 0, 0);
    taskCalendarFocusDate = d;
  }

  function getStartOfWeek(date) {
    const d = new Date(date);
    const dayIndex = d.getDay();
    d.setDate(d.getDate() - dayIndex);
    d.setHours(0, 0, 0, 0);
    return d;
  }

  function formatHebrewShortDate(date) {
    return date.toLocaleDateString('he-IL', { day: 'numeric', month: 'short' });
  }
  
  function renderTaskCalendar() {
    if (!taskCalendarGrid || !taskCalendarTitle) return;

    updateTaskCalendarViewToggle();
    updateTaskCalendarViewClasses();

    const today = new Date();
    const todayKey = toDateKey(today);

    // Build task map by date (exclude countdowns/events)
    const tasksByDate = {};
    tasks.forEach(task => {
      if (!task.dueDate) return;
      if (task.isCountdown || task.isEvent) return;
      const key = toDateKey(task.dueDate);
      if (!tasksByDate[key]) tasksByDate[key] = [];
      tasksByDate[key].push(task);
    });

    let html = '';
    const maxShow = getTaskCalendarMaxShow();

    if (taskCalendarView === 'month') {
      const year = currentTaskMonth.getFullYear();
      const month = currentTaskMonth.getMonth();
      taskCalendarTitle.textContent = `${HEBREW_MONTHS[month]} ${year}`;

      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const startDay = firstDay.getDay();
      const daysInMonth = lastDay.getDate();

      for (let i = 0; i < 7; i++) {
        html += `<div class="calendar-day-name">${HEBREW_DAYS[i]}</div>`;
      }

      const prevMonth = new Date(year, month, 0);
      const prevDays = prevMonth.getDate();
      for (let i = startDay - 1; i >= 0; i--) {
        const day = prevDays - i;
        html += `<div class="calendar-day other-month"><div class="calendar-day-number">${day}</div></div>`;
      }

      for (let day = 1; day <= daysInMonth; day++) {
        const dateKey = `${year}-${String(month + 1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
        const isToday = dateKey === todayKey;
        const dayTasks = tasksByDate[dateKey] || [];
        let classes = 'calendar-day';
        if (isToday) classes += ' today';

        let eventsHtml = '<div class="calendar-day-events">';
        const showTime = dayTasks.length > 1;
        dayTasks.slice(0, maxShow).forEach(task => {
          const subjectColor = subjects.find(s => s.id === task.subject)?.color;
          const resolvedColor = resolveTaskColor(task, subjectColor);
          const color = resolvedColor || subjectColor || '#667eea';
          const safeName = escapeHtml(task.title);
          const evtDate = new Date(task.dueDate);
          const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2,'0')}:${String(evtDate.getMinutes()).padStart(2,'0')} ` : '';
          const displayText = timeStr + safeName;
          eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-task-id="${task.id}">${displayText}</div>`;
        });
        if (dayTasks.length > maxShow) {
          eventsHtml += `<div class="calendar-more">+${dayTasks.length - maxShow} ◊¢◊ï◊ì</div>`;
        }
        eventsHtml += '</div>';

        html += `<div class="${classes}" data-date="${dateKey}">
          <div class="calendar-day-number">${day}</div>
          ${eventsHtml}
        </div>`;
      }

      const totalCells = startDay + daysInMonth;
      const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
      for (let i = 1; i <= remainingCells; i++) {
        html += `<div class="calendar-day other-month"><div class="calendar-day-number">${i}</div></div>`;
      }
    } else if (taskCalendarView === 'week') {
      const focus = taskCalendarFocusDate || new Date();
      const start = getStartOfWeek(focus);
      const end = new Date(start);
      end.setDate(start.getDate() + 6);
      taskCalendarTitle.textContent = `◊©◊ë◊ï◊¢ ${formatHebrewShortDate(start)} - ${formatHebrewShortDate(end)}`;

      for (let i = 0; i < 7; i++) {
        const dayDate = new Date(start);
        dayDate.setDate(start.getDate() + i);
        html += `<div class="calendar-day-name">${HEBREW_DAYS[dayDate.getDay()]}</div>`;
      }

      for (let i = 0; i < 7; i++) {
        const dayDate = new Date(start);
        dayDate.setDate(start.getDate() + i);
        const dateKey = toDateKey(dayDate);
        const dayTasks = tasksByDate[dateKey] || [];
        const isToday = dateKey === todayKey;
        const isOtherMonth = dayDate.getMonth() !== focus.getMonth();
        let classes = 'calendar-day';
        if (isToday) classes += ' today';
        if (isOtherMonth) classes += ' other-month';

        let eventsHtml = '<div class="calendar-day-events">';
        const showTime = true;
        dayTasks.slice(0, maxShow).forEach(task => {
          const subjectColor = subjects.find(s => s.id === task.subject)?.color;
          const resolvedColor = resolveTaskColor(task, subjectColor);
          const color = resolvedColor || subjectColor || '#667eea';
          const safeName = escapeHtml(task.title);
          const evtDate = new Date(task.dueDate);
          const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2,'0')}:${String(evtDate.getMinutes()).padStart(2,'0')} ` : '';
          const displayText = timeStr + safeName;
          eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-task-id="${task.id}">${displayText}</div>`;
        });
        if (dayTasks.length > maxShow) {
          eventsHtml += `<div class="calendar-more">+${dayTasks.length - maxShow} ◊¢◊ï◊ì</div>`;
        }
        eventsHtml += '</div>';

        html += `<div class="${classes}" data-date="${dateKey}">
          <div class="calendar-day-number">${dayDate.getDate()}</div>
          ${eventsHtml}
        </div>`;
      }
    } else {
      const focus = taskCalendarFocusDate || new Date();
      const dateKey = toDateKey(focus);
      taskCalendarTitle.textContent = focus.toLocaleDateString('he-IL', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
      html += `<div class="calendar-day-name">${HEBREW_DAYS[focus.getDay()]}</div>`;

      const dayTasks = tasksByDate[dateKey] || [];
      const isToday = dateKey === todayKey;
      let classes = 'calendar-day';
      if (isToday) classes += ' today';

      let eventsHtml = '<div class="calendar-day-events">';
      const showTime = true;
      dayTasks.slice(0, maxShow).forEach(task => {
        const subjectColor = subjects.find(s => s.id === task.subject)?.color;
        const resolvedColor = resolveTaskColor(task, subjectColor);
        const color = resolvedColor || subjectColor || '#667eea';
        const safeName = escapeHtml(task.title);
        const evtDate = new Date(task.dueDate);
        const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2,'0')}:${String(evtDate.getMinutes()).padStart(2,'0')} ` : '';
        const displayText = timeStr + safeName;
        eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-task-id="${task.id}">${displayText}</div>`;
      });
      if (dayTasks.length > maxShow) {
        eventsHtml += `<div class="calendar-more">+${dayTasks.length - maxShow} ◊¢◊ï◊ì</div>`;
      }
      eventsHtml += '</div>';

      html += `<div class="${classes}" data-date="${dateKey}">
        <div class="calendar-day-number">${focus.getDate()}</div>
        ${eventsHtml}
      </div>`;
    }

    taskCalendarGrid.innerHTML = html;
    renderTaskMonthList();
  }

  function renderTaskMonthList() {
    if (!taskMonthEvents || !taskMonthEventsTitle) return;

    let rangeStart;
    let rangeEnd;
    let titleText = '';
    let emptyText = '◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊ë◊ò◊ï◊ï◊ó';

    if (taskCalendarView === 'month') {
      const year = currentTaskMonth.getFullYear();
      const month = currentTaskMonth.getMonth();
      rangeStart = new Date(year, month, 1);
      rangeEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
      titleText = `◊û◊©◊ô◊û◊ï◊™ (◊ú◊ú◊ê ◊°◊§◊ô◊®◊ï◊™ ◊ú◊ê◊ó◊ï◊®) ${HEBREW_MONTHS[month]}`;
      emptyText = '◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊î◊ó◊ï◊ì◊©';
    } else if (taskCalendarView === 'week') {
      const focus = taskCalendarFocusDate || new Date();
      const start = getStartOfWeek(focus);
      const end = new Date(start);
      end.setDate(start.getDate() + 6);
      rangeStart = start;
      rangeEnd = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59, 999);
      titleText = `◊û◊©◊ô◊û◊ï◊™ ◊ú◊©◊ë◊ï◊¢ ${formatHebrewShortDate(start)} - ${formatHebrewShortDate(end)}`;
      emptyText = '◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊î◊©◊ë◊ï◊¢';
    } else {
      const focus = taskCalendarFocusDate || new Date();
      rangeStart = new Date(focus.getFullYear(), focus.getMonth(), focus.getDate());
      rangeEnd = new Date(focus.getFullYear(), focus.getMonth(), focus.getDate(), 23, 59, 59, 999);
      titleText = `◊û◊©◊ô◊û◊ï◊™ ◊ú◊ô◊ï◊ù ${focus.toLocaleDateString('he-IL', { day: 'numeric', month: 'long' })}`;
      emptyText = '◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊î◊ô◊ï◊ù';
    }

    taskMonthEventsTitle.textContent = titleText;

    const rangeTasks = tasks.filter(t => {
      if (!t.dueDate) return false;
      if (t.isCountdown || t.isEvent) return false;
      const d = new Date(t.dueDate);
      return d >= rangeStart && d <= rangeEnd;
    }).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));

    if (rangeTasks.length === 0) {
      taskMonthEvents.innerHTML = `<div class="no-events-msg">${emptyText}</div>`;
      return;
    }

    taskMonthEvents.innerHTML = rangeTasks.map(task => {
      const subjectColor = subjects.find(s => s.id === task.subject)?.color;
      const resolvedColor = resolveTaskColor(task, subjectColor);
      const color = resolvedColor || subjectColor || '#667eea';
      const d = new Date(task.dueDate);
      const dateStr = d.toLocaleDateString('he-IL', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      return `
        <div class="month-event-item" style="border-right-color: ${color}">
          <div class="month-event-color" style="background: ${color}"></div>
          <div class="month-event-info">
            <div class="month-event-name" style="${task.completed ? 'text-decoration: line-through; opacity: 0.7;' : ''}">${escapeHtml(task.title)}</div>
            <div class="month-event-date">${dateStr}</div>
          </div>
        </div>
      `;
    }).join('');
  }

  function shiftTaskCalendar(step) {
    if (taskCalendarView === 'month') {
      currentTaskMonth.setMonth(currentTaskMonth.getMonth() + step);
      setTaskCalendarFocus(new Date(currentTaskMonth.getFullYear(), currentTaskMonth.getMonth(), 1));
    } else if (taskCalendarView === 'week') {
      const next = new Date(taskCalendarFocusDate);
      next.setDate(next.getDate() + step * 7);
      setTaskCalendarFocus(next);
    } else {
      const next = new Date(taskCalendarFocusDate);
      next.setDate(next.getDate() + step);
      setTaskCalendarFocus(next);
    }
    renderTaskCalendar();
  }

  function jumpTaskCalendarToToday() {
    const today = new Date();
    currentTaskMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    setTaskCalendarFocus(today);
    renderTaskCalendar();
  }
  
  // Task Calendar Navigation
  $("prevTaskMonth").onclick = () => {
    shiftTaskCalendar(-1);
  };
  if (taskCalendarViewToggle) {
    taskCalendarViewToggle.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-view]');
      if (!btn) return;
      setTaskCalendarView(btn.dataset.view);
    });
  }
  
  // Toggle Task Calendar
  const toggleTaskCalendar = $("toggleTaskCalendar");
  if (toggleTaskCalendarSize && taskRightSidebar) {
    toggleTaskCalendarSize.onclick = () => {
      taskCalendarExpanded = !taskCalendarExpanded;
      taskRightSidebar.classList.toggle('calendar-expanded', taskCalendarExpanded);
      toggleTaskCalendarSize.textContent = taskCalendarExpanded ? '‚§°' : '‚§¢';
      const label = taskCalendarExpanded ? '◊î◊ß◊ò◊ü' : '◊î◊í◊ì◊ú';
      toggleTaskCalendarSize.title = label;
      toggleTaskCalendarSize.setAttribute('aria-label', label);
      renderTaskCalendar();
    };
  }
  if (toggleTaskCalendar && taskRightSidebar) {
    toggleTaskCalendar.onclick = () => {
      console.log('toggleTaskCalendar clicked');
      const wasHidden = taskRightSidebar.classList.contains("hidden") || getComputedStyle(taskRightSidebar).display === 'none';
      console.log('taskRightSidebar wasHidden=', wasHidden);
      if (wasHidden) {
        taskRightSidebar.classList.remove('hidden');
        taskRightSidebar.style.display = '';
        jumpTaskCalendarToToday();
      } else {
        taskRightSidebar.classList.add('hidden');
        taskRightSidebar.style.display = 'none';
      }
    };
  }
  // Toggle Task Manager Sidebar (subjects)
  const toggleTaskSidebarBtn = $("toggleTaskSidebar");
  const taskSidebar = $("taskSidebar");
  if (toggleTaskSidebarBtn && taskSidebar) {
    toggleTaskSidebarBtn.onclick = () => {
      console.log('toggleTaskSidebar clicked');
      const wasHidden = taskSidebar.classList.contains('hidden') || getComputedStyle(taskSidebar).display === 'none';
      console.log('taskSidebar wasHidden=', wasHidden);
      if (wasHidden) {
        taskSidebar.classList.remove('hidden');
        taskSidebar.style.display = '';
      } else {
        taskSidebar.classList.add('hidden');
        taskSidebar.style.display = 'none';
      }
    };
  }
  $("nextTaskMonth").onclick = () => {
    shiftTaskCalendar(1);
  };
  $("todayTaskBtn").onclick = () => {
    jumpTaskCalendarToToday();
  };
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  // ============ SIDEBAR SUBJECTS RENDERING ============
  function renderSubjectsSidebar() {
    if (!subjectsList) return;
    
    updateSmartViewCounts();
    
    let html = '';
    const topLevel = getTopLevelSubjects();
    
    topLevel.forEach(s => {
      const children = getChildSubjects(s.id);
      const hasChildren = children.length > 0;
      const isExpanded = expandedSubjects.has(s.id);
      const isActive = currentSubject === s.id && !currentSmartView;
      const taskCount = countSubjectTasks(s.id, true);
      
      html += `
        <div class="subject-list-item ${isExpanded ? 'expanded' : ''}" data-subject-id="${s.id}">
          <div class="subject-list-header ${isActive ? 'active' : ''}" data-subject="${s.id}">
            ${hasChildren ? `<span class="collapse-arrow">‚ñº</span>` : ''}
            <span class="subject-color-dot" style="background: ${s.color};"></span>
            <span class="subject-name">${escapeHtml(s.name)}</span>
            ${taskCount > 0 ? `<span class="subject-count">${taskCount}</span>` : ''}
            <div class="subject-actions">
              <button class="subject-action-btn" data-action="add-sub" title="◊î◊ï◊°◊£ ◊™◊™-◊†◊ï◊©◊ê" aria-label="◊î◊ï◊°◊£ ◊™◊™-◊†◊ï◊©◊ê">‚ûï</button>
              <button class="subject-action-btn" data-action="edit" title="◊¢◊®◊ô◊õ◊î" aria-label="◊¢◊®◊ô◊õ◊î">‚úèÔ∏è</button>
              <button class="subject-action-btn delete" data-action="delete" title="◊û◊ó◊ß" aria-label="◊û◊ó◊ß">üóëÔ∏è</button>
            </div>
          </div>
          ${hasChildren ? `
            <div class="subject-list-children">
              ${children.map(c => {
                const childCount = tasks.filter(t => t.subject === c.id && !t.completed).length;
                const childActive = currentSubject === c.id && !currentSmartView;
                return `
                  <div class="subject-child-item ${childActive ? 'active' : ''}" data-subject="${c.id}">
                    <span class="child-color" style="background: ${c.color};"></span>
                    <span class="child-name">${escapeHtml(c.name)}</span>
                    ${childCount > 0 ? `<span class="child-count">${childCount}</span>` : ''}
                    <div class="subject-actions">
                      <button class="subject-action-btn" data-action="edit" title="◊¢◊®◊ô◊õ◊î">‚úèÔ∏è</button>
                      <button class="subject-action-btn delete" data-action="delete" title="◊û◊ó◊ß">üóëÔ∏è</button>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          ` : ''}
        </div>
      `;
    });
    
    subjectsList.innerHTML = html;
    
    // Setup event handlers
    setupSubjectsSidebarHandlers();
    setupSmartViewsHandlers();
  }
  
  function setupSubjectsSidebarHandlers() {
    // Subject headers click - toggle collapse OR select subject
    subjectsList.querySelectorAll('.subject-list-header').forEach(header => {
      header.addEventListener('click', (e) => {
        // Don't do anything if clicking action buttons
        if (e.target.closest('.subject-actions')) {
          return;
        }
        
        const subjectId = header.dataset.subject;
                
        // Always select the subject
        currentSmartView = null;
        currentSubject = subjectId;
        syncQuickAddSubject();
        renderSubjectsSidebar();
        renderTasks();
      });
      
      // Right-click context menu
      header.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showContextMenu(e.clientX, e.clientY, header.dataset.subject);
      });

      attachSubjectDropHandlers(header, header.dataset.subject);
    });
    
    // Collapse arrows - clicking arrow only toggles (doesn't select)
    subjectsList.querySelectorAll('.collapse-arrow').forEach(arrow => {
      arrow.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent header click from also firing
        const subjectId = arrow.closest('.subject-list-item').dataset.subjectId;
        toggleSubjectExpanded(subjectId);
      });
    });
    
    // Subject action buttons (edit, delete, add-sub)
    subjectsList.querySelectorAll('.subject-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        const subjectId = btn.closest('[data-subject]').dataset.subject;
        
        if (action === 'edit') {
          openSubjectModal(subjectId);
        } else if (action === 'add-sub') {
          openSubjectModal(null, subjectId);
        } else if (action === 'delete') {
          if (confirm('◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó ◊©◊ë◊®◊¶◊ï◊†◊ö ◊ú◊û◊ó◊ï◊ß ◊ê◊™ ◊î◊†◊ï◊©◊ê ◊î◊ñ◊î?')) {
            deleteSubjectById(subjectId);
          }
        }
      });
    });
    
    // Child items click
    subjectsList.querySelectorAll('.subject-child-item').forEach(child => {
      child.addEventListener('click', (e) => {
        // Don't select if clicking action buttons
        if (e.target.closest('.subject-actions')) {
          return;
        }
        
        currentSmartView = null;
        currentSubject = child.dataset.subject;
        syncQuickAddSubject();
        renderSubjectsSidebar();
        renderTasks();
      });
      
      // Right-click context menu
      child.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showContextMenu(e.clientX, e.clientY, child.dataset.subject);
      });

      attachSubjectDropHandlers(child, child.dataset.subject);
    });
  }

  function attachSubjectDropHandlers(element, subjectId) {
    if (!element) return;
    element.addEventListener('dragover', (e) => {
      if (!draggingTaskId) return;
      e.preventDefault();
      element.classList.add('drag-over');
    });
    element.addEventListener('dragleave', () => {
      element.classList.remove('drag-over');
    });
    element.addEventListener('drop', (e) => {
      if (!draggingTaskId) return;
      e.preventDefault();
      element.classList.remove('drag-over');
      assignTaskToSubject(draggingTaskId, subjectId);
    });
  }
  
  function toggleSubjectExpanded(subjectId) {
    const item = subjectsList.querySelector(`.subject-list-item[data-subject-id="${subjectId}"]`);
    
    if (expandedSubjects.has(subjectId)) {
      expandedSubjects.delete(subjectId);
      if (item) item.classList.remove('expanded');
    } else {
      expandedSubjects.add(subjectId);
      if (item) item.classList.add('expanded');
    }
  }
  
  function setupSmartViewsHandlers() {
    if (!smartViewsList) return;
    
    // Clone and replace to remove all old event listeners
    smartViewsList.querySelectorAll('.smart-view-item').forEach(item => {
      const newItem = item.cloneNode(true);
      item.parentNode.replaceChild(newItem, item);
    });
    
    smartViewsList.querySelectorAll('.smart-view-item').forEach(item => {
      item.addEventListener('click', () => {
        const view = item.dataset.view;
        if (view === 'all') {
          currentSmartView = null;
          currentSubject = 'all';
        } else {
          currentSmartView = view;
          currentSubject = 'all';
        }
        syncQuickAddSubject();
        
        // Update active states
        smartViewsList.querySelectorAll('.smart-view-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        
        renderSubjectsSidebar();
        renderTasks();
      });
    });
    
    // Set initial active state
    const activeView = currentSmartView || 'all';
    smartViewsList.querySelectorAll('.smart-view-item').forEach(item => {
      item.classList.toggle('active', item.dataset.view === activeView);
    });
  }
  
  // Add subject sidebar button handler
  if (addSubjectSidebarBtn) {
    addSubjectSidebarBtn.addEventListener('click', () => openSubjectModal());
  }
  // Add subject button in header
  if (addSubjectBtn) {
    addSubjectBtn.addEventListener('click', () => {
      console.log('addSubjectBtn clicked');
      openSubjectModal();
    });
  }
  
  // ============ CONTEXT MENU ============
  function showContextMenu(x, y, subjectId) {
    contextMenuTarget = subjectId;
    const subject = subjects.find(s => s.id === subjectId);
    
    // Update menu items based on subject type
    const addSubItem = contextMenu.querySelector('[data-action="add-sub"]');
    if (subject && subject.parentId) {
      // It's a sub-subject, hide "add sub" option
      addSubItem.style.display = 'none';
    } else {
      addSubItem.style.display = 'flex';
    }
    
    // Position and show menu
    contextMenu.style.left = x + 'px';
    contextMenu.style.top = y + 'px';
    contextMenu.classList.add('open');
  }
  
  function hideContextMenu() {
    contextMenu.classList.remove('open');
    contextMenuTarget = null;
    hideEventContextMenu();
  }
  
  // ============ EVENT CONTEXT MENU ============
  function showEventContextMenu(x, y, eventId) {
    eventContextMenuTarget = eventId;
    const evt = events.find(e => e.id === eventId);
    
    // Update menu items based on current state
    const starItem = eventContextMenu.querySelector('[data-action="star"]');
    const pinItem = eventContextMenu.querySelector('[data-action="pin"]');
    
    if (starItem && evt) {
      starItem.innerHTML = evt.highlighted ? '‚≠ê ◊î◊°◊® ◊û◊ï◊¢◊ì◊£' : '‚≠ê ◊°◊û◊ü ◊õ◊û◊ï◊¢◊ì◊£';
    }
    
    if (pinItem && evt) {
      pinItem.innerHTML = evt.pinned ? 'üìå ◊ë◊ò◊ú ◊†◊¢◊ô◊¶◊î' : 'üìå ◊†◊¢◊• ◊ú◊û◊¢◊ú◊î';
    }
    
    // Position and show menu
    eventContextMenu.style.left = x + 'px';
    eventContextMenu.style.top = y + 'px';
    eventContextMenu.classList.add('open');
  }
  
  function hideEventContextMenu() {
    if (eventContextMenu) {
      eventContextMenu.classList.remove('open');
    }
    eventContextMenuTarget = null;
    hideAddEventContextMenu();
  }
  
  // ============ ADD EVENT CONTEXT MENU ============
  const addEventContextMenu = $("addEventContextMenu");
  
  function showAddEventContextMenu(x, y) {
    if (!addEventContextMenu) return;
    
    // Position and show menu
    addEventContextMenu.style.left = x + 'px';
    addEventContextMenu.style.top = y + 'px';
    addEventContextMenu.classList.add('open');
  }
  
  function hideAddEventContextMenu() {
    if (addEventContextMenu) {
      addEventContextMenu.classList.remove('open');
    }
  }
  
  // Add event context menu item clicks
  if (addEventContextMenu) {
    addEventContextMenu.addEventListener('click', (e) => {
      const action = e.target.closest('.context-menu-item')?.dataset.action;
      if (!action) return;
      
      const now = new Date();
      let targetDate = new Date();
      
      if (action === 'add') {
        // Focus on the input panel
        eventName.focus();
        hideAddEventContextMenu();
        return;
      } else if (action === 'add-tomorrow') {
        targetDate.setDate(targetDate.getDate() + 1);
        targetDate.setHours(12, 0, 0, 0);
      } else if (action === 'add-week') {
        targetDate.setDate(targetDate.getDate() + 7);
        targetDate.setHours(12, 0, 0, 0);
      }
      
      // Pre-fill the date - format from local date directly (not via ISO/UTC)
      const pad = n => String(n).padStart(2, '0');
      const localDateStr = `${targetDate.getFullYear()}-${pad(targetDate.getMonth()+1)}-${pad(targetDate.getDate())}T${pad(targetDate.getHours())}:${pad(targetDate.getMinutes())}`;
      eventDate.value = localDateStr;
      eventName.focus();
      
      hideAddEventContextMenu();
    });
  }
  
  // Add right-click on event list area to show add event menu
  eventList.addEventListener('contextmenu', (e) => {
    // Only show add menu if not clicking on an event row
    if (!e.target.closest('.event-row')) {
      e.preventDefault();
      hideContextMenu();
      showAddEventContextMenu(e.clientX, e.clientY);
    }
  });
  
  // Also add to empty state
  emptyState.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    hideContextMenu();
    showAddEventContextMenu(e.clientX, e.clientY);
  });
  
  // Event context menu item clicks
  if (eventContextMenu) {
    eventContextMenu.addEventListener('click', (e) => {
      const action = e.target.closest('.context-menu-item')?.dataset.action;
      if (!action || !eventContextMenuTarget) return;
      
      const evt = events.find(ev => ev.id === eventContextMenuTarget);
      
      if (action === 'edit') {
        startEdit(eventContextMenuTarget);
      } else if (action === 'pin') {
        if (evt) {
          updateInCloud(eventContextMenuTarget, { ...evt, pinned: !evt.pinned });
        }
      } else if (action === 'star') {
        if (evt) {
          updateInCloud(eventContextMenuTarget, { ...evt, highlighted: !evt.highlighted });
        }
      } else if (action === 'duplicate') {
        if (evt) {
          saveToCloud({
            name: evt.name + ' (◊î◊¢◊™◊ß)',
            date: evt.date,
            notes: evt.notes || null,
            reminder: evt.reminder || 0,
            highlighted: false,
            pinned: false
          });
        }
      } else if (action === 'delete') {
        const existing = pendingDeletes.get(eventContextMenuTarget);
        if (existing) clearTimeout(existing.timer);
        const timer = setTimeout(() => {
          deleteFromCloud(eventContextMenuTarget);
          pendingDeletes.delete(eventContextMenuTarget);
          if (lastDeletedId === eventContextMenuTarget) hideUndoToast();
        }, DELETE_TIMEOUT_MS);
        pendingDeletes.set(eventContextMenuTarget, { timer });
        render();
        showUndoToast(evt ? evt.name : 'Event', eventContextMenuTarget);
      }
      
      hideEventContextMenu();
    });
  }
  
  // Context menu item clicks (subjects)
  contextMenu.addEventListener('click', (e) => {
    const action = e.target.closest('.context-menu-item')?.dataset.action;
    if (!action || !contextMenuTarget) return;
    
    if (action === 'edit') {
      openSubjectModal(contextMenuTarget);
    } else if (action === 'add-sub') {
      openSubjectModal(null, contextMenuTarget);
    } else if (action === 'delete') {
      deleteSubjectById(contextMenuTarget);
    }
    
    hideContextMenu();
  });
  
  // Hide context menu on click outside
  document.addEventListener('click', (e) => {
    if (!contextMenu.contains(e.target) && 
        (!eventContextMenu || !eventContextMenu.contains(e.target)) &&
        (!addEventContextMenu || !addEventContextMenu.contains(e.target))) {
      hideContextMenu();
      hideAddEventContextMenu();
    }
  });
  
  document.addEventListener('contextmenu', (e) => {
    // Hide menus when right-clicking elsewhere
    if (!e.target.closest('.subject-list-header') && !e.target.closest('.subject-child-item')) {
      hideContextMenu();
    }
    if (!e.target.closest('.event-row') && !e.target.closest('.event-list') && !e.target.closest('.empty-state')) {
      hideEventContextMenu();
      hideAddEventContextMenu();
    }
  });
  
  function updateSubjectSelectors() {
    // Build hierarchical options for task subject selectors
    let options = `<option value="">◊ú◊ú◊ê ◊†◊ï◊©◊ê</option>`;
    
    const topLevel = getTopLevelSubjects();
    topLevel.forEach(s => {
      options += `<option value="${s.id}">${escapeHtml(s.name)}</option>`;
      const children = getChildSubjects(s.id);
      children.forEach(c => {
        options += `<option value="${c.id}">&nbsp;&nbsp;‚Ü≥ ${escapeHtml(c.name)}</option>`;
      });
    });
    
    newTaskSubject.innerHTML = options;
    editTaskSubject.innerHTML = options;
    syncQuickAddSubject();
  }
  
  function updateParentSubjectSelector() {
    // Only top-level subjects can be parents
    let options = `<option value="">◊ú◊ú◊ê (◊†◊ï◊©◊ê ◊®◊ê◊©◊ô)</option>`;
    const topLevel = getTopLevelSubjects();
    topLevel.forEach(s => {
      // Don't allow setting itself as parent when editing
      if (s.id !== editingSubjectId) {
        options += `<option value="${s.id}">${escapeHtml(s.name)}</option>`;
      }
    });
    parentSubjectSelect.innerHTML = options;
  }
  
  // Update getFilteredTasks to include subject filter AND smart views
  const originalGetFilteredTasks = getFilteredTasks;
  getFilteredTasks = function() {
    let filtered = originalGetFilteredTasks();
    
    // Apply smart view filter
    if (currentSmartView) {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const weekLater = new Date(today);
      weekLater.setDate(weekLater.getDate() + 7);
      
      if (currentSmartView === 'today') {
        filtered = filtered.filter(t => {
          if (!t.dueDate) return false;
          const due = new Date(t.dueDate);
          return due >= today && due < tomorrow;
        });
      } else if (currentSmartView === 'week') {
        filtered = filtered.filter(t => {
          if (!t.dueDate) return false;
          const due = new Date(t.dueDate);
          return due >= today && due < weekLater;
        });
      } else if (currentSmartView === 'overdue') {
        filtered = filtered.filter(t => {
          if (!t.dueDate || t.completed) return false;
          return new Date(t.dueDate) < now;
        });
      } else if (currentSmartView === 'nodate') {
        filtered = filtered.filter(t => !t.dueDate && !t.completed);
      }
    }
    
    // Apply subject filter
    if (currentSubject !== 'all' && !currentSmartView) {
      const selectedSubject = subjects.find(s => s.id === currentSubject);
      const isSubSubject = selectedSubject && selectedSubject.parentId;
      
      // Get all valid subject IDs (current + children if parent)
      const validIds = [currentSubject];
      const children = getChildSubjects(currentSubject);
      children.forEach(c => validIds.push(c.id));
      
      const subjectFiltered = filtered.filter(t => validIds.includes(t.subject));
      
      // If this is a sub-subject with no tasks, show high priority tasks from all subjects due today/tomorrow
      if (isSubSubject && subjectFiltered.filter(t => !t.completed).length === 0) {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const dayAfterTomorrow = new Date(today);
        dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2);
        
        // Get high priority tasks (urgent, high) due today or tomorrow from all subjects
        filtered = filtered.filter(t => {
          if (t.completed) return false;
          const isHighPriority = t.priority === 'urgent' || t.priority === 'high';
          const hasDueDate = t.dueDate;
          if (!hasDueDate) return isHighPriority; // Include high priority without date
          const due = new Date(t.dueDate);
          const isDueSoon = due >= today && due < dayAfterTomorrow;
          return isHighPriority || isDueSoon;
        });
        
        // Sort by priority then by due date
        filtered.sort((a, b) => {
          const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3, none: 4 };
          const pDiff = (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
          if (pDiff !== 0) return pDiff;
          if (!a.dueDate && !b.dueDate) return 0;
          if (!a.dueDate) return 1;
          if (!b.dueDate) return -1;
          return new Date(a.dueDate) - new Date(b.dueDate);
        });
        
        // Mark that we're showing suggested tasks
        window.showingSuggestedTasks = true;
      } else {
        filtered = subjectFiltered;
        window.showingSuggestedTasks = false;
      }
    } else {
      window.showingSuggestedTasks = false;
    }
    
    return filtered;
  };
  
  
  
  function openSubjectModal(subjectId, parentId = null) {
    console.log('openSubjectModal called', { subjectId, parentId });
    editingSubjectId = subjectId;
    updateParentSubjectSelector();
    
    if (subjectId) {
      const subject = subjects.find(s => s.id === subjectId);
      if (!subject) return;
      subjectModalTitle.textContent = '◊¢◊®◊ï◊ö ◊†◊ï◊©◊ê';
      subjectNameInput.value = subject.name;
      selectedSubjectColor = subject.color;
      parentSubjectSelect.value = subject.parentId || '';
      deleteSubjectBtn.style.display = 'block';
      
      // If editing a parent with children, disable parent selector
      const children = getChildSubjects(subjectId);
      parentSubjectSelect.disabled = children.length > 0;
    } else {
      subjectModalTitle.textContent = parentId ? '◊î◊ï◊°◊£ ◊™◊™-◊†◊ï◊©◊ê' : '◊î◊ï◊°◊£ ◊†◊ï◊©◊ê ◊ó◊ì◊©';
      subjectNameInput.value = '';
      selectedSubjectColor = '#667eea';
      parentSubjectSelect.value = parentId || '';
      parentSubjectSelect.disabled = false;
      deleteSubjectBtn.style.display = 'none';
    }
    
    // Update color picker selection
    subjectColorPicker.querySelectorAll('.subject-color-option').forEach(opt => {
      opt.classList.toggle('selected', opt.dataset.color === selectedSubjectColor);
    });
    
    subjectModal.classList.add('open');
    subjectNameInput.focus();
  }
  
  function closeSubjectModal() {
    subjectModal.classList.remove('open');
    editingSubjectId = null;
  }
  
  subjectModal.addEventListener('click', (e) => {
    if (e.target === subjectModal) closeSubjectModal();
  });
  
  // Color picker
  subjectColorPicker.addEventListener('click', (e) => {
    const option = e.target.closest('.subject-color-option');
    if (!option) return;
    subjectColorPicker.querySelectorAll('.subject-color-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedSubjectColor = option.dataset.color;
  });
  
  // Cancel button
  cancelSubjectBtn.onclick = closeSubjectModal;
  
  // Save subject
  saveSubjectBtn.onclick = () => {
    console.log('saveSubjectBtn clicked, name=', subjectNameInput.value);
    const name = subjectNameInput.value.trim();
    if (!name) return;
    
    const parentId = parentSubjectSelect.value || null;
    
    const subjectData = {
      name,
      color: selectedSubjectColor,
      parentId,
      createdAt: new Date().toISOString()
    };
    
    if (editingSubjectId) {
      // Update existing
      set(ref(db, `users/${currentUser}/subjects/${editingSubjectId}`), subjectData);
    } else {
      // Create new
      const newSubjectRef = push(subjectsRef);
      set(newSubjectRef, subjectData);
    }
    
    closeSubjectModal();
  };
  
  subjectNameInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') saveSubjectBtn.click();
  });
  
  // Delete subject by ID (used from dropdown buttons)
  function deleteSubjectById(subjectId) {
    const subject = subjects.find(s => s.id === subjectId);
    if (!subject) return;
    
    const children = getChildSubjects(subjectId);
    let message = `Delete "${subject.name}"?`;
    if (children.length > 0) {
      message += ` This will also delete ${children.length} sub-subject(s).`;
    }
    message += ' Tasks will remain but become uncategorized.';
    
    if (confirm(message)) {
      // Delete children first
      children.forEach(child => {
        tasks.forEach(task => {
          if (task.subject === child.id) {
            set(ref(db, `users/${currentUser}/tasks/${task.id}/subject`), '');
          }
        });
        remove(ref(db, `users/${currentUser}/subjects/${child.id}`));
      });
      
      // Remove subject from all tasks that have it
      tasks.forEach(task => {
        if (task.subject === subjectId) {
          set(ref(db, `users/${currentUser}/tasks/${task.id}/subject`), '');
        }
      });
      
      // Delete the subject
      remove(ref(db, `users/${currentUser}/subjects/${subjectId}`));
      
      // Reset to all if we were viewing that subject
      if (currentSubject === subjectId || children.some(c => c.id === currentSubject)) {
        currentSubject = 'all';
      }
    }
  }
  
  // Delete subject from modal
  deleteSubjectBtn.onclick = () => {
    if (!editingSubjectId) return;
    deleteSubjectById(editingSubjectId);
    closeSubjectModal();
  };
  
  // Update openTaskEditModal to set subject
  const originalOpenTaskEditModal = openTaskEditModal;
  openTaskEditModal = function(taskId) {
    originalOpenTaskEditModal(taskId);
    if (editingTask) {
      editTaskSubject.value = editingTask.subject || '';
    }
  };

  // ============ IMPROVED NATURAL LANGUAGE PARSING (Hebrew + English RTL-Safe) ============
  function parseNaturalLanguage(input) {
    let title = input;
    let dueDate = null;
    let priority = 'medium';
    let subjectId = '';

    // Helper: Normalize text by removing ALL spaces and converting to lowercase
    const normalize = (str) => str.replace(/\s+/g, '').toLowerCase();

    // ============ STEP 1: EXTRACT & REMOVE PRIORITY ============
    const priorityPatterns = [
      { level: 'urgent', patterns: [/\b(◊ì◊ó◊ï◊£|◊û◊ô◊ô◊ì◊ô|urgent|asap|!!!|!!)\b/gi] },
      { level: 'high', patterns: [/\b(◊í◊ë◊ï◊î|◊ó◊©◊ï◊ë|high|important|!)\b/gi] },
      { level: 'medium', patterns: [/\b(◊ë◊ô◊†◊ï◊†◊ô|◊®◊í◊ô◊ú|medium|normal)\b/gi] },
      { level: 'low', patterns: [/\b(◊†◊û◊ï◊ö|◊ú◊ê ◊ì◊ó◊ï◊£|low)\b/gi] }
    ];

    for (const { level, patterns } of priorityPatterns) {
      for (const pattern of patterns) {
        const matches = title.match(pattern);
        if (matches) {
          priority = level;
          // Remove all matches
          matches.forEach(match => {
            title = title.replace(match, ' ');
          });
          break;
        }
      }
      if (priority !== 'medium') break;
    }
    title = title.trim();

    // ============ STEP 2: EXTRACT & REMOVE TIME ============
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    let hours = 23, minutes = 59;

    // Time patterns - support multiple formats
    const timePatterns = [
      /\b(\d{1,2}):(\d{2})\b/g,                    // 14:30, 9:00
      /\b◊ë◊©◊¢◊î\s*(\d{1,2}):(\d{2})\b/gi,           // ◊ë◊©◊¢◊î 14:30
      /\bat\s*(\d{1,2}):(\d{2})\b/gi,              // at 14:30
      /\b(\d{1,2})\.(\d{2})\b/g,                   // 14.30
      /\b(\d{1,2}):(\d{2})\s*(am|pm)\b/gi,        // 2:30 PM
      /\b◊ë-?(\d{1,2}):(\d{2})\b/gi                 // ◊ë-14:30
    ];

    for (const pattern of timePatterns) {
      const match = title.match(pattern);
      if (match) {
        const firstMatch = match[0];
        const timeMatch = firstMatch.match(/(\d{1,2})[:.](\d{2})/);
        if (timeMatch) {
          hours = parseInt(timeMatch[1]);
          minutes = parseInt(timeMatch[2]);
          
          // Handle AM/PM
          const isPM = /pm/i.test(firstMatch);
          const isAM = /am/i.test(firstMatch);
          if (isPM && hours < 12) hours += 12;
          if (isAM && hours === 12) hours = 0;
          
          // Validate time
          if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
            title = title.replace(firstMatch, ' ').trim();
            break;
          }
        }
      }
    }

    // ============ STEP 3: EXTRACT & REMOVE DATE ============
    const dateKeywords = [
      { patterns: [/◊û◊ó◊®◊™◊ô◊ô◊ù/gi], days: 2 },
      { patterns: [/◊ë◊¢◊ï◊ì ◊ô◊ï◊û◊ô◊ô◊ù/gi, /in 2 days/gi], days: 2 },
      { patterns: [/◊ë◊¢◊ï◊ì 3 ◊ô◊û◊ô◊ù/gi, /in 3 days/gi], days: 3 },
      { patterns: [/◊ë◊¢◊ï◊ì 4 ◊ô◊û◊ô◊ù/gi, /in 4 days/gi], days: 4 },
      { patterns: [/◊ë◊¢◊ï◊ì 5 ◊ô◊û◊ô◊ù/gi, /in 5 days/gi], days: 5 },
      { patterns: [/◊ú◊î◊ô◊ï◊ù/gi, /◊î◊ô◊ï◊ù/gi, /today/gi], days: 0 },
      { patterns: [/◊ú◊û◊ó◊®/gi, /◊û◊ó◊®/gi, /tomorrow/gi], days: 1 },
      { patterns: [/◊ë◊¢◊ï◊ì ◊©◊ë◊ï◊¢◊ô◊ô◊ù/gi, /in 2 weeks/gi], days: 14 },
      { patterns: [/◊ë◊¢◊ï◊ì ◊©◊ë◊ï◊¢/gi, /in a week/gi], days: 7 },
      { patterns: [/◊î◊©◊ë◊ï◊¢/gi, /◊ë◊©◊ë◊ï◊¢ ◊î◊ë◊ê/gi, /this week/gi, /next week/gi], days: 7 },
      { patterns: [/◊ë◊¢◊ï◊ì ◊ó◊ï◊ì◊©/gi, /in a month/gi], days: 30 },
    ];

    for (const { patterns, days } of dateKeywords) {
      let matched = false;
      for (const pattern of patterns) {
        const matches = title.match(pattern);
        if (matches) {
          dueDate = new Date(today);
          dueDate.setDate(dueDate.getDate() + days);
          dueDate.setHours(hours, minutes, 0, 0);
          // Remove all matches
          matches.forEach(match => {
            title = title.replace(match, ' ');
          });
          matched = true;
          break;
        }
      }
      if (matched) break;
    }

    // Hebrew & English day names
    if (!dueDate) {
      const hebrewDays = ['◊®◊ê◊©◊ï◊ü', '◊©◊†◊ô', '◊©◊ú◊ô◊©◊ô', '◊®◊ë◊ô◊¢◊ô', '◊ó◊û◊ô◊©◊ô', '◊©◊ô◊©◊ô', '◊©◊ë◊™'];
      const englishDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      
      for (let i = 0; i < 7; i++) {
        const hebrewPattern = new RegExp(`(◊ë◊ô◊ï◊ù\\s+|◊ô◊ï◊ù\\s+)?${hebrewDays[i]}`, 'gi');
        const englishPattern = new RegExp(`(on\\s+)?${englishDays[i]}`, 'gi');
        
        const heMatches = title.match(hebrewPattern);
        const enMatches = title.match(englishPattern);
        
        if (heMatches || enMatches) {
          const currentDay = today.getDay();
          let daysToAdd = i - currentDay;
          if (daysToAdd <= 0) daysToAdd += 7;
          
          dueDate = new Date(today);
          dueDate.setDate(dueDate.getDate() + daysToAdd);
          dueDate.setHours(hours, minutes, 0, 0);
          
          if (heMatches) heMatches.forEach(m => title = title.replace(m, ' '));
          if (enMatches) enMatches.forEach(m => title = title.replace(m, ' '));
          break;
        }
      }
    }

    // Specific date formats: DD/MM or DD.MM
    if (!dueDate) {
      const datePattern = /\b(\d{1,2})[\/\.](\d{1,2})\b/g;
      const match = title.match(datePattern);
      if (match) {
        const firstMatch = match[0];
        const parts = firstMatch.split(/[\/\.]/);
        const day = parseInt(parts[0]);
        const month = parseInt(parts[1]) - 1; // JS months are 0-indexed
        
        if (day >= 1 && day <= 31 && month >= 0 && month <= 11) {
          dueDate = new Date(today.getFullYear(), month, day, hours, minutes, 0, 0);
          
          // If date is in the past, assume next year
          if (dueDate < now) {
            dueDate.setFullYear(dueDate.getFullYear() + 1);
          }
          
          title = title.replace(firstMatch, ' ').trim();
        }
      }
    }

    // ============ STEP 4: ENHANCED SUBJECT DETECTION ============
    // Sort subjects by name length (longest first) to prevent partial matches
    const sortedSubjects = [...subjects].sort((a, b) => b.name.length - a.name.length);
    let matchedSubject = null;
    let textToRemove = '';

    // METHOD 1: Hashtag with hierarchy #parent/child or #parent/child/grandchild
    const hierarchyMatch = title.match(/#([^#\s]+)\/([^#\s\/]+)(?:\/([^#\s\/]+))?/);
    if (hierarchyMatch) {
      const parentSearch = normalize(hierarchyMatch[1].replace(/_/g, ' '));
      const childSearch = normalize(hierarchyMatch[2].replace(/_/g, ' '));
      const grandchildSearch = hierarchyMatch[3] ? normalize(hierarchyMatch[3].replace(/_/g, ' ')) : null;
      
      // Find parent
      const parent = sortedSubjects.find(s => 
        !s.parentId && normalize(s.name).includes(parentSearch)
      );
      
      if (parent) {
        // Find child
        let child = subjects.find(s => 
          s.parentId === parent.id && normalize(s.name).includes(childSearch)
        );
        
        // If grandchild specified, find it
        if (child && grandchildSearch) {
          const grandchild = subjects.find(s =>
            s.parentId === child.id && normalize(s.name).includes(grandchildSearch)
          );
          if (grandchild) {
            matchedSubject = grandchild;
          } else {
            matchedSubject = child; // Fallback to child if grandchild not found
          }
        } else if (child) {
          matchedSubject = child;
        }
        
        if (matchedSubject) {
          textToRemove = hierarchyMatch[0];
        }
      }
    }

    // METHOD 2: Explicit Hashtag - Search ALL subjects (parent and children)
    if (!matchedSubject) {
      const hashIndex = title.indexOf('#');
      
      if (hashIndex !== -1) {
        const afterHash = title.substring(hashIndex + 1);
        
        // Check for quoted format first
        const quotedMatch = afterHash.match(/^"([^"]+)"/);
        if (quotedMatch) {
          const searchNorm = normalize(quotedMatch[1]);
          // Search in ALL subjects (including children)
          matchedSubject = sortedSubjects.find(s => normalize(s.name) === searchNorm);
          if (matchedSubject) {
            textToRemove = '#"' + quotedMatch[1] + '"';
          }
        }
        
        // Check for underscore format
        if (!matchedSubject) {
          const underscoreMatch = afterHash.match(/^([^\s]+)/);
          if (underscoreMatch) {
            const searchText = underscoreMatch[1].replace(/_/g, ' ');
            const searchNorm = normalize(searchText);
            // Search in ALL subjects (including children)
            matchedSubject = sortedSubjects.find(s => normalize(s.name) === searchNorm);
            if (matchedSubject) {
              textToRemove = '#' + underscoreMatch[1];
            }
          }
        }
        
        // Character-by-character matching (space-insensitive)
        if (!matchedSubject) {
          const afterHashNormalized = normalize(afterHash);
          
          // Search in ALL subjects (including children)
          for (const subject of sortedSubjects) {
            const subjectNormalized = normalize(subject.name);
            
            if (afterHashNormalized.startsWith(subjectNormalized)) {
              matchedSubject = subject;
              
              // Calculate exact length to remove
              let matchLength = 0;
              let subjectCharIdx = 0;
              const subjectNoSpaces = subject.name.replace(/\s+/g, '').toLowerCase();
              
              for (let i = 0; i < afterHash.length; i++) {
                const char = afterHash[i].toLowerCase();
                if (/\s/.test(char)) {
                  matchLength++;
                  continue;
                }
                if (char === subjectNoSpaces[subjectCharIdx]) {
                  matchLength++;
                  subjectCharIdx++;
                  if (subjectCharIdx >= subjectNoSpaces.length) break;
                } else {
                  break;
                }
              }
              
              textToRemove = '#' + afterHash.substring(0, matchLength);
              break;
            }
          }
        }
      }
    }

    // METHOD 3: Auto-detect subject name anywhere in text (without #)
    // Search ALL subjects - children are prioritized because sortedSubjects is by length
    if (!matchedSubject) {
      for (const subject of sortedSubjects) {
        // Create flexible regex that allows optional spaces between letters
        const words = subject.name.split(/\s+/);
        const pattern = words.map(w => 
          w.split('').map(c => c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('\\s*')
        ).join('\\s+');
        const boundary = "(?:^|\\s|[\\.,!\\?;:\\-\\(\\)\\[\\]{}\"'])";
        const regex = new RegExp(`${boundary}(${pattern})(?=$|\\s|[\\.,!\\?;:\\-\\(\\)\\[\\]{}\"'])`, 'i');
        
        const match = title.match(regex);
        if (match) {
          matchedSubject = subject;
          textToRemove = match[1] || match[0];
          break;
        }
      }
    }

    // Apply subject match
    if (matchedSubject) {
      subjectId = matchedSubject.id;
      if (textToRemove) {
        title = title.replace(textToRemove, ' ').trim();
      }
    }

    // ============ STEP 5: FINAL CLEANUP ============
    title = title.replace(/#\s*/g, ' ');
    title = title.replace(/\s+/g, ' ').trim();
    title = title.replace(/^[,.:;\-]+\s*/, '').replace(/\s*[,.:;\-]+$/, '').trim();

    return { title, dueDate, priority, subjectId };
  }
  
  // Legacy helper - kept for compatibility
  function normalizeForComparison(text) {
    return text.toLowerCase().replace(/\s+/g, '').trim();
  }
  
  // Helper function to find best matching subject (used by some methods)
  function findBestSubjectMatch(searchTerm, sortedSubjects) {
    const normalize = (str) => str.replace(/\s+/g, '').toLowerCase();
    const searchNorm = normalize(searchTerm);
    const searchLower = searchTerm.toLowerCase().trim(); // Define searchLower for fuzzy matching
    
    // 1. Exact match (space-insensitive)
    let found = sortedSubjects.find(s => normalize(s.name) === searchNorm);
    if (found) return found;
    
    // 2. Starts with
    found = sortedSubjects.find(s => normalize(s.name).startsWith(searchNorm));
    if (found) return found;
    
    // 3. Search term starts with subject name
    found = sortedSubjects.find(s => searchNorm.startsWith(normalize(s.name)));
    if (found) return found;
    
    // 4. Contains
    found = sortedSubjects.find(s => normalize(s.name).includes(searchNorm));
    if (found) return found;
    
    // 5. Reverse contains
    found = sortedSubjects.find(s => searchLower.includes(s.name.toLowerCase()));
    if (found) return found;
    
    // 6. Fuzzy match - check if all words from search appear in subject name
    const searchWords = searchLower.split(/\s+/);
    found = sortedSubjects.find(s => {
      const subjectLower = s.name.toLowerCase();
      return searchWords.every(word => subjectLower.includes(word));
    });
    if (found) return found;
    
    return null;
  }
  
  // Smart quick add with natural language + Enter to add
  newTaskTitle.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter') return;
    e.preventDefault();
    const input = newTaskTitle.value.trim();
    if (!input) return;
    
    const parsed = parseNaturalLanguage(input);
    const hasParsed = parsed.dueDate || parsed.subjectId || parsed.priority !== 'medium';
    
    if (hasParsed) {
      const defaultSubjectId = getDefaultSubjectId();
      const selectedSubjectId = parsed.subjectId || defaultSubjectId;
      const orderValue = hasManualOrder() ? getNextTaskOrder(false) : null;
      const recurrence = newTaskRecurrence ? newTaskRecurrence.value : 'none';
      
        const taskData = {
          title: parsed.title || input,
          content: '',
          priority: parsed.priority,
          dueDate: parsed.dueDate ? parsed.dueDate.toISOString() : null,
          subject: selectedSubjectId || '',
          checklist: [],
          completed: false,
          createdAt: new Date().toISOString(),
          ...(Number.isFinite(orderValue) ? { order: orderValue } : {}),
          ...(selectedTaskColor ? { color: selectedTaskColor } : {}),
          ...(recurrence && recurrence !== 'none' ? { recurrence } : {})
        };
      
      const newTaskRef = push(tasksRef);
      set(newTaskRef, taskData);
      
      const taskSections = $("taskSections");
      if (taskSections) {
        taskSections.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
        newTaskTitle.value = '';
        quickAddRow.style.display = 'none';
        selectedTaskColor = '';
        if (newTaskRecurrence) newTaskRecurrence.value = 'none';
        setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
        syncQuickAddSubject();
    } else {
      addTask();
    }
  });

  if (newTaskDue) {
    newTaskDue.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      addTask();
    });
  }

  // Kick off Pomodoro UI
  Pomodoro.init();

  // ============ DAILY REMINDER ============
  const closeReminderBtn = $("closeReminderBtn");
  const reminderDate = $("reminderDate");
  const todayTasksList = $("todayTasksList");
  const tomorrowTasksList = $("tomorrowTasksList");
  const todayTasksSection = $("todayTasksSection");
  const tomorrowTasksSection = $("tomorrowTasksSection");
  
  function showDailyReminder() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const dayAfterTomorrow = new Date(tomorrow);
    dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
    
    // Format date in Hebrew
    const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    reminderDate.textContent = now.toLocaleDateString('he-IL', dateOptions);
    
    // Get today's tasks
    const todayTasks = tasks.filter(t => {
      if (!t.dueDate || t.completed) return false;
      const due = new Date(t.dueDate);
      return due >= today && due < tomorrow;
    }).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
    
    // Get tomorrow's tasks
    const tomorrowTasks = tasks.filter(t => {
      if (!t.dueDate || t.completed) return false;
      const due = new Date(t.dueDate);
      return due >= tomorrow && due < dayAfterTomorrow;
    }).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
    
    // Render today's tasks
    if (todayTasks.length > 0) {
      todayTasksSection.style.display = 'block';
      todayTasksList.innerHTML = todayTasks.map(t => renderReminderTask(t)).join('');
    } else {
      todayTasksSection.style.display = 'block';
      todayTasksList.innerHTML = '<div class="reminder-empty">üéâ ◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊ú◊î◊ô◊ï◊ù!</div>';
    }
    
    // Render tomorrow's tasks
    if (tomorrowTasks.length > 0) {
      tomorrowTasksSection.style.display = 'block';
      tomorrowTasksList.innerHTML = tomorrowTasks.map(t => renderReminderTask(t)).join('');
    } else {
      tomorrowTasksSection.style.display = 'none';
    }
    
    reminderModal.classList.add('open');
  }
  
  function renderReminderTask(task) {
    const priorityColors = {
      urgent: '#ef4444',
      high: '#f97316',
      medium: '#eab308',
      low: '#22c55e',
      none: '#6b7280'
    };
    const color = priorityColors[task.priority || 'none'];
    const time = task.dueDate ? new Date(task.dueDate).toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' }) : '';
    
    return `
      <div class="reminder-task-item">
        <div class="task-priority-dot" style="background: ${color};"></div>
        <div class="task-info">
          <div class="task-title">${escapeHtml(task.title)}</div>
          ${time ? `<div class="task-time">‚è∞ ${time}</div>` : ''}
        </div>
      </div>
    `;
  }
  
  closeReminderBtn.onclick = () => {
    reminderModal.classList.remove('open');
    localStorage.setItem('lastReminderDate', new Date().toDateString());
  };
  
  // Check if we should show reminder (at 9:00 AM)
  function checkDailyReminder() {
    const now = new Date();
    const lastReminder = localStorage.getItem('lastReminderDate');
    const todayString = now.toDateString();
    
    // If already shown today, skip
    if (lastReminder === todayString) return;
    
    // If it's between 9:00 and 9:30 AM, show reminder
    if (now.getHours() === 9 && now.getMinutes() < 30) {
      // Wait for tasks to load
      if (tasks.length > 0 || subjects.length > 0) {
        showDailyReminder();
      }
    }
  }
  
  // Check every minute
  setInterval(checkDailyReminder, 60000);
  
  // Also check on page load (with delay to let data load)
  setTimeout(checkDailyReminder, 3000);

  // ============ INITIALIZE SMART VIEWS ============
  setupSmartViewsHandlers();
</script>
</body>
</html>
