<!doctype html>
<html lang="he" dir="rtl">

<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=5,user-scalable=yes,viewport-fit=cover" />
  <title>Shared Event Countdowns</title>

  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#667eea" media="(prefers-color-scheme: light)" />
  <meta name="theme-color" content="#0f172a" media="(prefers-color-scheme: dark)" />
  <meta name="description" content="Track countdowns to events and manage tasks with reminders" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Countdowns" />
  <meta name="application-name" content="Countdowns" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="msapplication-TileColor" content="#667eea" />
  <meta name="msapplication-tap-highlight" content="no" />

  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23667eea'/%3E%3Cstop offset='100%25' stop-color='%23764ba2'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='16' cy='16' r='14' fill='url(%23g)'/%3E%3Cpath d='M16 8v8l5 3' stroke='white' stroke-width='2.5' stroke-linecap='round' fill='none'/%3E%3C/svg%3E" />

  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,400..600,0..1,-25..0" />

  <!-- External CSS -->
  <link rel="stylesheet" href="css/styles.css">
</head>

<body>
  <!-- Fixed Header Bar -->
  <div class="fixed-header-bar">
    <button class="header-btn active" id="toggleCountdown">
      <span class="icon" aria-hidden="true">timer</span>
      <span>ספירה לאחור</span>
    </button>
    <button class="header-btn" id="toggleTasks">
      <span class="icon" aria-hidden="true">checklist</span>
      <span>משימות</span>
    </button>
    <button class="header-btn" id="togglePomodoro">
      <span class="icon" aria-hidden="true">timelapse</span>
      <span>פומודורו</span>
    </button>
    <button class="header-btn" id="togglePlanner">
      <span class="icon" aria-hidden="true">event_note</span>
      <span>מתכנן יומי</span>
    </button>
    <div class="header-spacer"></div>
    <button class="header-btn" id="toggleSidebar">
      <span class="icon" aria-hidden="true">calendar_month</span>
      <span>לוח</span>
    </button>
    <span class="sync-badge hidden" id="syncBadge"><span class="sync-dot"></span><span
        class="sync-text">Syncing…</span></span>
    <button class="header-btn icon-only" id="calendarSyncBtn" aria-label="Sync with Calendar"
      title="סנכרון עם לוח השנה"><span class="icon" aria-hidden="true">sync</span></button>
    <button class="header-btn icon-only" id="notifyBtn" aria-label="Enable notifications"
      title="Enable notifications"><span class="icon" aria-hidden="true">notifications</span></button>
    <button class="header-btn icon-only" id="helpShortcuts" aria-label="Keyboard shortcuts" title="קיצורים (H)"><span
        class="icon" aria-hidden="true">keyboard</span></button>
    <button class="header-btn icon-only" id="themeToggle" aria-label="Toggle dark mode"><span class="icon"
        aria-hidden="true">dark_mode</span></button>
    <button class="header-btn" id="userBtn"
      style="margin-left:8px; border:1px solid var(--accent); color:var(--accent);">
      <span class="icon" aria-hidden="true">account_circle</span>
      <span>Guest</span>
    </button>
  </div>

  <!-- Task Manager Fullscreen -->
  <div class="task-manager-overlay" id="taskManagerOverlay">
    <div class="task-manager-header">
      <div class="task-manager-title">📝 Task Manager</div>
      <button class="header-btn" id="toggleTaskSidebar" style="margin-right: 12px;">📚 נושאים</button>
      <button class="task-manager-close" id="closeTaskManager" aria-label="Close task manager">×</button>
      <div class="task-search-bar">
        <input type="text" id="taskSearch" placeholder="חיפוש משימות... / Search tasks..." />
      </div>
      <div class="task-filters">
        <button class="filter-pill active" data-filter="all">הכל</button>
        <button class="filter-pill" data-filter="active">פעיל</button>
        <button class="filter-pill" data-filter="completed">הושלם</button>
        <button class="header-btn" id="toggleTaskCalendar">📅 לוח</button>
      </div>
    </div>

    <!-- Task Manager Layout with Sidebar -->
    <div class="task-manager-layout" style="display: flex; height: 100%; overflow: hidden; position: relative;">
      <!-- Sidebar -->
      <div class="task-manager-sidebar" id="taskSidebar" style="transition: margin-right 0.2s;">
        <div class="task-manager-sidebar-header">
          <h3>📚 נושאים</h3>
          <button class="add-subject-btn" id="addSubjectBtn" title="הוסף נושא">+</button>
        </div>
        <div class="task-manager-sidebar-content">
          <!-- Smart Views -->
          <div class="smart-views-list" id="smartViewsList">
            <div class="smart-view-item" data-view="all">
              <span class="view-icon">📋</span>
              <span class="view-name">כל המשימות</span>
              <span class="view-count" id="countAll">0</span>
            </div>
            <div class="smart-view-item" data-view="today">
              <span class="view-icon">📅</span>
              <span class="view-name">היום</span>
              <span class="view-count" id="countToday">0</span>
            </div>
            <div class="smart-view-item" data-view="tomorrow">
              <span class="view-icon">🌅</span>
              <span class="view-name">מחר</span>
              <span class="view-count" id="countTomorrow">0</span>
            </div>
            <div class="smart-view-item" data-view="week">
              <span class="view-icon">📆</span>
              <span class="view-name">7 ימים הבאים</span>
              <span class="view-count" id="countWeek">0</span>
            </div>
            <div class="smart-view-item" data-view="overdue">
              <span class="view-icon">⚠️</span>
              <span class="view-name">באיחור</span>
              <span class="view-count" id="countOverdue">0</span>
            </div>
            <div class="smart-view-item" data-view="nodate">
              <span class="view-icon">📭</span>
              <span class="view-name">ללא תאריך</span>
              <span class="view-count" id="countNoDate">0</span>
            </div>
          </div>

          <!-- Subjects List -->
          <div class="subjects-list-title">נושאים</div>
          <div class="subjects-list" id="subjectsList"></div>
          <button class="add-subject-sidebar-btn" id="addSubjectSidebarBtn">
            <span>+</span>
            <span>הוסף נושא</span>
          </button>


        </div>
      </div>

      <!-- Main Content -->
      <div class="task-manager-body">
        <div class="quick-add-task" id="quickAddTask">
          <input type="text" id="newTaskTitle" placeholder="הוסף משימה... (לדוגמה: להגיש תרגיל מחר 23:00 #מתמטיקה דחוף)"
            dir="auto" />
          <div class="nl-hint">
            💡 <strong>קצרת דרך:</strong> כתוב בשפה טבעית ולחץ Enter!
            <span class="nl-hint-toggle"
              onclick="document.getElementById('nlExamples').classList.toggle('show')">דוגמאות ▼</span>
            <div class="nl-hint-examples" id="nlExamples">
              <div style="border-bottom: 2px solid var(--accent); padding-bottom: 12px; margin-bottom: 12px;">
                <strong style="color: var(--accent); font-size: 13px;">📅 תאריכים ושעות:</strong>
              </div>
              <div>
                <div class="example-input">להגיש תרגיל מחר 23:59 #מתמטיקה דחוף</div>
                <div class="example-result">→ מחר ב-23:59, נושא: מתמטיקה, עדיפות: דחוף</div>
              </div>
              <div>
                <div class="example-input">פגישה עם יועץ ביום שלישי 14:30</div>
                <div class="example-result">→ יום שלישי הקרוב ב-14:30</div>
              </div>
              <div>
                <div class="example-input">מבחן היום 16:00 גבוה</div>
                <div class="example-result">→ היום ב-16:00, עדיפות: גבוה</div>
              </div>
              <div>
                <div class="example-input">רופא ב-25/12 בשעה 10:30</div>
                <div class="example-result">→ 25 בדצמבר ב-10:30</div>
              </div>

              <div
                style="border-bottom: 2px solid var(--accent); padding-bottom: 12px; margin-bottom: 12px; margin-top: 16px;">
                <strong style="color: var(--accent); font-size: 13px;">📚 נושאים (כולל תת-נושאים):</strong>
              </div>
              <div>
                <div class="example-input">לקרוא פרק 5 #מתמטיקה/אלגברה</div>
                <div class="example-result">→ נושא: מתמטיקה → אלגברה (תת-נושא)</div>
              </div>
              <div>
                <div class="example-input">סיכום שיעור #"היסטוריה מודרנית"</div>
                <div class="example-result">→ נושא עם רווחים (בגרשיים)</div>
              </div>
              <div>
                <div class="example-input">פרוייקט גמר #עבודה/פיתוח/frontend</div>
                <div class="example-result">→ עבודה → פיתוח → frontend (3 רמות!)</div>
              </div>
              <div>
                <div class="example-input">תרגיל בית #מדעי_המחשב</div>
                <div class="example-result">→ נושא עם קו תחתון במקום רווח</div>
              </div>
              <div>
                <div class="example-input">תרגיל #אלגברה</div>
                <div class="example-result">→ ישירות לתת-נושא אלגברה (בלי הורה!)</div>
              </div>
              <div>
                <div class="example-input">פגישה #frontend</div>
                <div class="example-result">→ ישירות לתת-נושא frontend</div>
              </div>
              <div>
                <div class="example-input">קניות לשבת פיזיקה</div>
                <div class="example-result">→ זיהוי אוטומטי של נושא בלי # (אם קיים)</div>
              </div>

              <div
                style="border-bottom: 2px solid var(--accent); padding-bottom: 12px; margin-bottom: 12px; margin-top: 16px;">
                <strong style="color: var(--accent); font-size: 13px;">🚨 עדיפויות:</strong>
              </div>
              <div>
                <div class="example-input">להגיש עבודה דחוף !!!</div>
                <div class="example-result">→ עדיפות: דחוף (!!!, דחוף, מיידי, urgent, asap)</div>
              </div>
              <div>
                <div class="example-input">מבחן חשוב מחר !</div>
                <div class="example-result">→ עדיפות: גבוה (!, גבוה, חשוב, high, important)</div>
              </div>
              <div>
                <div class="example-input">לקרוא מאמר נמוך</div>
                <div class="example-result">→ עדיפות: נמוך (נמוך, לא דחוף, low)</div>
              </div>

              <div
                style="border-bottom: none; padding-top: 16px; color: var(--text); background: var(--day-other); padding: 12px; border-radius: 8px; margin-top: 12px;">
                <strong style="display: block; margin-bottom: 8px; color: var(--accent);">📖 מילות מפתח:</strong>
                <div style="line-height: 1.8; font-size: 11px;">
                  <div><strong>📅 תאריכים:</strong> היום, מחר, מחרתיים, בעוד X ימים, השבוע, בשבוע הבא, ביום
                    ראשון/שני/..., DD/MM</div>
                  <div><strong>⏰ שעות:</strong> 14:30, בשעה 9:00, ב-23:59, 2:30 PM</div>
                  <div><strong>🏷️ נושאים:</strong> #נושא, #נושא_עם_קו_תחתון, #"נושא עם רווחים", #הורה/ילד,
                    #הורה/ילד/נכד</div>
                  <div><strong>🚨 עדיפות:</strong> דחוף (!!!), גבוה (!), בינוני, נמוך</div>
                </div>
              </div>

              <div style="padding-top: 12px; color: var(--muted); font-size: 11px; text-align: center;">
                <strong>💡 טיפ:</strong> אפשר לשלב הכל! לדוגמה: "להגיש פרויקט מחר 23:59 #עבודה/פיתוח דחוף !!"
              </div>
            </div>
          </div>
          <div class="quick-add-row" id="quickAddRow" style="display: none;">
            <div class="priority-selector" id="taskPriorityPicker">
              <div class="priority-option" data-priority="urgent">🔴 דחוף</div>
              <div class="priority-option" data-priority="high">🟠 גבוה</div>
              <div class="priority-option selected" data-priority="medium">🟡 בינוני</div>
              <div class="priority-option" data-priority="low">🟢 נמוך</div>
              <div class="priority-option" data-priority="none">⚪ ללא</div>
            </div>
            <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap; width: 100%;">
              <div class="label-input-wrapper" style="flex-shrink: 0;">
                <span>📁</span>
                <select id="newTaskSubject"
                  style="border: none; background: transparent; color: var(--text); font-size: 13px; outline: none; cursor: pointer;">
                  <option value="">ללא נושא</option>
                </select>
              </div>
              <div class="label-input-wrapper">
                <span>📅</span>
                <input type="datetime-local" id="newTaskDue"
                  style="width: 180px; border: none; background: transparent; color: var(--text);" />
              </div>
              <div class="label-input-wrapper">
                <span>⏱️</span>
                <select id="newTaskDuration"
                  style="border: none; background: transparent; color: var(--text); font-size: 13px; outline: none; cursor: pointer;">
                  <option value="0">ללא משך</option>
                  <option value="15">15 דק׳</option>
                  <option value="30">30 דק׳</option>
                  <option value="45">45 דק׳</option>
                  <option value="60">שעה</option>
                  <option value="90">1.5 שעות</option>
                  <option value="120">שעתיים</option>
                  <option value="180">3 שעות</option>
                </select>
              </div>
              <div class="label-input-wrapper">
                <span style="font-size: 11px; font-weight: 600;">חוזר</span>
                <select id="newTaskRecurrence"
                  style="border: none; background: transparent; color: var(--text); font-size: 13px; outline: none; cursor: pointer;">
                  <option value="none">ללא חזרה</option>
                  <option value="daily">יומי</option>
                  <option value="weekdays">ימי חול</option>
                  <option value="weekly">שבועי</option>
                  <option value="biweekly">דו-שבועי</option>
                  <option value="monthly">חודשי</option>
                  <option value="yearly">שנתי</option>
                </select>
              </div>
              <div class="label-input-wrapper">
                <span>🔔</span>
                <select id="newTaskReminder"
                  style="border: none; background: transparent; color: var(--text); font-size: 13px; outline: none; cursor: pointer;">
                  <option value="0">ללא תזכורת</option>
                  <option value="1">דקה לפני</option>
                  <option value="5">5 דקות לפני</option>
                  <option value="10">10 דקות לפני</option>
                  <option value="15">15 דקות לפני</option>
                  <option value="30">30 דקות לפני</option>
                  <option value="60">שעה לפני</option>
                  <option value="1440">יום לפני</option>
                  <option value="custom">⚙️ מותאם אישית...</option>
                </select>
                <div class="task-reminder-custom hidden" id="newTaskReminderCustomWrap">
                  <input type="number" id="newTaskReminderCustomValue" min="1" step="1"
                    style="width: 60px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; background: var(--input-bg); color: var(--text);"
                    placeholder="#" />
                  <select id="newTaskReminderCustomUnit"
                    style="padding: 4px 8px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; background: var(--input-bg); color: var(--text);">
                    <option value="minutes">דקות</option>
                    <option value="hours">שעות</option>
                    <option value="days">ימים</option>
                  </select>
                </div>
              </div>
              <div class="label-input-wrapper">
                <span>🎨</span>
                <div class="task-color-picker compact" id="quickTaskColorPicker">
                  <div class="task-color-option none selected" data-color="" title="ללא צבע">–</div>
                  <div class="task-color-option subject disabled" data-color="subject" title="צבע נושא">S</div>
                  <div class="task-color-option" data-color="#667eea" style="background: #667eea;" title="סגול"></div>
                  <div class="task-color-option" data-color="#ef4444" style="background: #ef4444;" title="אדום"></div>
                  <div class="task-color-option" data-color="#f97316" style="background: #f97316;" title="כתום"></div>
                  <div class="task-color-option" data-color="#eab308" style="background: #eab308;" title="צהוב"></div>
                  <div class="task-color-option" data-color="#22c55e" style="background: #22c55e;" title="ירוק"></div>
                  <div class="task-color-option" data-color="#06b6d4" style="background: #06b6d4;" title="ציאן"></div>
                  <div class="task-color-option" data-color="#8b5cf6" style="background: #8b5cf6;" title="סגול כהה">
                  </div>
                </div>
              </div>
              <button class="btn btn-primary" id="addTaskBtn">הוסף</button>
            </div>
          </div>
        </div>

        <div class="task-sections" id="taskSections">
          <!-- Active Tasks -->
          <div id="activeSection">
            <div class="task-section-header">
              <div class="task-section-title">📋 משימות פעילות</div>
              <div class="task-sort-dropdown">
                <button class="task-sort-btn" id="taskSortBtn" title="מיין לפי">
                  <span id="taskSortLabel">📅 תאריך</span>
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="m6 9 6 6 6-6" />
                  </svg>
                </button>
                <div class="task-sort-menu" id="taskSortMenu">
                  <div class="task-sort-option selected" data-sort="dueDate">📅 תאריך יעד (קרוב ראשון)</div>
                  <div class="task-sort-option" data-sort="priority">⚡ עדיפות (דחוף ראשון)</div>
                  <div class="task-sort-option" data-sort="created">🕐 נוצר (חדש ראשון)</div>
                  <div class="task-sort-option" data-sort="createdOldest">📆 נוצר (ישן ראשון)</div>
                  <div class="task-sort-option" data-sort="title">🔤 שם (א-ת)</div>
                </div>
              </div>
            </div>
            <div class="task-list" id="activeTasks"></div>
          </div>

          <!-- Completed Tasks -->
          <div id="completedSection" style="display: none;">
            <div class="task-section-title">✅ הושלמו</div>
            <div class="task-list" id="completedTasks"></div>
          </div>

          <!-- Empty State -->
          <div class="tasks-empty" id="tasksEmpty" style="display: none;">
            <div class="tasks-empty-icon">📝</div>
            <h3>אין משימות עדיין</h3>
            <p>הוסף משימה ראשונה למעלה כדי להתחיל!</p>
          </div>
        </div>
      </div>

      <!-- Right Sidebar for Task Calendar -->
      <aside class="sidebar hidden" id="taskRightSidebar">
        <div class="calendar-container">
          <div class="calendar-header">
            <div class="calendar-nav">
              <button id="prevTaskMonth">‹</button>
              <button id="todayTaskBtn">●</button>
              <button id="nextTaskMonth">›</button>
              <button id="toggleTaskCalendarSize" title="הגדל/הקטן" aria-label="הגדל/הקטן">⤢</button>
            </div>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: flex-end;">
              <div class="calendar-title" id="taskCalendarTitle"></div>
              <div class="calendar-view-toggle" id="taskCalendarViewToggle" aria-label="Calendar view">
                <button data-view="month" class="active">חודש</button>
                <button data-view="week">שבוע</button>
                <button data-view="day">יום</button>
              </div>
            </div>
          </div>
          <div class="calendar-grid" id="taskCalendarGrid"></div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title" id="taskMonthEventsTitle">משימות החודש</div>
          <div class="month-events" id="taskMonthEvents">
            <div class="no-events-msg">אין משימות החודש</div>
          </div>
        </div>
      </aside>
    </div><!-- close task-manager-layout -->
  </div>

  <!-- Task Edit Modal -->
  <div class="task-edit-modal" id="taskEditModal">
    <div class="task-edit-card" id="taskEditCard">
      <input type="text" id="editTaskTitle" placeholder="Task title..." />
      <textarea id="editTaskContent" placeholder="Add notes..."></textarea>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Subject</div>
        <select id="editTaskSubject"
          style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px; cursor: pointer;">
          <option value="">No Subject</option>
        </select>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Priority</div>
        <div class="priority-selector" id="editTaskPriority">
          <div class="priority-option" data-priority="urgent">🔴 Urgent</div>
          <div class="priority-option" data-priority="high">🟠 High</div>
          <div class="priority-option" data-priority="medium">🟡 Medium</div>
          <div class="priority-option" data-priority="low">🟢 Low</div>
          <div class="priority-option" data-priority="none">⚪ None</div>
        </div>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Color <span
            style="font-weight: 400; color: var(--muted); font-size: 12px;">(אופציונלי)</span></div>
        <div class="task-color-picker" id="taskColorPicker">
          <div class="task-color-option none selected" data-color="" title="ללא צבע - רק עדיפות">–</div>
          <div class="task-color-option subject disabled" data-color="subject" title="צבע נושא">S</div>
          <div class="task-color-option" data-color="#667eea" style="background: #667eea;" title="סגול"></div>
          <div class="task-color-option" data-color="#ef4444" style="background: #ef4444;" title="אדום"></div>
          <div class="task-color-option" data-color="#f97316" style="background: #f97316;" title="כתום"></div>
          <div class="task-color-option" data-color="#eab308" style="background: #eab308;" title="צהוב"></div>
          <div class="task-color-option" data-color="#22c55e" style="background: #22c55e;" title="ירוק"></div>
          <div class="task-color-option" data-color="#06b6d4" style="background: #06b6d4;" title="ציאן"></div>
          <div class="task-color-option" data-color="#8b5cf6" style="background: #8b5cf6;" title="סגול כהה"></div>
          <div class="task-color-option" data-color="#ec4899" style="background: #ec4899;" title="ורוד"></div>
        </div>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Due Date</div>
        <input type="datetime-local" id="editTaskDue"
          style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%;" />
        <div class="quick-date-options">
          <button class="quick-date-btn" data-action="today">היום</button>
          <button class="quick-date-btn" data-action="tomorrow">מחר</button>
          <button class="quick-date-btn" data-action="nextWeek">שבוע הבא</button>
          <button class="quick-date-btn" data-action="clear"
            style="margin-right: auto; color: var(--danger); border-color: var(--danger);">נקה</button>
        </div>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">⏱️ Duration</div>
        <select id="editTaskDuration"
          style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px; cursor: pointer;">
          <option value="0">ללא משך</option>
          <option value="15">15 דק׳</option>
          <option value="30">30 דק׳</option>
          <option value="45">45 דק׳</option>
          <option value="60">שעה</option>
          <option value="90">1.5 שעות</option>
          <option value="120">שעתיים</option>
          <option value="180">3 שעות</option>
          <option value="240">4 שעות</option>
          <option value="360">6 שעות</option>
          <option value="480">8 שעות</option>
        </select>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Recurrence</div>
        <select id="editTaskRecurrence"
          style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px; cursor: pointer;">
          <option value="none">ללא חזרה</option>
          <option value="daily">יומי</option>
          <option value="weekdays">ימי חול (א׳-ה׳)</option>
          <option value="weekly">שבועי</option>
          <option value="biweekly">דו-שבועי</option>
          <option value="monthly">חודשי</option>
          <option value="yearly">שנתי</option>
        </select>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">Reminder</div>
        <div class="quick-reminder-btns">
          <button type="button" class="quick-reminder-btn" data-minutes="1">1
            דקה</button>
          <button type="button" class="quick-reminder-btn" data-minutes="5">5
            דקות</button>
          <button type="button" class="quick-reminder-btn" data-minutes="10">10
            דקות</button>
          <button type="button" class="quick-reminder-btn" data-minutes="15">15
            דקות</button>
          <button type="button" class="quick-reminder-btn" data-minutes="60">שעה</button>
        </div>
        <select id="editTaskReminder"
          style="padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; width: 100%; max-width: 250px; cursor: pointer;">
          <option value="0">🔕 ללא תזכורת</option>
          <option value="1">🔔 דקה לפני</option>
          <option value="5">🔔 5 דקות לפני</option>
          <option value="10">🔔 10 דקות לפני</option>
          <option value="15">🔔 15 דקות לפני</option>
          <option value="30">🔔 30 דקות לפני</option>
          <option value="60">🔔 שעה לפני</option>
          <option value="1440">🔔 יום לפני</option>
          <option value="custom">⚙️ מותאם אישית...</option>
        </select>
        <div class="task-reminder-custom hidden" id="editTaskReminderCustomWrap"
          style="display: flex; gap: 8px; margin-top: 10px;">
          <input type="number" id="editTaskReminderCustomValue" min="1" step="1"
            style="width: 80px; padding: 10px 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text);"
            placeholder="מספר" />
          <select id="editTaskReminderCustomUnit"
            style="padding: 10px 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text);">
            <option value="minutes">דקות</option>
            <option value="hours">שעות</option>
            <option value="days">ימים</option>
          </select>
        </div>
      </div>

      <div class="task-edit-section">
        <div class="task-edit-section-title">
          Subtasks / Checklist
        </div>
        <div class="task-checklist" id="editTaskChecklist"></div>
        <div class="checklist-add">
          <input type="text" id="newChecklistItem" placeholder="Add subtask..." />
          <button class="btn btn-primary" id="addChecklistItem" style="padding: 10px 16px;"
            aria-label="הוסף פריט">+</button>
        </div>
      </div>

      <div class="task-edit-footer">
        <div style="display: flex; gap: 8px;">
          <button class="task-action-btn" id="duplicateTaskBtn" title="Duplicate" aria-label="שכפל משימה">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </button>
          <button class="task-action-btn delete" id="deleteTaskBtn" title="Delete" aria-label="מחק משימה">🗑️</button>
        </div>
        <button class="btn btn-primary" id="saveTaskBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Pomodoro Overlay -->
  <div class="pomodoro-overlay" id="pomodoroOverlay">
    <div class="pomodoro-header-bar">
      <div class="pomodoro-header-title">🍅 טיימר פומודורו</div>
      <label class="pomodoro-option" style="margin: 0; background: transparent;">
        <input type="checkbox" id="pomodoroMiniToggle" />
        <span style="font-size: 13px;">הצג מיני-טיימר</span>
      </label>
    </div>

    <div class="pomodoro-content">
      <div class="pomodoro-container">
        <div class="pomodoro-card" id="pomodoroCard">

          <!-- Timer Circle -->
          <div class="pomodoro-timer-wrap">
            <div class="pomodoro-timer-ring" id="pomodoroRing" style="--progress: 0%;"></div>
            <div class="pomodoro-timer">
              <div class="pomodoro-time" id="pomodoroDisplay">25:00</div>
              <div class="pomodoro-mode">
                <span class="pomodoro-mode-dot"></span>
                <span id="pomodoroMode">מיקוד</span>
              </div>
              <div class="pomodoro-next" id="pomodoroNext">הבא: הפסקה קצרה</div>
            </div>
          </div>

          <!-- Controls -->
          <div class="pomodoro-controls">
            <button class="pomodoro-btn" id="pomodoroReset" title="איפוס">🔄</button>
            <button class="pomodoro-btn primary" id="pomodoroStart" title="התחל">▶️</button>
            <button class="pomodoro-btn" id="pomodoroSkip" title="דלג">⏭️</button>
            <button class="pomodoro-btn" id="pomodoroPiP" title="Picture-in-Picture">📌</button>
          </div>

          <div id="pomodoroProgress" style="display:none;"></div>

          <!-- Presets -->
          <div class="pomodoro-presets">
            <button class="pomodoro-preset" data-preset="classic">25/5 קלאסי</button>
            <button class="pomodoro-preset" data-preset="flow">50/10 זרימה</button>
            <button class="pomodoro-preset" data-preset="ultradian">90/20 אולטרה</button>
            <button class="pomodoro-preset" data-preset="perfect">52/17 קצב יעיל</button>
            <button class="pomodoro-preset bad-day" data-preset="badday10">😔 10 דק׳</button>
            <button class="pomodoro-preset bad-day" data-preset="badday5">💫 5 דק׳</button>
            <button class="pomodoro-preset" data-preset="custom">⚙️ מותאם אישית</button>
          </div>

          <!-- Bad Day Tip -->
          <div class="pomodoro-bad-day-tip" id="pomodoroBadDayTip" style="display: none;">
            <span class="tip-icon">💡</span>
            <span class="tip-text">יום מאתגר? זה בסדר. גם 5-10 דקות מיקוד עוזרות לשמור על מומנטום ולהפחית סטרס.</span>
          </div>

          <!-- Settings Panel -->
          <div class="pomodoro-settings-panel">
            <div class="pomodoro-field">
              <label>זמן מיקוד</label>
              <input type="number" min="5" max="240" id="pomodoroFocus" value="25" />
            </div>
            <div class="pomodoro-field">
              <label>הפסקה קצרה</label>
              <input type="number" min="3" max="60" id="pomodoroBreak" value="5" />
            </div>
            <div class="pomodoro-field">
              <label>הפסקה ארוכה</label>
              <input type="number" min="5" max="90" id="pomodoroLong" value="15" />
            </div>
            <div class="pomodoro-field">
              <label>הפסקה ארוכה כל כמה מחזורים</label>
              <input type="number" min="1" max="8" id="pomodoroLongEvery" value="4" />
            </div>
          </div>

          <!-- Options -->
          <div class="pomodoro-options">
            <label class="pomodoro-option">
              <input type="checkbox" id="pomodoroAutoContinue" />
              <span>מעבר אוטומטי בין מצבים</span>
            </label>
            <label class="pomodoro-option">
              <input type="checkbox" id="pomodoroSoundEnabled" checked />
              <span>🔔 צליל התראה</span>
            </label>
            <select class="pomodoro-sound-select" id="pomodoroSound">
              <option value="chime">🎵 צלצול עדין</option>
              <option value="soft">🧘 מדיטציה</option>
              <option value="bell">🔔 פעמון</option>
              <option value="digital">📱 דיגיטלי</option>
              <option value="glass">✨ קריסטל</option>
              <option value="success">🎉 פנפרה</option>
            </select>
            <button class="pomodoro-preview-btn" id="pomodoroPreviewSound">▶️ האזן</button>
          </div>

          <!-- Task Select -->
          <select class="pomodoro-task-select" id="pomodoroTaskSelect">
            <option value="">📋 בחר משימת מיקוד (לא חובה)</option>
          </select>

          <!-- Stats -->
          <div class="pomodoro-stats">
            <div class="pomodoro-stat">
              <div class="label">מחזורים</div>
              <div class="value" id="pomodoroSessionCount">0</div>
            </div>
            <div class="pomodoro-stat">
              <div class="label">דקות מיקוד</div>
              <div class="value" id="pomodoroFocusMinutes">0</div>
            </div>
            <div class="pomodoro-stat">
              <div class="label">רצף ימי מיקוד</div>
              <div class="value" id="pomodoroStreak">0</div>
            </div>
          </div>

          <!-- Daily Progress -->
          <div class="pomodoro-daily">
            <div class="pomodoro-daily-bar">
              <div class="pomodoro-daily-fill" id="pomodoroDayProgress"></div>
            </div>
            <div class="pomodoro-daily-label" id="pomodoroDayLabel">0/8 מחזורי מיקוד היום</div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Hidden canvas for Picture-in-Picture -->
  <canvas id="pomodoroPipCanvas" width="400" height="200" style="display: none;"></canvas>



  <!-- ============== DAILY PLANNER ============== -->
  <div class="planner-overlay" id="plannerOverlay">
    <div class="planner-header-bar">
      <div class="planner-header-title">📅 מתכנן יומי</div>

      <div class="planner-date-nav" style="order: 2;">
        <button id="plannerPrevDay">‹</button>
        <span class="planner-current-date" id="plannerCurrentDate">יום ראשון, 1 בינואר 2026</span>
        <button id="plannerNextDay">›</button>
      </div>

      <button class="planner-today-btn" id="plannerTodayBtn" style="order: 3;">📍 היום</button>

      <div class="planner-view-toggle">
        <button class="active" data-view="day">📋 יום</button>
        <button data-view="week">📆 שבוע</button>
      </div>
    </div>

    <div class="planner-stats-bar">
      <div class="planner-stat">
        <div class="planner-stat-icon">📝</div>
        <div class="planner-stat-info">
          <div class="planner-stat-value" id="plannerTotalBlocks">0</div>
          <div class="planner-stat-label">פעילויות</div>
        </div>
      </div>
      <div class="planner-stat">
        <div class="planner-stat-icon">⏱️</div>
        <div class="planner-stat-info">
          <div class="planner-stat-value" id="plannerTotalHours">0 שעות</div>
          <div class="planner-stat-label">זמן מתוכנן</div>
        </div>
      </div>
      <div class="planner-stat">
        <div class="planner-stat-icon">✅</div>
        <div class="planner-stat-info">
          <div class="planner-stat-value" id="plannerCompletedBlocks">0</div>
          <div class="planner-stat-label">הושלמו</div>
        </div>
      </div>
      <div class="planner-stat">
        <div class="planner-stat-icon">🎯</div>
        <div class="planner-stat-info">
          <div class="planner-stat-value" id="plannerProgress">0%</div>
          <div class="planner-stat-label">התקדמות</div>
        </div>
      </div>
    </div>

    <div class="planner-main">
      <!-- Main Content -->
      <div class="planner-content" id="plannerContent">
        <!-- Day View -->
        <div class="planner-day-view" id="plannerDayView">
          <div class="planner-day-header">
            <div class="planner-day-title" id="plannerDayTitle">היום - יום ראשון</div>
            <div class="planner-day-summary">
              <span id="plannerDaySummary">0 פעילויות • 0 שעות</span>
            </div>
          </div>
          <div class="planner-timeline" id="plannerTimeline">
            <!-- Hours will be generated by JS -->
          </div>
        </div>

        <!-- Week View (hidden by default) -->
        <div class="planner-week-view" id="plannerWeekView" style="display: none;">
          <!-- Week days will be generated by JS -->
        </div>
      </div>

      <!-- Sidebar -->
      <div class="planner-sidebar" id="plannerSidebar">
        <!-- Sync All Button -->
        <div style="padding: 16px 16px 0 16px;">
          <button class="planner-sync-all-btn" id="plannerSyncAllBtn">
            <span>🔄</span>
            <span>סנכרן הכל ליום הנוכחי</span>
          </button>
        </div>

        <!-- Mini Calendar -->
        <div class="planner-sidebar-section">
          <div class="planner-sidebar-title">📅 לוח שנה</div>
          <div class="planner-mini-calendar" id="plannerMiniCalendar">
            <div class="planner-mini-header">
              <button class="planner-mini-nav-btn" id="plannerMiniPrev">‹</button>
              <span class="planner-mini-title" id="plannerMiniTitle">ינואר 2026</span>
              <button class="planner-mini-nav-btn" id="plannerMiniNext">›</button>
            </div>
            <div class="planner-mini-grid" id="plannerMiniGrid">
              <!-- Mini calendar grid will be generated by JS -->
            </div>
          </div>
        </div>

        <!-- Countdowns Section -->
        <div class="planner-sidebar-section">
          <div class="planner-sync-header">
            <div class="planner-sidebar-title planner-section-collapse" id="plannerCountdownsToggle">
              <span class="collapse-icon">▼</span> ⏰ ספירות לאחור
            </div>
            <button class="planner-sync-btn" id="plannerSyncCountdownsBtn">
              <span>↓</span> סנכרן
            </button>
          </div>
          <div class="planner-section-content" id="plannerCountdownsList">
            <div class="no-events-msg">אין ספירות לאחור להיום</div>
          </div>
        </div>

        <!-- Scheduled Tasks Section -->
        <div class="planner-sidebar-section">
          <div class="planner-sync-header">
            <div class="planner-sidebar-title planner-section-collapse" id="plannerScheduledTasksToggle">
              <span class="collapse-icon">▼</span> ✅ משימות מתוזמנות
            </div>
            <button class="planner-sync-btn" id="plannerSyncTasksBtn">
              <span>↓</span> סנכרן
            </button>
          </div>
          <div class="planner-section-content" id="plannerScheduledTasksList">
            <div class="no-events-msg">אין משימות מתוזמנות להיום</div>
          </div>
        </div>

        <!-- Quick Templates -->
        <div class="planner-sidebar-section">
          <div class="planner-sidebar-title">⚡ תבניות מהירות</div>
          <button class="planner-template-btn" data-template="morning">
            <span class="planner-template-icon">🌅</span>
            <span>שגרת בוקר</span>
          </button>
          <button class="planner-template-btn" data-template="work">
            <span class="planner-template-icon">💼</span>
            <span>יום עבודה</span>
          </button>
          <button class="planner-template-btn" data-template="study">
            <span class="planner-template-icon">📚</span>
            <span>יום לימודים</span>
          </button>
          <button class="planner-template-btn" data-template="relax">
            <span class="planner-template-icon">🧘</span>
            <span>יום מנוחה</span>
          </button>
        </div>

        <!-- Unscheduled Tasks -->
        <div class="planner-sidebar-section" style="flex: 1; display: flex; flex-direction: column;">
          <div class="planner-sidebar-title">📋 משימות לתזמון</div>
          <div class="planner-quick-tasks" id="plannerQuickTasks">
            <!-- Tasks will be populated by JS -->
            <div class="no-events-msg" id="plannerNoTasks">אין משימות ללא תזמון</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Planner Add/Edit Block Modal -->
  <div class="planner-add-modal" id="plannerAddModal">
    <div class="planner-add-card">
      <div class="planner-add-title" id="plannerModalTitle">➕ הוסף פעילות</div>

      <div class="planner-add-field">
        <label class="planner-add-label">שם הפעילות *</label>
        <input type="text" class="planner-add-input" id="plannerBlockTitle" placeholder="מה אתה מתכנן לעשות?"
          dir="auto" />
      </div>

      <div class="planner-add-row">
        <div class="planner-add-field">
          <label class="planner-add-label">שעת התחלה</label>
          <input type="time" class="planner-add-input" id="plannerBlockStart" style="direction: ltr;" />
        </div>
        <div class="planner-add-field">
          <label class="planner-add-label">שעת סיום</label>
          <input type="time" class="planner-add-input" id="plannerBlockEnd" style="direction: ltr;" />
        </div>
      </div>

      <div class="planner-add-field">
        <label class="planner-add-label">משך זמן מהיר</label>
        <div class="planner-add-duration-presets">
          <button class="planner-duration-btn" data-duration="15">15 דק׳</button>
          <button class="planner-duration-btn" data-duration="30">30 דק׳</button>
          <button class="planner-duration-btn active" data-duration="60">שעה</button>
          <button class="planner-duration-btn" data-duration="90">1.5 שעות</button>
          <button class="planner-duration-btn" data-duration="120">שעתיים</button>
          <button class="planner-duration-btn" data-duration="180">3 שעות</button>
        </div>
      </div>

      <div class="planner-add-field">
        <label class="planner-add-label">צבע (אופציונלי)</label>
        <div class="planner-color-picker" id="plannerColorPicker">
          <div class="planner-color-option selected" style="background: transparent; border: 2px dashed var(--border);"
            data-color="">✕</div>
          <div class="planner-color-option" style="background: #667eea;" data-color="#667eea"></div>
          <div class="planner-color-option" style="background: #ef4444;" data-color="#ef4444"></div>
          <div class="planner-color-option" style="background: #f97316;" data-color="#f97316"></div>
          <div class="planner-color-option" style="background: #eab308;" data-color="#eab308"></div>
          <div class="planner-color-option" style="background: #22c55e;" data-color="#22c55e"></div>
          <div class="planner-color-option" style="background: #06b6d4;" data-color="#06b6d4"></div>
          <div class="planner-color-option" style="background: #8b5cf6;" data-color="#8b5cf6"></div>
          <div class="planner-color-option" style="background: #ec4899;" data-color="#ec4899"></div>
          <div class="planner-color-option" style="background: #14b8a6;" data-color="#14b8a6"></div>
          <div class="planner-color-option" style="background: #84cc16;" data-color="#84cc16"></div>
          <div class="planner-color-option" style="background: #0ea5e9;" data-color="#0ea5e9"></div>
        </div>
      </div>

      <div class="planner-add-field">
        <label class="planner-add-label">עדיפות</label>
        <div class="planner-add-priority" id="plannerPriorityPicker">
          <button class="planner-priority-option" data-priority="urgent">🔴 דחוף</button>
          <button class="planner-priority-option" data-priority="high">🟠 גבוהה</button>
          <button class="planner-priority-option selected" data-priority="medium">🟡 בינונית</button>
          <button class="planner-priority-option" data-priority="low">🟢 נמוכה</button>
          <button class="planner-priority-option" data-priority="none">⚪ ללא</button>
        </div>
      </div>

      <div class="planner-add-field">
        <label class="planner-add-label">קטגוריה (אופציונלי)</label>
        <select class="planner-add-input" id="plannerBlockCategory">
          <option value="">ללא קטגוריה</option>
          <option value="work">💼 עבודה</option>
          <option value="study">📚 לימודים</option>
          <option value="health">🏃 בריאות</option>
          <option value="personal">🏠 אישי</option>
          <option value="social">👥 חברתי</option>
          <option value="creative">🎨 יצירתי</option>
          <option value="rest">🧘 מנוחה</option>
        </select>
      </div>

      <div class="planner-add-field">
        <label class="planner-add-label">הערות (אופציונלי)</label>
        <textarea class="planner-add-input" id="plannerBlockNotes" rows="2" placeholder="הוסף פרטים נוספים..."
          dir="auto"></textarea>
      </div>

      <div class="planner-add-field">
        <label class="planner-add-label">תזכורת</label>
        <select class="planner-add-input" id="plannerBlockReminder">
          <option value="0">ללא תזכורת</option>
          <option value="5">5 דקות לפני</option>
          <option value="10">10 דקות לפני</option>
          <option value="15">15 דקות לפני</option>
          <option value="30">30 דקות לפני</option>
          <option value="60">שעה לפני</option>
        </select>
      </div>

      <div class="planner-add-field">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
          <input type="checkbox" id="plannerBlockRepeat" />
          <span style="font-size: 13px; color: var(--text);">🔄 חזור כל יום</span>
        </label>
      </div>

      <div class="planner-add-actions">
        <button class="planner-add-cancel" id="plannerCancelBtn">ביטול</button>
        <button class="planner-add-delete" id="plannerDeleteBtn" style="display: none;">🗑️</button>
        <button class="planner-add-save" id="plannerSaveBtn">💾 שמור</button>
      </div>
    </div>
  </div>

  <!-- Subject Modal -->
  <div class="subject-modal" id="subjectModal">
    <div class="subject-modal-card">
      <h3 id="subjectModalTitle">הוסף נושא חדש</h3>
      <input type="text" id="subjectNameInput" placeholder="שם הנושא (לדוגמה: מתמטיקה, עבודה, אישי)" dir="auto" />

      <div class="task-edit-section-title" style="margin: 16px 0 10px 0;">נושא אב (אופציונלי)</div>
      <select id="parentSubjectSelect"
        style="width: 100%; padding: 12px 14px; border: 2px solid var(--border); border-radius: 10px; font-size: 14px; background: var(--input-bg); color: var(--text); outline: none; cursor: pointer; margin-bottom: 16px;">
        <option value="">ללא (נושא ראשי)</option>
      </select>

      <div class="task-edit-section-title" style="margin-bottom: 10px;">צבע</div>
      <div class="subject-color-picker" id="subjectColorPicker">
        <div class="subject-color-option selected" style="background: #667eea;" data-color="#667eea"></div>
        <div class="subject-color-option" style="background: #ef4444;" data-color="#ef4444"></div>
        <div class="subject-color-option" style="background: #f97316;" data-color="#f97316"></div>
        <div class="subject-color-option" style="background: #eab308;" data-color="#eab308"></div>
        <div class="subject-color-option" style="background: #22c55e;" data-color="#22c55e"></div>
        <div class="subject-color-option" style="background: #06b6d4;" data-color="#06b6d4"></div>
        <div class="subject-color-option" style="background: #8b5cf6;" data-color="#8b5cf6"></div>
        <div class="subject-color-option" style="background: #ec4899;" data-color="#ec4899"></div>
        <div class="subject-color-option" style="background: #0ea5e9;" data-color="#0ea5e9"></div>
        <div class="subject-color-option" style="background: #14b8a6;" data-color="#14b8a6"></div>
        <div class="subject-color-option" style="background: #84cc16;" data-color="#84cc16"></div>
        <div class="subject-color-option" style="background: #f43f5e;" data-color="#f43f5e"></div>
      </div>

      <!-- Sharing Section -->
      <div class="task-edit-section-title" style="margin: 20px 0 10px 0;">שיתוף <span
          style="font-weight: normal; font-size: 12px; color: var(--muted);">(אופציונלי)</span></div>
      <div id="subjectSharingSection" style="background: var(--day-other); border-radius: 10px; padding: 12px;">
        <div id="sharedWithList" style="margin-bottom: 10px;"></div>
        <div style="display: flex; gap: 8px;">
          <input type="text" id="shareWithUserInput" placeholder="הזן שם משתמש לשיתוף" dir="auto"
            style="flex: 1; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; font-size: 13px; background: var(--input-bg); color: var(--text);" />
          <button type="button" id="addShareUserBtn" class="btn btn-primary"
            style="padding: 8px 16px; font-size: 13px;">הוסף</button>
        </div>
        <div id="shareError" style="color: #ef4444; font-size: 12px; margin-top: 6px; display: none;"></div>
      </div>

      <div class="subject-modal-actions">
        <button class="btn" id="cancelSubjectBtn"
          style="background: var(--day-other); color: var(--muted);">ביטול</button>
        <button class="btn btn-danger" id="deleteSubjectBtn" style="display: none;">מחק</button>
        <button class="btn btn-primary" id="saveSubjectBtn">שמור</button>
      </div>
    </div>
  </div>

  <!-- Context Menu for Subjects -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" data-action="edit">✏️ עריכה</div>
    <div class="context-menu-item" data-action="share">🔗 שתף</div>
    <div class="context-menu-item" data-action="add-sub">➕ הוסף תת-נושא</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" data-action="delete">🗑️ מחק</div>
  </div>

  <!-- Context Menu for Countdown Events -->
  <div class="context-menu" id="eventContextMenu">
    <div class="context-menu-item" data-action="pin">📌 נעץ למעלה</div>
    <div class="context-menu-item" data-action="star">⭐ סמן כמועדף</div>
    <div class="context-menu-item" data-action="edit">✏️ עריכה</div>
    <div class="context-menu-item" data-action="duplicate">📋 שכפל</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" data-action="delete">🗑️ מחק</div>
  </div>

  <!-- Context Menu for Adding New Event -->
  <div class="context-menu" id="addEventContextMenu">
    <div class="context-menu-item" data-action="add">➕ הוסף אירוע חדש</div>
    <div class="context-menu-item" data-action="add-tomorrow">📅 אירוע למחר</div>
    <div class="context-menu-item" data-action="add-week">📆 אירוע לשבוע הבא</div>
  </div>

  <!-- Daily Reminder Modal -->
  <div class="reminder-modal" id="reminderModal">
    <div class="reminder-card">
      <h2>☀️ בוקר טוב!</h2>
      <div class="reminder-date" id="reminderDate"></div>

      <div class="reminder-section" id="todayTasksSection">
        <h3>📅 משימות להיום</h3>
        <div id="todayTasksList"></div>
      </div>

      <div class="reminder-section" id="tomorrowTasksSection">
        <h3>📆 משימות למחר</h3>
        <div id="tomorrowTasksList"></div>
      </div>

      <div class="reminder-actions">
        <button class="btn btn-primary" id="closeReminderBtn" style="width: 100%;">הבנתי, תודה! 👍</button>
      </div>
    </div>
  </div>

  <div class="reminder-modal" id="eventAlertModal" role="dialog" aria-modal="true" aria-labelledby="alertTitle">
    <div class="reminder-card" style="border-top: 5px solid var(--accent);">
      <div style="font-size: 40px; margin-bottom: 10px;">⏰</div>
      <h2 id="alertTitle">Reminder!</h2>
      <p id="alertMessage" style="font-size: 18px; margin: 10px 0; color: var(--text);">Event is starting soon</p>
      <div class="reminder-actions">
        <button class="btn btn-primary" id="closeAlertBtn" style="width: 100%;">Dismiss</button>
      </div>
    </div>
  </div>

  <!-- Calendar Sync Modal -->
  <div class="reminder-modal" id="calendarSyncModal" role="dialog" aria-modal="true"
    aria-labelledby="calendarSyncTitle">
    <div class="reminder-card" style="max-width: 500px; border-top: 5px solid var(--accent);">
      <div style="font-size: 40px; margin-bottom: 10px;">📅</div>
      <h2 id="calendarSyncTitle">סנכרון לוח שנה / Calendar Sync</h2>
      <p style="color: var(--muted); font-size: 14px; margin-bottom: 20px;">ייבוא אירועים מלוח השנה שלך (חד-כיווני)
      </p>

      <details class="calendar-sync-settings" id="googleSettingsDetails">
        <summary>⚙️ Google Settings (API Key + Client ID)</summary>
        <div class="settings-grid">
          <label>
            Google API Key
            <input id="googleApiKeyInput" type="password" inputmode="text" autocomplete="off" spellcheck="false"
              placeholder="AIza..." />
          </label>
          <label>
            OAuth Client ID
            <input id="googleClientIdInput" type="text" inputmode="text" autocomplete="off" spellcheck="false"
              placeholder="1234567890-xxxx.apps.googleusercontent.com" />
          </label>
          <div class="settings-actions">
            <button class="btn btn-primary" id="saveGoogleSettingsBtn" type="button" style="flex:1;">Save</button>
            <button class="btn" id="resetGoogleSettingsBtn" type="button"
              style="flex:1; background: var(--day-other); color: var(--muted);">Reset</button>
          </div>
        </div>
        <div class="settings-hint">
          Google Calendar sync requires serving this app via `http://localhost` or `https://` and adding that origin
          to
          your Google OAuth "Authorized JavaScript origins".
        </div>
      </details>

      <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px;">
        <button class="btn btn-primary" id="syncGoogleCalendar"
          style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px;">
          <span style="font-size: 20px;">📆</span>
          <span>Google Calendar</span>
        </button>

        <button class="btn btn-primary" id="syncAppleCalendar"
          style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px; background: linear-gradient(135deg, #667eea, #764ba2);">
          <span style="font-size: 20px;">🍎</span>
          <span>Apple Calendar (iCal)</span>
        </button>
      </div>

      <div id="calendarSyncStatus"
        style="padding: 12px; border-radius: 8px; background: var(--day-other); color: var(--muted); font-size: 13px; margin-bottom: 16px; display: none;">
      </div>

      <div id="calendarEventsList" style="max-height: 300px; overflow-y: auto; margin-bottom: 16px; display: none;">
        <div style="font-weight: 600; margin-bottom: 8px; color: var(--text);">אירועים שנמצאו / Events Found:</div>
        <div id="calendarEventsContent" style="display: flex; flex-direction: column; gap: 6px;"></div>
      </div>

      <div class="reminder-actions" style="display: flex; gap: 8px;">
        <button class="btn" id="closeCalendarSyncBtn"
          style="flex: 1; background: var(--day-other); color: var(--muted);">סגור / Close</button>
        <button class="btn btn-primary" id="importCalendarEventsBtn" style="flex: 1; display: none;">ייבא /
          Import</button>
      </div>
    </div>
  </div>

  <div class="app-layout">
    <div class="main-content">
      <div class="container">
        <header class="header">
          <h1>⏱️ Shared Event Countdowns</h1>
          <p>Events sync live across all devices</p>
        </header>

        <div class="input-panel" id="inputPanel">
          <div class="input-row">
            <input type="text" id="eventName" placeholder="Event name..." autocomplete="off" aria-label="Event name" />
            <input type="datetime-local" id="eventDate" aria-label="Event date and time" max="9999-12-31T23:59" />
            <select id="eventReminder" class="reminder-select" aria-label="Reminder time">
              <option value="0">🔕 No Reminder</option>
              <option value="5">5 minutes before</option>
              <option value="10">10 minutes before</option>
              <option value="60">1 hour before</option>
              <option value="1440">1 day before</option>
              <option value="2880">2 days before</option>
              <option value="4320">3 days before</option>
              <option value="10080">1 week before</option>
              <option value="custom">⚙️ Custom…</option>
            </select>
            <div class="reminder-custom hidden" id="reminderCustomWrap" aria-label="Custom reminder">
              <input type="number" id="eventReminderCustomValue" min="1" step="1" inputmode="numeric"
                placeholder="Custom" aria-label="Custom reminder value" />
              <select id="eventReminderCustomUnit" aria-label="Custom reminder unit">
                <option value="minutes">minutes</option>
                <option value="hours">hours</option>
                <option value="days">days</option>
                <option value="weeks">weeks</option>
              </select>
            </div>
            <button class="btn btn-primary" id="addBtn">Add Event</button>
            <button class="btn btn-cancel" id="cancelBtn">Cancel</button>
            <button class="btn btn-ghost" id="clearBtn">Clear All</button>
          </div>
          <div class="input-row-notes">
            <textarea id="eventNotes" placeholder="Notes (optional)..." aria-label="Event notes"></textarea>
          </div>
        </div>

        <div class="event-list loading" id="eventList" role="list">
          <div class="event-skeleton">
            <div class="event-skeleton-row"></div>
            <div class="event-skeleton-row"></div>
            <div class="event-skeleton-row"></div>
          </div>
        </div>

        <div class="empty-state" id="emptyState">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
              d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <p>No events yet. Add your first countdown above! 🎉</p>
        </div>
      </div>
    </div>

    <aside class="sidebar hidden" id="sidebar">
      <div class="calendar-container">
        <div class="calendar-header">
          <div class="calendar-nav">
            <button id="prevMonth" aria-label="חודש קודם">‹</button>
            <button id="todayBtn" aria-label="היום" title="היום">●</button>
            <button id="nextMonth" aria-label="חודש הבא">›</button>
          </div>
          <div class="calendar-view-toggle" id="eventCalendarViewToggle">
            <button data-view="month" class="active">חודש</button>
            <button data-view="week">שבוע</button>
            <button data-view="day">יום</button>
          </div>
          <div class="calendar-title" id="calendarTitle"></div>
        </div>
        <div class="calendar-grid" id="calendarGrid"></div>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title" id="monthEventsTitle">אירועי החודש</div>
        <div class="month-events" id="monthEvents">
          <div class="no-events-msg">אין אירועים החודש</div>
        </div>
      </div>
    </aside>
  </div>

  <!-- Mobile Floating Action Button -->
  <button class="mobile-fab" id="mobileFab" aria-label="הוספה מהירה" style="display: none;">+</button>

  <!-- Mobile Event Bottom Sheet -->
  <div class="mobile-event-sheet-backdrop" id="mobileEventSheetBackdrop"></div>
  <div class="mobile-event-sheet" id="mobileEventSheet" role="dialog" aria-modal="true"
    aria-labelledby="mobileSheetTitle">
    <div class="mobile-sheet-handle"></div>
    <div class="mobile-sheet-header">
      <h3 id="mobileSheetTitle">הוסף אירוע חדש ➕</h3>
      <button class="mobile-sheet-close" id="mobileSheetClose" aria-label="סגור">×</button>
    </div>
    <div class="mobile-sheet-content">
      <div class="sheet-form-group">
        <label class="sheet-form-label" for="mobileEventName">שם האירוע</label>
        <input type="text" id="mobileEventName" placeholder="למשל: מבחן מתמטיקה, יום הולדת..." autocomplete="off"
          dir="auto" />
      </div>

      <div class="sheet-form-group">
        <label class="sheet-form-label" for="mobileEventDate">תאריך ושעה</label>
        <input type="datetime-local" id="mobileEventDate" max="9999-12-31T23:59" style="direction: ltr;" />
      </div>

      <div class="sheet-form-group">
        <label class="sheet-form-label" for="mobileEventReminder">תזכורת</label>
        <select id="mobileEventReminder">
          <option value="0">🔕 ללא תזכורת</option>
          <option value="5">5 דקות לפני</option>
          <option value="10">10 דקות לפני</option>
          <option value="60">שעה לפני</option>
          <option value="1440">יום לפני</option>
          <option value="2880">יומיים לפני</option>
          <option value="10080">שבוע לפני</option>
        </select>
      </div>

      <div class="sheet-form-group">
        <label class="sheet-form-label" for="mobileEventNotes">הערות (אופציונלי)</label>
        <textarea id="mobileEventNotes" placeholder="פרטים נוספים..." dir="auto"></textarea>
      </div>

      <div class="mobile-sheet-actions">
        <button class="btn btn-secondary" id="mobileSheetCancel">ביטול</button>
        <button class="btn btn-primary" id="mobileSheetAdd">הוסף אירוע ✓</button>
      </div>
    </div>
  </div>

  <!-- Mobile Sidebar Backdrop -->
  <div class="mobile-sidebar-backdrop" id="mobileSidebarBackdrop"></div>


  <div class="modal-backdrop" id="clearModal" role="dialog" aria-modal="true" aria-labelledby="clearModalTitle"
    aria-describedby="clearModalDesc">
    <div class="modal-card">
      <h3 id="clearModalTitle">Clear all shared events?</h3>
      <p id="clearModalDesc">This removes every event for everyone. Do you want to continue?</p>
      <div class="modal-actions">
        <button class="btn btn-danger" id="confirmClearBtn">Yes, clear everything</button>
        <button class="btn btn-cancel" id="cancelClearModalBtn" style="display:inline-block;">Keep events</button>
      </div>
    </div>
  </div>

  <!-- AI Day Plan Preview Modal -->
  <div class="shortcuts-backdrop" id="shortcutsModal" role="dialog" aria-modal="true" aria-labelledby="shortcutsTitle">
    <div class="shortcuts-card">
      <div class="shortcuts-hero">
        <div>
          <div class="shortcuts-eyebrow">⌨️ קיצורי מקלדת</div>
          <div class="shortcuts-title" id="shortcutsTitle">Shortcut Command Center</div>
          <div class="shortcuts-subtitle">H לפתיחה/סגירה</div>
        </div>
        <button class="shortcuts-close" id="shortcutsClose" aria-label="Close shortcuts">×</button>
      </div>
      <div class="shortcuts-body">
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">יצירה מהירה</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">פוקוס על הוספה מהירה</div>
              <div class="shortcut-keys"><span class="keycap">N</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">פתח/סגור חלון קיצורים</div>
              <div class="shortcut-keys"><span class="keycap">H</span></div>
            </div>
          </div>
        </div>
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">ניווט ותצוגות</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">קפיצה ל״היום״</div>
              <div class="shortcut-keys"><span class="keycap">T</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">פתח פומודורו</div>
              <div class="shortcut-keys"><span class="keycap">P</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">הצג/הסתר לוח שנה</div>
              <div class="shortcut-keys"><span class="keycap">C</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">מעבר למשימות</div>
              <div class="shortcut-keys"><span class="keycap">M</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">חזרה לספירה לאחור</div>
              <div class="shortcut-keys"><span class="keycap">G</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">חיפוש משימות</div>
              <div class="shortcut-keys"><span class="keycap">/</span></div>
            </div>
          </div>
        </div>
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">מערכת</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">סגור מודאלים/חלונות</div>
              <div class="shortcut-keys"><span class="keycap wide">Esc</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">מצב כהה/בהיר</div>
              <div class="shortcut-keys"><span class="keycap">D</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">קליק ימני ברשימת אירועים</div>
              <div class="shortcut-keys"><span class="keycap wide">➕</span></div>
            </div>
          </div>
        </div>
        <div class="shortcut-note">טיפ: הקיצורים פועלים רק כשלא מקלידים בתוך שדה טקסט.</div>
      </div>
    </div>
  </div>

  <!-- Guide/Help Modal -->
  <div class="shortcuts-backdrop" id="guideModal" role="dialog" aria-modal="true" aria-labelledby="guideTitle">
    <div class="shortcuts-card" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
      <div class="shortcuts-hero">
        <div>
          <div class="shortcuts-eyebrow">❓ מדריך האפליקציה</div>
          <div class="shortcuts-title" id="guideTitle">Complete Guide & Shortcuts</div>
          <div class="shortcuts-subtitle">? לפתיחה/סגירה</div>
        </div>
        <button class="shortcuts-close" id="guideClose" aria-label="Close guide">×</button>
      </div>
      <div class="shortcuts-body">
        <!-- Keyboard Shortcuts Section -->
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">⌨️ קיצורי מקלדת - ניווט ותצוגות</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">פתח פלטת פקודות (חיפוש מהיר)</div>
              <div class="shortcut-keys"><span class="keycap">⌘</span><span class="keycap">K</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">קפיצה ל״היום״</div>
              <div class="shortcut-keys"><span class="keycap">T</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">פתח פומודורו</div>
              <div class="shortcut-keys"><span class="keycap">P</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">הצג/הסתר לוח שנה</div>
              <div class="shortcut-keys"><span class="keycap">C</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">מעבר למשימות</div>
              <div class="shortcut-keys"><span class="keycap">M</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">חזרה לספירה לאחור</div>
              <div class="shortcut-keys"><span class="keycap">G</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">חיפוש משימות</div>
              <div class="shortcut-keys"><span class="keycap">/</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">מצב כהה/בהיר</div>
              <div class="shortcut-keys"><span class="keycap">D</span></div>
            </div>
          </div>
        </div>

        <div class="shortcuts-section">
          <div class="shortcuts-section-title">⌨️ קיצורי מקלדת - יצירה ועריכה</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">פוקוס על הוספה מהירה</div>
              <div class="shortcut-keys"><span class="keycap">N</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">בטל פעולה אחרונה (Undo)</div>
              <div class="shortcut-keys"><span class="keycap">⌘</span><span class="keycap">Z</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">חזור על פעולה (Redo)</div>
              <div class="shortcut-keys"><span class="keycap">⌘</span><span class="keycap">⇧</span><span
                  class="keycap">Z</span></div>
            </div>
          </div>
        </div>

        <div class="shortcuts-section">
          <div class="shortcuts-section-title">⌨️ ניווט Vim-Style במשימות</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">ירידה למשימה הבאה</div>
              <div class="shortcut-keys"><span class="keycap">J</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">עלייה למשימה הקודמת</div>
              <div class="shortcut-keys"><span class="keycap">K</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">סמן משימה כהושלמה</div>
              <div class="shortcut-keys"><span class="keycap">X</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">ערוך משימה מסומנת</div>
              <div class="shortcut-keys"><span class="keycap wide">Enter</span></div>
            </div>
          </div>
        </div>

        <div class="shortcuts-section">
          <div class="shortcuts-section-title">⌨️ קיצורי מערכת</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">סגור מודאלים/חלונות</div>
              <div class="shortcut-keys"><span class="keycap wide">Esc</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">פתח מדריך זה</div>
              <div class="shortcut-keys"><span class="keycap">?</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">פתח/סגור חלון קיצורים (ישן)</div>
              <div class="shortcut-keys"><span class="keycap">H</span></div>
            </div>
          </div>
        </div>

        <!-- Right-Click Section -->
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">🖱️ קליק ימני (Context Menu)</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">על משימה: השלם, ערוך, שכפל, מחק, עדיפות, תאריך, תזכורת, נושא</div>
              <div class="shortcut-keys"><span class="keycap wide">→ משימה</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">על אירוע: ערוך, שכפל, מחק, מועדף, נעיצה</div>
              <div class="shortcut-keys"><span class="keycap wide">→ אירוע</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">על יום בלוח שנה: הוסף משימה/אירוע ליום</div>
              <div class="shortcut-keys"><span class="keycap wide">→ יום</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">על סרגל צד: נושא חדש, פילטרים מהירים</div>
              <div class="shortcut-keys"><span class="keycap wide">→ סרגל צד</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">על כותרת: ניווט, הגדרות, קיצורים</div>
              <div class="shortcut-keys"><span class="keycap wide">→ כותרת</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">על פומודורו: התחל, אפס, סגור</div>
              <div class="shortcut-keys"><span class="keycap wide">→ פומודורו</span></div>
            </div>
          </div>
        </div>

        <!-- Features Section -->
        <div class="shortcuts-section">
          <div class="shortcuts-section-title">✨ פיצ׳רים נוספים</div>
          <div class="shortcuts-grid">
            <div class="shortcut-item">
              <div class="shortcut-label">🎉 קונפטי בהשלמת משימה</div>
              <div class="shortcut-keys"><span class="keycap wide">אוטומטי</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">🔄 חזרות: יומי, שבועי, דו-שבועי, חודשי, שנתי, ימי חול</div>
              <div class="shortcut-keys"><span class="keycap wide">בעריכה</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">↩️ Undo/Redo עד 50 פעולות</div>
              <div class="shortcut-keys"><span class="keycap">⌘</span><span class="keycap">Z</span></div>
            </div>
            <div class="shortcut-item">
              <div class="shortcut-label">🔔 התראות Push (גם כשהאפליקציה סגורה)</div>
              <div class="shortcut-keys"><span class="keycap wide">לחץ 🔔</span></div>
            </div>
          </div>
        </div>

        <div class="shortcut-note">💡 קיצורי מקלדת פועלים רק כשלא מקלידים בתוך שדה טקסט</div>
      </div>
    </div>
  </div>

  <!-- Day Drawer -->
  <div class="day-drawer-backdrop" id="dayDrawer" role="dialog" aria-modal="true" aria-labelledby="dayDrawerTitle">
    <div class="day-drawer">
      <div class="day-drawer-header">
        <div>
          <div class="day-drawer-title" id="dayDrawerTitle"></div>
          <div class="day-drawer-subtitle" id="dayDrawerSubtitle"></div>
        </div>
        <button class="day-drawer-close" id="closeDayDrawer" aria-label="סגור">×</button>
      </div>
      <div class="day-drawer-content">
        <div class="day-drawer-section" id="dayDrawerEvents">
          <div class="day-drawer-section-title">
            📅 אירועים <span class="count" id="dayEventsCount">0</span>
          </div>
          <div id="dayEventsList"></div>
        </div>
        <div class="day-drawer-section" id="dayDrawerTasks">
          <div class="day-drawer-section-title">
            ✅ משימות <span class="count" id="dayTasksCount">0</span>
          </div>
          <div id="dayTasksList"></div>
        </div>
      </div>
      <div class="day-drawer-actions">
        <button class="btn btn-primary" id="addEventToDay">📅 הוסף אירוע</button>
        <button class="btn" id="addTaskToDay" style="background: var(--btn-secondary-bg); color: var(--text);">✅ הוסף
          משימה</button>
      </div>
    </div>
  </div>

  <div class="undo-toast" id="undoToast" role="status" aria-live="polite">
    <span id="undoToastMsg">Event deleted</span>
    <button id="undoToastUndo" aria-label="Undo delete">Undo</button>
  </div>

  <!-- Command Palette -->
  <div class="command-palette-backdrop" id="commandPalette" role="dialog" aria-modal="true"
    aria-label="Command Palette">
    <div class="command-palette">
      <div class="command-palette-input-wrap">
        <input type="text" class="command-palette-input" id="commandPaletteInput"
          placeholder="חפש פקודות, אירועים או משימות..." autocomplete="off" />
      </div>
      <div class="command-palette-results" id="commandPaletteResults">
        <!-- Results populated by JS -->
      </div>
    </div>
  </div>

  <!-- Pull to Refresh Indicator -->
  <div class="pull-to-refresh" id="pullToRefresh">
    <span class="pull-spinner">🔄</span>
  </div>

  <!-- Advanced Undo Stack Toast -->
  <div class="undo-stack-toast" id="undoStackToast" role="status" aria-live="polite">
    <span class="undo-stack-message" id="undoStackMessage">פעולה בוצעה</span>
    <div class="undo-stack-actions">
      <button class="undo-stack-btn undo" id="undoStackUndo">↩️ בטל (Cmd+Z)</button>
      <button class="undo-stack-btn dismiss" id="undoStackDismiss">סגור</button>
    </div>
  </div>

  <!-- Pomodoro Mini Player (Moved to root for visibility) -->
  <div class="pomodoro-mini" id="pomodoroMini">
    <div>
      <div class="pomodoro-mini-time" id="pomodoroMiniTime">25:00</div>
      <div class="pomodoro-mini-mode" id="pomodoroMiniMode">מיקוד</div>
    </div>
    <button class="pomodoro-mini-close" id="pomodoroMiniClose" aria-label="סגור">×</button>
  </div>

  <script type="module">
    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                    SHARED EVENT COUNTDOWNS - MAIN CONTROLLER             ║
    // ╠══════════════════════════════════════════════════════════════════════════╣
    // ║  This inline script acts as the main controller, coordinating the        ║
    // ║  modular components in the js/ directory.                                ║
    // ║                                                                          ║
    // ║  TABLE OF CONTENTS:                                                      ║
    // ║  ─────────────────                                                       ║
    // ║  1. FIREBASE INITIALIZATION                          (Line ~30)          ║
    // ║  2. USER AUTHENTICATION                              (Line ~60)          ║
    // ║  3. GLOBAL CONSTANTS & DOM REFERENCES                (Line ~100)         ║
    // ║  4. EVENT/COUNTDOWN MANAGEMENT                       (Line ~200)         ║
    // ║  5. CONFETTI & ANIMATIONS                            (Line ~2500)        ║
    // ║  6. UNDO/REDO STACK                                  (Line ~3300)        ║
    // ║  7. KEYBOARD NAVIGATION                              (Line ~3400)        ║
    // ║  8. CONTEXT MENUS                                    (Line ~3430)        ║
    // ║  9. TASK MANAGER                                     (Line ~3850)        ║
    // ║  10. POMODORO INTEGRATION                            (Line ~4230)        ║
    // ║  11. SUBJECTS/CATEGORIES                             (Line ~5800)        ║
    // ║  12. TASK CALENDAR                                   (Line ~6000)        ║
    // ║  13. NATURAL LANGUAGE PARSING                        (Line ~7370)        ║
    // ║  14. DAILY PLANNER                                   (Line ~7890)        ║
    // ║  15. INITIALIZATION                                  (Line ~9500+)       ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // ============ 1. FIREBASE INITIALIZATION ============
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, set, onValue, push, remove, onChildAdded, onChildChanged, onChildRemoved, goOnline, goOffline } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    import { ctx } from "./js/context.js";
    import { initEvents } from "./js/events.js";
    import { initTasks } from "./js/tasks.js";
    import { initCalendar } from "./js/calendar.js";
    import { createPomodoro } from "./js/pomodoro.js";
    import { initUi } from "./js/ui.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB_IflOD8CwVLQQjqtz_ZKWzbfgCiOm2Js",
      authDomain: "countdown-463de.firebaseapp.com",
      databaseURL: "https://countdown-463de-default-rtdb.firebaseio.com",
      projectId: "countdown-463de",
      storageBucket: "countdown-463de.firebasestorage.app",
      messagingSenderId: "1016385864732",
      appId: "1:1016385864732:web:8a82e771e1f4be567a8bd9"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const eventsRef = ref(db, 'events');
    Object.assign(ctx, {
      db,
      ref,
      set,
      onValue,
      push,
      remove,
      onChildAdded,
      onChildChanged,
      onChildRemoved,
      goOnline,
      goOffline,
      eventsRef
    });

    // ============ 2. USER AUTHENTICATION ============
    const userBtn = document.getElementById('userBtn');
    let currentUser = localStorage.getItem('countdown_username');

    // Function to sanitize username (remove special chars)
    const cleanUsername = (name) => {
      return (name || '').trim().toLowerCase().replace(/[^a-z0-9_-]/g, '');
    };

    // Login Process
    if (!currentUser) {
      const input = prompt("👋 Welcome! \nEnter a username to access your private tasks:\n(e.g., 'john123', 'sarah_work')");
      currentUser = cleanUsername(input);

      if (!currentUser) {
        currentUser = 'guest_' + Math.floor(Math.random() * 1000);
        alert("No name entered. You are logged in as: " + currentUser);
      }
      localStorage.setItem('countdown_username', currentUser);
    }

    // Update UI
    if (userBtn) userBtn.textContent = `👤 ${currentUser}`;

    // 3. PRIVATE REFERENCES (Scoped to the user)
    const tasksRef = ref(db, `users/${currentUser}/tasks`);
    const subjectsRef = ref(db, `users/${currentUser}/subjects`);
    Object.assign(ctx, { currentUser, tasksRef, subjectsRef });

    // 4. LOGOUT / SWITCH USER FUNCTION
    if (userBtn) {
      userBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // Use timeout to prevent instant dismissal issues
        setTimeout(() => {
          const switchUser = confirm(`You are logged in as "${currentUser}".\n\nDo you want to switch users?`);
          if (switchUser) {
            localStorage.removeItem('countdown_username');
            location.reload(); // Reload page to reset references
          }
        }, 50);
      };
    }

    // ============ 3. GLOBAL CONSTANTS & DOM REFERENCES ============
    const COLORS = ['#667eea', '#f59e0b', '#10b981', '#ec4899', '#8b5cf6', '#06b6d4', '#ef4444', '#84cc16'];
    const HEBREW_DAYS = ['א׳', 'ב׳', 'ג׳', 'ד׳', 'ה׳', 'ו׳', 'ש׳'];
    const HEBREW_MONTHS = ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'];

    const escapeHtml = (str) => String(str || '').replace(/[&<>"']/g, (c) => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    })[c]);
    Object.assign(ctx, { COLORS, HEBREW_DAYS, HEBREW_MONTHS, escapeHtml });

    const $ = id => document.getElementById(id);
    const eventList = $("eventList");
    const emptyState = $("emptyState");
    const eventName = $("eventName");
    const eventDate = $("eventDate");
    const eventReminder = $("eventReminder");
    const reminderCustomWrap = $("reminderCustomWrap");
    const eventReminderCustomValue = $("eventReminderCustomValue");
    const eventReminderCustomUnit = $("eventReminderCustomUnit");
    const eventAlertModal = $("eventAlertModal");
    const closeAlertBtn = $("closeAlertBtn");
    const alertTitle = $("alertTitle");
    const alertMessage = $("alertMessage");
    const inputPanel = $("inputPanel");
    const addBtn = $("addBtn");
    const cancelBtn = $("cancelBtn");
    const clearBtn = $("clearBtn");
    const sidebar = $("sidebar");
    const calendarGrid = $("calendarGrid");
    const calendarTitle = $("calendarTitle");
    const monthEventsEl = $("monthEvents");
    const monthEventsTitle = $("monthEventsTitle");
    const clearModal = $("clearModal");
    const confirmClearBtn = $("confirmClearBtn");
    const cancelClearModalBtn = $("cancelClearModalBtn");
    ctx.clearModal = clearModal;
    const themeToggle = $("themeToggle");
    const notifyBtn = $("notifyBtn");
    const togglePomodoro = $("togglePomodoro");
    const pomodoroOverlay = $("pomodoroOverlay");



    const eventNotes = $("eventNotes");
    const undoToast = $("undoToast");
    const undoToastMsg = $("undoToastMsg");
    const shortcutsModal = $("shortcutsModal");
    const shortcutsClose = $("shortcutsClose");
    const helpShortcuts = $("helpShortcuts");
    const dayDrawer = $("dayDrawer");
    Object.assign(ctx, {
      eventList,
      emptyState,
      eventName,
      eventDate,
      eventNotes,
      inputPanel,
      themeToggle,
      notifyBtn,
      pomodoroOverlay,
      eventAlertModal,
      alertTitle,
      alertMessage,
      undoToast,
      undoToastMsg,
      shortcutsModal,
      shortcutsClose,
      helpShortcuts,
      dayDrawer
    });
    let shortcutsLastFocus = null;

    const undoToastUndo = $("undoToastUndo");
    const pomodoroCard = $("pomodoroCard");
    const pomodoroTaskSelect = $("pomodoroTaskSelect");
    const pomodoroPresetsEls = Array.from(document.querySelectorAll('.pomodoro-preset'));
    const pomodoroFocusInput = $("pomodoroFocus");
    const pomodoroBreakInput = $("pomodoroBreak");
    const pomodoroLongInput = $("pomodoroLong");
    const pomodoroLongEveryInput = $("pomodoroLongEvery");
    const pomodoroAutoContinueEl = $("pomodoroAutoContinue");
    const pomodoroSoundEl = $("pomodoroSound");
    const pomodoroDisplay = $("pomodoroDisplay");
    const pomodoroMode = $("pomodoroMode");
    const pomodoroNext = $("pomodoroNext");
    const pomodoroProgress = $("pomodoroProgress");
    const pomodoroStart = $("pomodoroStart");
    const pomodoroSkip = $("pomodoroSkip");
    const pomodoroReset = $("pomodoroReset");
    const pomodoroSessionCount = $("pomodoroSessionCount");
    const pomodoroFocusMinutes = $("pomodoroFocusMinutes");
    const pomodoroStreak = $("pomodoroStreak");
    const pomodoroDayProgress = $("pomodoroDayProgress");
    const pomodoroDayLabel = $("pomodoroDayLabel");

    const STORAGE_KEYS = {
      THEME: 'countdown-theme',
      SIDEBAR_WIDTH: 'countdown-sidebar-width',
      GOOGLE_API_KEY: 'countdown-google-api-key',
      GOOGLE_CLIENT_ID: 'countdown-google-client-id'
    };
    const CACHE_KEYS = {
      EVENTS: 'countdown-events-cache-v1',
      TASKS_PREFIX: 'countdown-tasks-cache-v1:',
      SUBJECTS_PREFIX: 'countdown-subjects-cache-v1:'
    };
    Object.assign(ctx, { STORAGE_KEYS, CACHE_KEYS });

    let editingId = null;
    Object.defineProperty(ctx, 'editingId', { get: () => editingId, set: (val) => { editingId = val; } });
    let events = [];
    let eventsLoaded = false;
    let hasEventsCache = false;
    const eventsById = new Map();
    const refs = new Map();
    let tickerHandle = null;
    Object.defineProperties(ctx, {
      events: { get: () => events, set: (val) => { events = val; } },
      eventsLoaded: { get: () => eventsLoaded, set: (val) => { eventsLoaded = val; } },
      hasEventsCache: { get: () => hasEventsCache, set: (val) => { hasEventsCache = val; } },
      eventsById: { value: eventsById }
    });
    function getEventById(id) { return eventsById.get(id); }
    function upsertLocalEvent(id, data) {
      const existing = eventsById.get(id);
      if (existing) Object.assign(existing, data);
      else {
        const evt = { id, ...data };
        events.push(evt);
        eventsById.set(id, evt);
      }
    }
    ctx.upsertLocalEvent = upsertLocalEvent;
    let currentMonth = new Date();
    let eventCalendarView = 'month'; // 'month', 'week', 'day'
    let eventCalendarFocusDate = new Date();
    Object.defineProperties(ctx, {
      currentMonth: { get: () => currentMonth, set: (val) => { currentMonth = val; } },
      eventCalendarView: { get: () => eventCalendarView, set: (val) => { eventCalendarView = val; } },
      eventCalendarFocusDate: { get: () => eventCalendarFocusDate, set: (val) => { eventCalendarFocusDate = val; } }
    });
    const pendingDeletes = new Map();
    let lastDeletedId = null;
    const DELETE_TIMEOUT_MS = 10000;
    const taskNotifyScope = currentUser ? `:${currentUser}` : '';
    const NOTIFY_KEYS = {
      EVENTS: 'countdown-notified-events-v1',
      TASKS: `countdown-notified-tasks-v1${taskNotifyScope}`,
      EVENTS_LAST_CHECK: 'countdown-last-event-check-v1',
      TASKS_LAST_CHECK: `countdown-last-task-check-v1${taskNotifyScope}`
    };
    const NOTIFY_TTL_MS = 1000 * 60 * 60 * 24 * 7;
    const REMINDER_CATCHUP_MAX_MS = 1000 * 60 * 60 * 12;
    const REMINDER_CATCHUP_MAX_COUNT = 6; // Limit burst after long inactivity.
    const NOTIFY_CHECK_PERSIST_MS = 30000;

    function loadNotifiedMap(storageKey) {
      const map = new Map();
      const now = Date.now();
      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return map;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return map;
        Object.entries(parsed).forEach(([id, entry]) => {
          if (typeof entry === 'string') {
            map.set(id, { key: entry, ts: now });
            return;
          }
          if (!entry || typeof entry !== 'object') return;
          const key = entry.key;
          const ts = Number(entry.ts) || 0;
          if (!key || !ts) return;
          if (now - ts > NOTIFY_TTL_MS) return;
          map.set(id, { key, ts });
        });
      } catch (e) { }
      return map;
    }

    function persistNotifiedMap(storageKey, map) {
      try {
        const payload = {};
        map.forEach((entry, id) => {
          if (!entry || !entry.key) return;
          payload[id] = { key: entry.key, ts: entry.ts || Date.now() };
        });
        localStorage.setItem(storageKey, JSON.stringify(payload));
      } catch (e) { }
    }

    function pruneNotifiedMap(storageKey, map, validIds) {
      const now = Date.now();
      let changed = false;
      map.forEach((entry, id) => {
        const ts = Number(entry?.ts) || 0;
        if (!entry?.key || !ts || now - ts > NOTIFY_TTL_MS || (validIds && !validIds.has(id))) {
          map.delete(id);
          changed = true;
        }
      });
      if (changed) persistNotifiedMap(storageKey, map);
    }

    function loadLastCheck(storageKey) {
      const raw = Number(localStorage.getItem(storageKey));
      return Number.isFinite(raw) && raw > 0 ? raw : 0;
    }

    function getReminderWindow(lastCheck, nowMs) {
      let start = Number.isFinite(lastCheck) && lastCheck > 0 ? lastCheck : nowMs;
      if (start > nowMs) start = nowMs;
      const minStart = nowMs - REMINDER_CATCHUP_MAX_MS;
      const isCatchup = start < minStart;
      if (isCatchup) start = minStart;
      return { start, isCatchup };
    }

    function persistLastCheck(state, nowMs, force = false) {
      if (!force && nowMs - state.lastPersisted < NOTIFY_CHECK_PERSIST_MS) return;
      state.lastPersisted = nowMs;
      try { localStorage.setItem(state.key, String(nowMs)); } catch (e) { }
    }

    const notifiedEvents = loadNotifiedMap(NOTIFY_KEYS.EVENTS);
    const notifiedTasks = loadNotifiedMap(NOTIFY_KEYS.TASKS);
    const reminderCheckState = {
      events: { key: NOTIFY_KEYS.EVENTS_LAST_CHECK, lastCheck: loadLastCheck(NOTIFY_KEYS.EVENTS_LAST_CHECK), lastPersisted: 0 },
      tasks: { key: NOTIFY_KEYS.TASKS_LAST_CHECK, lastCheck: loadLastCheck(NOTIFY_KEYS.TASKS_LAST_CHECK), lastPersisted: 0 }
    };
    let pendingEventAlert = null;
    const reminderAudio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-software-interface-start-2574.mp3');
    reminderAudio.preload = 'auto';
    reminderAudio.volume = 0.6;

    const getActiveEvents = () => events.filter(evt => !pendingDeletes.has(evt.id));
    ctx.getActiveEvents = getActiveEvents;
    const pruneNotifiedEvents = () => {
      const ids = new Set(getActiveEvents().map(evt => evt.id));
      pruneNotifiedMap(NOTIFY_KEYS.EVENTS, notifiedEvents, ids);
    };

    const readCache = (key) => {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.items)) return null;
        return parsed.items;
      } catch (e) {
        return null;
      }
    };

    const writeCache = (key, items, limit) => {
      try {
        const payload = { ts: Date.now(), items: items.slice(0, limit) };
        localStorage.setItem(key, JSON.stringify(payload));
      } catch (e) { }
    };
    Object.assign(ctx, { readCache, writeCache });

    // Web Push (works when closed) requires: HTTPS + Service Worker + a backend sender (VAPID private key).
    // 1) Generate VAPID keys on your backend, then paste the PUBLIC key here.
    const PUSH_VAPID_PUBLIC_KEY = "BL-m24SrurFUNIQxH7S77r1yYShIiCibpw2CbtK8FwYATHzYiR0kQGKzWilEGRHyRK2jxqRPUR_RJoAVUgrO-24";
    const PUSH_LOCAL_USER_KEY = 'countdown_push_subscription_user';

    const isPushSupported = () => (
      window.isSecureContext &&
      'serviceWorker' in navigator &&
      'PushManager' in window
    );

    const urlBase64ToUint8Array = (base64String) => {
      const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
      return outputArray;
    };

    async function getPushRegistration() {
      if (!('serviceWorker' in navigator)) return null;
      return await navigator.serviceWorker.getRegistration();
    }

    async function ensurePushRegistration() {
      if (!('serviceWorker' in navigator)) return null;
      const existing = await getPushRegistration();
      if (existing) return existing;
      return await navigator.serviceWorker.register('./service-worker.js', { scope: './' });
    }

    const NOTIFICATION_ICON = './icon-192.png';
    const NOTIFICATION_BADGE = './icon-192.png';

    const isIOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isStandalone = () =>
      (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
      (typeof navigator.standalone === 'boolean' && navigator.standalone);

    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    async function showSystemNotification(title, options = {}) {
      if (!("Notification" in window)) return false;
      if (Notification.permission !== 'granted') return false;

      const merged = {
        icon: NOTIFICATION_ICON,
        badge: NOTIFICATION_BADGE,
        vibrate: [200, 100, 200],
        requireInteraction: true,
        silent: false,
        ...options
      };
      merged.data = { url: window.location.href, ...(options.data || {}) };

      // Prefer Service Worker notifications (more reliable on mobile), but never hang waiting for `ready`.
      if (window.isSecureContext && 'serviceWorker' in navigator) {
        try {
          const reg = await getPushRegistration();
          if (reg && typeof reg.showNotification === 'function') {
            await reg.showNotification(title, merged);
            return true;
          }
        } catch (e) { }

        try {
          const reg = await Promise.race([ensurePushRegistration(), delay(1500).then(() => null)]);
          if (reg && typeof reg.showNotification === 'function') {
            await reg.showNotification(title, merged);
            return true;
          }
        } catch (e) {
          console.warn('[Notification] Service Worker registration failed:', e);
        }
      }

      // Fallback: direct Notification API (works in many browsers while the app is open).
      try {
        new Notification(title, merged);
        return true;
      } catch (e) {
        console.warn('[Notification] new Notification failed:', e);
        return false;
      }
    }

    async function sha256Base64Url(input) {
      const data = new TextEncoder().encode(String(input || ''));
      const digest = await crypto.subtle.digest('SHA-256', data);
      const bytes = Array.from(new Uint8Array(digest));
      const b64 = btoa(String.fromCharCode(...bytes));
      return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
    }

    async function savePushSubscriptionForUser(userId, subscription) {
      if (!userId) return;
      if (!subscription) return;
      const key = await sha256Base64Url(subscription.endpoint);
      const payload = {
        sub: subscription.toJSON(),
        ua: navigator.userAgent,
        createdAt: Date.now()
      };
      await set(ref(db, `users/${userId}/pushSubscriptions/${key}`), payload);
    }

    async function removePushSubscriptionForUser(userId, subscription) {
      if (!userId) return;
      if (!subscription) return;
      const key = await sha256Base64Url(subscription.endpoint);
      await remove(ref(db, `users/${userId}/pushSubscriptions/${key}`));
    }

    async function syncExistingSubscriptionToCurrentUser() {
      if (!isPushSupported()) return;
      if (!PUSH_VAPID_PUBLIC_KEY) return;
      try {
        const reg = await getPushRegistration();
        if (!reg) return;
        let sub = await reg.pushManager.getSubscription();

        // If no subscription but permission granted, auto-resubscribe (handles expired subs)
        if (!sub && (Notification.permission === 'granted')) {
          try {
            const appServerKey = urlBase64ToUint8Array(PUSH_VAPID_PUBLIC_KEY);
            sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: appServerKey });
            console.log('[Push] Auto-resubscribed');
          } catch (e) {
            console.warn('[Push] Auto-resubscribe failed:', e);
            return;
          }
        }

        if (!sub) return;
        const prevUser = localStorage.getItem(PUSH_LOCAL_USER_KEY);
        if (prevUser && prevUser !== currentUser) {
          await removePushSubscriptionForUser(prevUser, sub).catch(() => { });
        }
        // Only update localStorage if Firebase save succeeds (prevents state mismatch)
        await savePushSubscriptionForUser(currentUser, sub);
        localStorage.setItem(PUSH_LOCAL_USER_KEY, currentUser);
      } catch (e) {
        console.warn('[Push] Sync failed:', e);
      }

    }

    async function refreshNotifyButton() {
      if (!notifyBtn) return;
      if (!("Notification" in window)) {
        notifyBtn.textContent = "🔕";
        notifyBtn.title = "Notifications are not supported in this browser";
        notifyBtn.disabled = true;
        notifyBtn.setAttribute('aria-disabled', 'true');
        notifyBtn.classList.remove('notify-enabled');
        return;
      }
      if (!window.isSecureContext) {
        notifyBtn.textContent = "🔒";
        notifyBtn.title = "Notifications require HTTPS (or localhost)";
        notifyBtn.disabled = true;
        notifyBtn.setAttribute('aria-disabled', 'true');
        notifyBtn.classList.remove('notify-enabled');
        return;
      }
      if (isIOS() && !isStandalone()) {
        notifyBtn.textContent = "📲";
        notifyBtn.title = "On iPhone/iPad: install this app (Add to Home Screen) to enable notifications";
        notifyBtn.disabled = false;
        notifyBtn.removeAttribute('aria-disabled');
        notifyBtn.setAttribute('aria-pressed', 'false');
        notifyBtn.classList.remove('notify-enabled');
        return;
      }
      notifyBtn.disabled = false;
      notifyBtn.removeAttribute('aria-disabled');

      const perm = Notification.permission;
      if (perm === 'denied') {
        notifyBtn.textContent = "🔕";
        notifyBtn.title = "Notifications blocked (enable in browser settings)";
        notifyBtn.classList.remove('notify-enabled');
        return;
      }

      if (isPushSupported()) {
        try {
          const reg = await getPushRegistration();
          const sub = reg ? await reg.pushManager.getSubscription() : null;
          if (sub && perm === 'granted') {
            // PUSH ENABLED - show distinct active state
            notifyBtn.textContent = "🔔";
            notifyBtn.title = `✅ Push enabled for "${currentUser}" (works when closed) - click to disable`;
            notifyBtn.setAttribute('aria-pressed', 'true');
            notifyBtn.classList.add('notify-enabled');
            return;
          }
        } catch { }
        // Push supported but not subscribed
        notifyBtn.textContent = "🔕";
        notifyBtn.title = perm === 'granted'
          ? "Click to enable push (works when closed)"
          : "Click to enable notifications";
        notifyBtn.setAttribute('aria-pressed', 'false');
        notifyBtn.classList.remove('notify-enabled');
        return;
      }

      // No push support - basic notifications
      if (perm === 'granted') {
        notifyBtn.textContent = "🔔";
        notifyBtn.title = "Notifications enabled (only while app is open)";
        notifyBtn.setAttribute('aria-pressed', 'true');
        notifyBtn.classList.add('notify-enabled');
      } else {
        notifyBtn.textContent = "🔕";
        notifyBtn.title = "Click to enable notifications";
        notifyBtn.setAttribute('aria-pressed', 'false');
        notifyBtn.classList.remove('notify-enabled');
      }
    }

    async function toggleNotificationsFromUser() {
      if (!("Notification" in window)) {
        alert("Notifications aren't supported in this browser.");
        return;
      }
      if (!window.isSecureContext) {
        alert("Notifications require HTTPS (GitHub Pages is OK) or localhost.");
        return;
      }
      if (isIOS() && !isStandalone()) {
        alert("On iPhone/iPad, notifications require installing the PWA:\nShare → Add to Home Screen → open the app from the home screen, then enable notifications.");
        return;
      }
      if (Notification.permission === 'denied') {
        alert("Notifications are blocked for this site. Enable them in browser/OS settings and reload.");
        return;
      }

      const perm = Notification.permission === 'granted'
        ? 'granted'
        : await Notification.requestPermission();

      if (perm !== 'granted') {
        await refreshNotifyButton();
        return;
      }

      if (!isPushSupported()) {
        showSystemNotification("Notifications enabled ✅", { body: "You’ll get reminders while this app is open.", requireInteraction: false }).catch(() => { });
        await refreshNotifyButton();
        return;
      }

      if (!PUSH_VAPID_PUBLIC_KEY) {
        alert("To enable push while closed, set PUSH_VAPID_PUBLIC_KEY in the code and run a push-sender backend.");
        await refreshNotifyButton();
        return;
      }

      const reg = await ensurePushRegistration();
      const existing = await reg.pushManager.getSubscription();
      if (existing) {
        const ok = confirm(`Push is enabled for "${currentUser}".\n\nDisable it on this device?`);
        if (!ok) return;
        await removePushSubscriptionForUser(currentUser, existing).catch(() => { });
        await existing.unsubscribe().catch(() => { });
        localStorage.removeItem(PUSH_LOCAL_USER_KEY);
        await refreshNotifyButton();
        return;
      }

      const appServerKey = urlBase64ToUint8Array(PUSH_VAPID_PUBLIC_KEY);
      let sub = null;
      try {
        sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: appServerKey });
        await savePushSubscriptionForUser(currentUser, sub);
        localStorage.setItem(PUSH_LOCAL_USER_KEY, currentUser);
        showSystemNotification("Push enabled ✅", { body: `Push is enabled for "${currentUser}".`, requireInteraction: false }).catch(() => { });
      } catch (e) {
        console.warn('[Push] subscribe/save failed:', e);
        try { if (sub) await sub.unsubscribe(); } catch { }
        alert("Failed to enable push notifications. Check connection and try again.");
      }
      await refreshNotifyButton();
    }

    if (notifyBtn) notifyBtn.addEventListener('click', toggleNotificationsFromUser);
    (async () => {
      if (window.isSecureContext && 'serviceWorker' in navigator) {
        try { await ensurePushRegistration(); } catch (e) { console.warn('[SW] register failed:', e); }
      }
      await syncExistingSubscriptionToCurrentUser();
      await refreshNotifyButton();

      // Register periodic background sync for Android push reliability
      if ('serviceWorker' in navigator && 'periodicSync' in (await navigator.serviceWorker.ready)) {
        try {
          const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
          if (status.state === 'granted') {
            const reg = await navigator.serviceWorker.ready;
            await reg.periodicSync.register('push-keepalive', { minInterval: 12 * 60 * 60 * 1000 });
            console.log('[Push] Periodic sync registered for background reliability');
          }
        } catch (e) {
          console.log('[Push] Periodic sync not available:', e.message);
        }
      }
    })();

    // Test notification function - can be called from browser console
    window.testNotification = async function () {
      if (!("Notification" in window)) {
        console.error('Notifications not supported');
        return 'Notifications not supported';
      }
      if (Notification.permission !== 'granted') {
        console.error('Notification permission not granted:', Notification.permission);
        return 'Permission: ' + Notification.permission;
      }
      const ok = await showSystemNotification("Test Notification 🔔", {
        body: "If you see this, notifications are working!",
        tag: 'test-notification',
        requireInteraction: true,
        renotify: true
      });
      if (ok) {
        console.log('Test notification sent');
        return 'Success - check your notifications!';
      }
      return 'Error: could not send notification (check browser support + permissions)';
    };
    console.log('[App] To test notifications, run: testNotification()');

    const setEventsLoading = (isLoading) => {
      if (!eventList) return;
      eventList.classList.toggle('loading', isLoading);
    };
    ctx.setEventsLoading = setEventsLoading;

    const syncBadge = $("syncBadge");
    const syncState = { events: false, tasks: false, subjects: false };
    const syncCacheUsed = { events: false, tasks: false, subjects: false };
    const SYNC_TIMEOUT_MS = 15000;
    const SUBJECTS_NO_CACHE_TIMEOUT_MS = 8000;
    const syncTimeouts = { events: null, tasks: null, subjects: null, subjectsNoCache: null };
    Object.assign(ctx, {
      syncState,
      syncCacheUsed,
      SYNC_TIMEOUT_MS,
      SUBJECTS_NO_CACHE_TIMEOUT_MS
    });
    const clearSyncTimeouts = (key) => {
      const keys = key === 'subjects' ? ['subjects', 'subjectsNoCache'] : [key];
      keys.forEach((timeoutKey) => {
        if (syncTimeouts[timeoutKey]) {
          clearTimeout(syncTimeouts[timeoutKey]);
          syncTimeouts[timeoutKey] = null;
        }
      });
    };
    const startSyncTimeout = (key, ms, reason, onTimeout) => {
      const timeoutKey = (key === 'subjects' && reason === 'no-cache') ? 'subjectsNoCache' : key;
      syncTimeouts[timeoutKey] = setTimeout(() => {
        syncTimeouts[timeoutKey] = null;
        if (syncState[key]) return;
        console.debug(`[sync] ${key} timeout after ${ms}ms (${reason}) - continuing with cache`);
        if (typeof onTimeout === 'function') onTimeout();
        markSyncReady(key, `timeout:${reason}`);
      }, ms);
    };
    const updateSyncBadge = () => {
      if (!syncBadge) return;
      const hasCache = Object.values(syncCacheUsed).some(Boolean);
      const ready = syncState.events && syncState.tasks && syncState.subjects;
      const total = Object.keys(syncState).length;
      const readyCount = Object.values(syncState).filter(Boolean).length;
      const percent = Math.floor((readyCount / total) * 100);
      const syncText = syncBadge.querySelector('.sync-text');
      if (syncText) syncText.textContent = ready ? 'Synced' : `Syncing ${percent}%`;
      syncBadge.classList.toggle('hidden', !hasCache || ready);
    };
    const markSyncReady = (key, source = 'unknown') => {
      if (syncState[key]) {
        console.debug(`[sync] ${key} already ready (${source})`);
        return;
      }
      syncState[key] = true;
      const total = Object.keys(syncState).length;
      const readyCount = Object.values(syncState).filter(Boolean).length;
      console.debug(`[sync] ${key} ready (${source}) ${readyCount}/${total}`);
      updateSyncBadge();
    };
    Object.assign(ctx, { clearSyncTimeouts, startSyncTimeout, updateSyncBadge, markSyncReady });

    const showUndoToast = (name, id) => {
      undoToastMsg.textContent = `${name} deleted`;
      lastDeletedId = id;
      undoToast.classList.add('show');
    };

    const hideUndoToast = () => {
      lastDeletedId = null;
      undoToast.classList.remove('show');
    };

    const closeEventAlert = () => {
      if (eventAlertModal) eventAlertModal.classList.remove('open');
    };
    ctx.closeEventAlert = closeEventAlert;

    const getReminderMinutesFromUI = () => {
      if (!eventReminder) return 0;
      const raw = eventReminder.value;
      if (raw !== 'custom') return parseInt(raw, 10) || 0;

      const value = parseInt(eventReminderCustomValue?.value, 10);
      const unit = eventReminderCustomUnit?.value || 'minutes';
      if (!Number.isFinite(value) || value <= 0) return null;

      const multipliers = { minutes: 1, hours: 60, days: 1440, weeks: 10080 };
      const mult = multipliers[unit] || 1;
      const minutes = value * mult;
      if (!Number.isFinite(minutes) || minutes <= 0) return null;
      return minutes;
    };

    const setReminderUIFromMinutes = (minutes) => {
      if (!eventReminder) return;
      const min = parseInt(minutes, 10) || 0;
      const optionExists = Array.from(eventReminder.options).some(o => o.value === String(min));

      if (min > 0 && !optionExists) {
        eventReminder.value = 'custom';
        if (reminderCustomWrap) reminderCustomWrap.classList.remove('hidden');

        let unit = 'minutes';
        let value = min;
        if (min % 10080 === 0) {
          unit = 'weeks';
          value = Math.round(min / 10080);
        } else if (min % 1440 === 0) {
          unit = 'days';
          value = Math.round(min / 1440);
        } else if (min % 60 === 0) {
          unit = 'hours';
          value = Math.round(min / 60);
        }
        if (eventReminderCustomUnit) eventReminderCustomUnit.value = unit;
        if (eventReminderCustomValue) eventReminderCustomValue.value = String(value);
        return;
      }

      eventReminder.value = String(min);
      if (reminderCustomWrap) reminderCustomWrap.classList.add('hidden');
      if (eventReminderCustomValue) eventReminderCustomValue.value = '';
      if (eventReminderCustomUnit) eventReminderCustomUnit.value = 'minutes';
    };

    if (eventReminder) {
      eventReminder.addEventListener('change', () => {
        const isCustom = eventReminder.value === 'custom';
        if (reminderCustomWrap) reminderCustomWrap.classList.toggle('hidden', !isCustom);
        if (isCustom) {
          if (eventReminderCustomUnit && !eventReminderCustomUnit.value) eventReminderCustomUnit.value = 'minutes';
          if (eventReminderCustomValue && !eventReminderCustomValue.value) eventReminderCustomValue.value = '10';
          if (eventReminderCustomValue) eventReminderCustomValue.focus();
        } else {
          if (eventReminderCustomValue) eventReminderCustomValue.value = '';
          if (eventReminderCustomUnit) eventReminderCustomUnit.value = 'minutes';
        }
      });
    }

    if (closeAlertBtn) {
      closeAlertBtn.onclick = closeEventAlert;
    }
    if (eventAlertModal) {
      eventAlertModal.addEventListener('click', (e) => {
        if (e.target === eventAlertModal) closeEventAlert();
      });
    }

    const flushReminderChecks = () => {
      const now = Date.now();
      persistLastCheck(reminderCheckState.events, now, true);
      persistLastCheck(reminderCheckState.tasks, now, true);
    };

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        flushReminderChecks();
        return;
      }
      if (!document.hidden && pendingEventAlert) {
        showEventAlert(pendingEventAlert.title, pendingEventAlert.message, true);
        pendingEventAlert = null;
      }
      checkEventReminders(Date.now());
      checkTaskReminders();
      // Force Firebase reconnect when app becomes visible (fixes mobile sync issues)
      if (!document.hidden) {
        goOffline(db);
        setTimeout(() => goOnline(db), 100);
      }
    });
    window.addEventListener('beforeunload', flushReminderChecks);

    undoToastUndo.onclick = () => {
      if (!lastDeletedId) return;
      const pending = pendingDeletes.get(lastDeletedId);
      if (pending) {
        clearTimeout(pending.timer);
        pendingDeletes.delete(lastDeletedId);
        render();
      }
      hideUndoToast();
    };

    function getEventColor(id) {

      const charCode = id.charCodeAt(id.length - 1);

      return COLORS[charCode % COLORS.length];

    }
    ctx.getEventColor = getEventColor;



    $("toggleSidebar").onclick = () => {

      const wasHidden = sidebar.classList.contains("hidden");

      sidebar.classList.toggle("hidden");

      // Reset to current month when opening sidebar

      if (wasHidden) {

        currentMonth = new Date();

        renderCalendar();

      }

    };



    // Dark mode toggle

    const initTheme = () => {

      const saved = localStorage.getItem(STORAGE_KEYS.THEME);

      if (saved === 'dark' || (!saved && window.matchMedia('(prefers-color-scheme: dark)').matches)) {

        document.body.classList.add('dark');

        themeToggle.textContent = '☀️';

      }

    };

    initTheme();

    themeToggle.onclick = () => {
      document.body.classList.toggle('dark');
      const isDark = document.body.classList.contains('dark');
      themeToggle.textContent = isDark ? '☀️' : '🌙';
      localStorage.setItem(STORAGE_KEYS.THEME, isDark ? 'dark' : 'light');
    };

    const calendarApi = initCalendar();
    const { renderCalendar, scheduleCalendarRender, openDayDrawer, closeDayDrawer } = calendarApi;
    Object.assign(ctx, { renderCalendar, scheduleCalendarRender, openDayDrawer, closeDayDrawer });

    // ========================================

    // Persist sidebar width
    const savedWidth = localStorage.getItem(STORAGE_KEYS.SIDEBAR_WIDTH);
    if (savedWidth) sidebar.style.width = savedWidth;

    const resizeObserver = new ResizeObserver(() => {
      localStorage.setItem(STORAGE_KEYS.SIDEBAR_WIDTH, sidebar.style.width || sidebar.offsetWidth + 'px');
    });
    resizeObserver.observe(sidebar);

    function parseLocal(value) {
      const match = String(value || "").match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})$/);
      if (!match) return null;
      const [, Y, Mo, D, H, Mi] = match;
      return new Date(+Y, +Mo - 1, +D, +H, +Mi, 0, 0);
    }

    function toLocalDatetime(isoString) {
      const d = new Date(isoString);
      const pad = n => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    function toDateKey(date) {
      const d = new Date(date);
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    }
    Object.assign(ctx, { parseLocal, toLocalDatetime, toDateKey });

    const eventsApi = initEvents({
      onEventsUpdated: () => {
        pruneNotifiedEvents();
        render();
        scheduleCalendarRender();
        startTicker();
      },
      onEventsCacheLoaded: () => {
        pruneNotifiedEvents();
        render();
        scheduleCalendarRender();
        startTicker();
      }
    });
    const { saveToCloud, updateInCloud, deleteFromCloud, clearAllCloud } = eventsApi;
    Object.assign(ctx, { saveToCloud, updateInCloud, deleteFromCloud, clearAllCloud });

    function formatDate(iso) {
      const d = new Date(iso);
      const day = d.getDate();
      const month = d.toLocaleString('he-IL', { month: 'short' });
      const weekday = d.toLocaleString('he-IL', { weekday: 'short' });
      const time = d.toLocaleString('he-IL', { hour: '2-digit', minute: '2-digit' });
      return `${weekday}, ${day} ${month}, ${time}`;
    }

    function formatReminderOffset(minutes) {
      if (minutes >= 1440) {
        const days = Math.round(minutes / 1440);
        return days === 1 ? '1 day' : `${days} days`;
      }
      if (minutes >= 60) {
        const hours = Math.round(minutes / 60);
        return hours === 1 ? '1 hour' : `${hours} hours`;
      }
      return minutes === 1 ? '1 minute' : `${minutes} minutes`;
    }
    Object.assign(ctx, { formatDate, formatReminderOffset });

    function playReminderSound() {
      if (!reminderAudio) return;
      reminderAudio.currentTime = 0;
      reminderAudio.play().catch(() => {
        console.log("Audio play failed (interaction needed)");
      });
    }

    function showEventAlert(title, message, playSound = false) {
      if (!eventAlertModal) return;
      if (alertTitle) alertTitle.textContent = title;
      if (alertMessage) alertMessage.textContent = message;
      eventAlertModal.classList.add('open');
      if (playSound) playReminderSound();
    }

    async function triggerAlert(evt, nowMs = Date.now()) {
      const eventTime = new Date(evt.date).getTime();
      if (!Number.isFinite(eventTime)) return;
      const diffMinutes = Math.round((eventTime - nowMs) / 60000);
      let msg = '';
      let inAppMsg = '';
      if (diffMinutes > 0) {
        const timeString = formatReminderOffset(Math.max(1, diffMinutes));
        msg = `${evt.name} starts in ${timeString}!`;
        inAppMsg = `Starting in ${timeString}`;
      } else if (diffMinutes < 0) {
        const timeString = formatReminderOffset(Math.max(1, Math.abs(diffMinutes)));
        msg = `${evt.name} started ${timeString} ago`;
        inAppMsg = `Started ${timeString} ago`;
      } else {
        msg = `${evt.name} starts now!`;
        inAppMsg = 'Starting now';
      }

      showSystemNotification("Event Reminder ⏰", {
        body: msg,
        tag: `event-${evt.id || evt.name || 'reminder'}`,
        renotify: true
      }).catch(() => { });

      // Show in-app alert if visible, or queue for later
      if (document.hidden) {
        pendingEventAlert = { title: evt.name, message: inAppMsg };
      } else {
        showEventAlert(evt.name, inAppMsg, true);
      }
    }

    function calcTime(target) {
      const diff = Math.max(0, new Date(target).getTime() - Date.now());
      return {
        ended: diff === 0,
        d: Math.floor(diff / 86400000),
        h: Math.floor((diff % 86400000) / 3600000),
        m: Math.floor((diff % 3600000) / 60000),
        s: Math.floor((diff % 60000) / 1000)
      };
    }
    ctx.calcTime = calcTime;

    function startEdit(id) {
      const evt = events.find(e => e.id === id);
      if (!evt) return;

      // Detect mobile - input panel is hidden on mobile
      const isMobile = window.innerWidth <= 768 ||
        document.body.classList.contains('is-mobile') ||
        (window.matchMedia && window.matchMedia('(pointer: coarse)').matches && window.innerWidth <= 1024);

      if (isMobile) {
        // Inline mobile bottom sheet handling to avoid timing issues
        const mobileEventSheet = document.getElementById('mobileEventSheet');
        const mobileEventSheetBackdrop = document.getElementById('mobileEventSheetBackdrop');
        const mobileSheetTitle = document.getElementById('mobileSheetTitle');
        const mobileSheetAdd = document.getElementById('mobileSheetAdd');
        const mobileEventName = document.getElementById('mobileEventName');
        const mobileEventDate = document.getElementById('mobileEventDate');
        const mobileEventReminder = document.getElementById('mobileEventReminder');
        const mobileEventNotes = document.getElementById('mobileEventNotes');

        if (mobileEventSheet && mobileEventSheetBackdrop) {
          // Set edit id on the sheet for the save handler to use
          mobileEventSheet.dataset.editingId = id;

          // Populate form with event data
          if (mobileSheetTitle) mobileSheetTitle.textContent = 'עריכת אירוע ✏️';
          if (mobileSheetAdd) mobileSheetAdd.textContent = 'שמור שינויים ✓';
          if (mobileEventName) mobileEventName.value = evt.name || '';
          if (mobileEventDate) mobileEventDate.value = toLocalDatetime(evt.date) || '';
          if (mobileEventReminder) mobileEventReminder.value = String(evt.reminder || 0);
          if (mobileEventNotes) mobileEventNotes.value = evt.notes || '';

          // Open sheet
          mobileEventSheetBackdrop.classList.add('open');
          mobileEventSheet.classList.add('open');
          document.body.style.overflow = 'hidden';

          setTimeout(() => mobileEventName?.focus(), 350);
          return;
        }
      }

      // Desktop flow
      editingId = id;
      eventName.value = evt.name;
      eventDate.value = toLocalDatetime(evt.date);
      eventNotes.value = evt.notes || '';
      setReminderUIFromMinutes(evt.reminder || 0);
      addBtn.textContent = "Save";
      cancelBtn.style.display = "block";
      clearBtn.style.display = "none";
      inputPanel.classList.add("editing");
      eventName.focus();
    }

    function cancelEdit() {
      editingId = null;
      eventName.value = "";
      eventDate.value = "";
      eventNotes.value = "";
      setReminderUIFromMinutes(0);
      addBtn.textContent = "Add Event";
      cancelBtn.style.display = "none";
      clearBtn.style.display = "block";
      inputPanel.classList.remove("editing");
    }
    ctx.cancelEdit = cancelEdit;

    function setEventReminder(id, minutes) {
      const evt = events.find(e => e.id === id);
      if (!evt) return;

      const eventRef = ref(db, `events/${id}`);
      set(eventRef, { ...evt, reminder: minutes || null });
    }

    // Close reminder dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.event-reminder-wrap')) {
        document.querySelectorAll('.event-reminder-dropdown.open').forEach(d => d.classList.remove('open'));
      }
    });

    function render() {
      refs.clear();
      const frag = document.createDocumentFragment();
      // Use getActiveEvents() to account for pending deletes
      emptyState.style.display = getActiveEvents().length ? "none" : "block";

      const now = Date.now();

      const sorted = [...events].filter(e => !pendingDeletes.has(e.id)).sort((a, b) => {
        // First sort by pinned status
        if (a.pinned && !b.pinned) return -1;
        if (!a.pinned && b.pinned) return 1;

        // Then by time
        const aTime = new Date(a.date).getTime();
        const bTime = new Date(b.date).getTime();
        const aEnded = aTime <= now;
        const bEnded = bTime <= now;

        if (!aEnded && bEnded) return -1;
        if (aEnded && !bEnded) return 1;
        return aTime - bTime;
      });

      const conflicts = findConflictingEvents(sorted);

      sorted.forEach((evt) => {
        const color = getEventColor(evt.id);
        const t = calcTime(evt.date);
        const hasConflict = conflicts.has(evt.id);

        const row = document.createElement("div");
        row.className = `event-row ${evt.highlighted ? 'highlighted' : ''}`;
        row.dataset.id = evt.id;
        // Set event color for mobile accent bar
        row.style.setProperty('--event-color', color);
        row.style.setProperty('--event-color-soft', `${color}1a`);

        const dot = document.createElement("span");
        dot.className = "color-dot";
        dot.style.background = color;

        const info = document.createElement("div");
        info.className = "event-info";

        const name = document.createElement("div");
        name.className = "event-name";
        name.textContent = evt.name;

        const date = document.createElement("div");
        date.className = "event-date";
        date.dataset.iso = evt.date;
        date.textContent = formatDate(evt.date);

        info.appendChild(name);
        info.appendChild(date);

        if (hasConflict) {
          const conflict = document.createElement("div");
          conflict.className = "conflict-badge";
          conflict.innerHTML = `<span class="conflict-dot"></span><span>חפיפה עם אירוע קרוב</span>`;
          info.appendChild(conflict);
        }

        if (evt.notes) {
          const notes = document.createElement("div");
          notes.className = "event-notes";
          notes.textContent = evt.notes;
          info.appendChild(notes);
          if (evt.notes.length > 60 || evt.notes.includes('\n')) {
            const toggle = document.createElement("span");
            toggle.className = "notes-toggle";
            toggle.textContent = "הצג עוד";
            toggle.onclick = (e) => {
              e.stopPropagation();
              notes.classList.toggle('expanded');
              toggle.textContent = notes.classList.contains('expanded') ? "הסתר" : "הצג עוד";
            };
            info.appendChild(toggle);
          }
        }

        const timer = document.createElement("div");
        timer.className = "timer";

        const units = [
          { key: 's', label: 'Sec' },
          { key: 'm', label: 'Min' },
          { key: 'h', label: 'Hrs' },
          { key: 'd', label: 'Days' }
        ];

        units.forEach(({ key, label }) => {
          const unit = document.createElement("div");
          unit.className = "time-unit";

          const val = document.createElement("span");
          val.className = `time-val time-${key}`;
          val.style.color = color;
          val.textContent = key === 'd' ? t[key] : String(t[key]).padStart(2, '0');

          const lbl = document.createElement("div");
          lbl.className = "time-label";
          lbl.textContent = label;

          unit.appendChild(val);
          unit.appendChild(lbl);
          timer.appendChild(unit);
        });

        const badge = document.createElement("span");
        badge.className = `badge ${t.ended ? 'badge-ended' : 'badge-upcoming'}`;
        badge.textContent = t.ended ? 'Ended' : 'Upcoming';

        const starBtn = document.createElement("button");
        starBtn.className = `star-btn ${evt.highlighted ? 'active' : ''}`;
        starBtn.setAttribute("aria-label", "Highlight event");
        starBtn.textContent = "☆";

        const pinBtn = document.createElement("button");
        pinBtn.className = `pin-btn ${evt.pinned ? 'pinned' : ''}`;
        pinBtn.setAttribute("aria-label", evt.pinned ? "Unpin event" : "Pin event");
        pinBtn.title = evt.pinned ? "Unpin" : "Pin to top";
        pinBtn.textContent = "📌";

        const editBtn = document.createElement("button");
        editBtn.className = "edit-btn";
        editBtn.setAttribute("aria-label", "Edit event");
        editBtn.title = "Edit";
        editBtn.textContent = "✎";

        // Reminder button with dropdown
        const reminderWrap = document.createElement("div");
        reminderWrap.className = "event-reminder-wrap";

        const reminderBtn = document.createElement("button");
        reminderBtn.className = `reminder-btn ${evt.reminder ? 'has-reminder' : ''}`;
        reminderBtn.setAttribute("aria-label", "Set reminder");
        reminderBtn.title = evt.reminder ? `תזכורת ${evt.reminder} דקות לפני` : "הגדר תזכורת";
        reminderBtn.textContent = "🔔";

        const reminderDropdown = document.createElement("div");
        reminderDropdown.className = "event-reminder-dropdown";
        const reminderOptions = [
          { label: 'דקה אחת', value: 1 },
          { label: '5 דקות', value: 5 },
          { label: '15 דקות', value: 15 },
          { label: 'שעה', value: 60 },
          { label: 'יום', value: 1440 },
          { label: 'הסר תזכורת', value: 0, remove: true }
        ];
        reminderOptions.forEach(opt => {
          if (opt.remove && !evt.reminder) return; // Only show remove if there's a reminder
          const optEl = document.createElement("div");
          optEl.className = `event-reminder-option ${opt.remove ? 'remove' : ''} ${evt.reminder === opt.value ? 'active' : ''}`;
          optEl.textContent = opt.label;
          optEl.onclick = (e) => {
            e.stopPropagation();
            setEventReminder(evt.id, opt.value);
            reminderDropdown.classList.remove('open');
          };
          reminderDropdown.appendChild(optEl);
        });

        reminderBtn.onclick = (e) => {
          e.stopPropagation();
          // Close other dropdowns
          document.querySelectorAll('.event-reminder-dropdown.open').forEach(d => {
            if (d !== reminderDropdown) d.classList.remove('open');
          });
          reminderDropdown.classList.toggle('open');
        };

        reminderWrap.appendChild(reminderBtn);
        reminderWrap.appendChild(reminderDropdown);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-btn";
        deleteBtn.setAttribute("aria-label", "Delete event");
        deleteBtn.textContent = "×";

        const actions = document.createElement("div");
        actions.className = "event-actions";
        actions.appendChild(pinBtn);
        actions.appendChild(starBtn);
        actions.appendChild(reminderWrap);
        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);

        row.appendChild(dot);
        row.appendChild(timer);
        row.appendChild(badge);
        row.appendChild(info);
        row.appendChild(actions);

        enableInlineEventTitle(name, evt.id);
        enableInlineEventDate(date, evt.id);

        // Right-click context menu for events
        row.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showEventContextMenu(e.clientX, e.clientY, evt.id);
        });

        refs.set(evt.id, {
          row,
          dEl: row.querySelector(".time-d"),
          hEl: row.querySelector(".time-h"),
          mEl: row.querySelector(".time-m"),
          sEl: row.querySelector(".time-s"),
          badge: badge,
          target: new Date(evt.date).getTime()
        });

        frag.appendChild(row);
      });

      eventList.replaceChildren(frag);

      tick();
    }

    function findConflictingEvents(list, thresholdMinutes = 30) {
      if (!Array.isArray(list) || list.length < 2) return new Set();
      const thresholdMs = thresholdMinutes * 60000;
      // Assume `list` is already sorted by date (render() prepares a sorted list)
      const conflicts = new Set();
      for (let i = 0; i < list.length - 1; i++) {
        const current = list[i];
        const next = list[i + 1];
        const diff = Math.abs(new Date(next.date) - new Date(current.date));
        if (diff < thresholdMs) {
          conflicts.add(current.id);
          conflicts.add(next.id);
        }
      }
      return conflicts;
    }

    function inlineEdit(el, { type = 'text', value = '', className = 'inline-edit-input', step, onSave }) {
      el.style.cursor = 'text';
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        if (el.dataset.editing === '1') return;
        el.dataset.editing = '1';

        const input = document.createElement('input');
        input.type = type;
        input.value = value;
        input.className = className;
        if (step) input.step = step;

        const original = el.textContent;
        el.replaceWith(input);
        input.focus();
        input.select();

        let cancelled = false;
        const finish = (commit) => {
          if (input.parentElement) input.replaceWith(el);
          delete el.dataset.editing;
          if (commit && typeof onSave === 'function') onSave(input.value, original, el);
        };

        input.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') finish(true);
          else if (ev.key === 'Escape') {
            cancelled = true;
            finish(false);
          }
        });
        input.addEventListener('blur', () => finish(!cancelled));
      });
    }

    function enableInlineEventTitle(el, eventId) {
      inlineEdit(el, {
        value: el.textContent.trim(),
        onSave: (val, original) => {
          const newName = val.trim();
          const evt = events.find(e => e.id === eventId);
          if (!evt || !newName) {
            el.textContent = original;
            return;
          }
          el.textContent = newName;
          updateInCloud(eventId, { ...evt, name: newName });
        }
      });
    }

    function enableInlineEventDate(el, eventId) {
      inlineEdit(el, {
        type: 'datetime-local',
        value: toLocalDatetime(el.dataset.iso || events.find(e => e.id === eventId)?.date || new Date().toISOString()),
        className: 'inline-edit-input small',
        step: 60,
        onSave: (val, original) => {
          const parsed = parseLocal(val);
          const evt = events.find(e => e.id === eventId);
          if (!evt || !parsed || isNaN(parsed.getTime())) {
            el.textContent = original;
            return;
          }
          const iso = parsed.toISOString();
          el.textContent = formatDate(iso);
          el.dataset.iso = iso;
          updateInCloud(eventId, { ...evt, date: iso });
        }
      });
    }

    function checkEventReminders(nowMs = Date.now()) {
      const state = reminderCheckState.events;
      const { start, isCatchup } = getReminderWindow(state.lastCheck, nowMs);
      const candidates = [];

      getActiveEvents().forEach(evt => {
        const reminderMinutes = parseInt(evt.reminder, 10) || 0;
        if (!reminderMinutes) return;
        const reminderKey = `${evt.date || ''}|${reminderMinutes}`;
        const entry = notifiedEvents.get(evt.id);
        if (entry && entry.key === reminderKey) return;
        const eventTime = new Date(evt.date).getTime();
        if (!Number.isFinite(eventTime)) return;
        const triggerTime = eventTime - (reminderMinutes * 60000);
        if (triggerTime < start || triggerTime > nowMs) return;
        candidates.push({ evt, reminderKey, triggerTime });
      });

      if (candidates.length) {
        if (isCatchup && candidates.length > REMINDER_CATCHUP_MAX_COUNT) {
          candidates.sort((a, b) => b.triggerTime - a.triggerTime);
          candidates.length = REMINDER_CATCHUP_MAX_COUNT;
        } else {
          candidates.sort((a, b) => a.triggerTime - b.triggerTime);
        }
        candidates.forEach(item => {
          triggerAlert(item.evt, nowMs);
          notifiedEvents.set(item.evt.id, { key: item.reminderKey, ts: nowMs });
        });
        persistNotifiedMap(NOTIFY_KEYS.EVENTS, notifiedEvents);
      }

      state.lastCheck = nowMs;
      persistLastCheck(state, nowMs);
    }

    function tick() {
      const now = Date.now();

      refs.forEach((ref) => {
        const diff = Math.max(0, ref.target - now);
        const ended = diff === 0;

        const d = Math.floor(diff / 86400000);
        const h = Math.floor((diff % 86400000) / 3600000);
        const m = Math.floor((diff % 3600000) / 60000);
        const s = Math.floor((diff % 60000) / 1000);

        ref.dEl.textContent = d;
        ref.hEl.textContent = String(h).padStart(2, '0');
        ref.mEl.textContent = String(m).padStart(2, '0');
        ref.sEl.textContent = String(s).padStart(2, '0');

        ref.badge.className = `badge ${ended ? 'badge-ended' : 'badge-upcoming'}`;
        ref.badge.textContent = ended ? 'Ended' : 'Upcoming';
      });

      const nowMs = now;
      checkEventReminders(nowMs);
    }

    function startTicker() {
      if (tickerHandle) return; // already running
      const loop = () => {
        tick();
        const msToNext = 1000 - (Date.now() % 1000);
        tickerHandle = setTimeout(loop, msToNext);
      };
      loop();
    }

    addBtn.onclick = () => {
      const name = eventName.value.trim();
      const dateValue = eventDate.value;
      const notes = eventNotes.value.trim();
      const reminderVal = getReminderMinutesFromUI();

      if (!name || !dateValue) {
        alert("Please enter both event name and date");
        return;
      }
      if (reminderVal === null) {
        alert("Please enter a valid custom reminder (positive number).");
        return;
      }

      const parsedDate = parseLocal(dateValue);
      if (!parsedDate || isNaN(parsedDate.getTime())) {
        alert("Invalid date");
        return;
      }

      if (editingId) {
        const evt = events.find(e => e.id === editingId);
        updateInCloud(editingId, {
          name,
          date: parsedDate.toISOString(),
          notes: notes || null,
          reminder: reminderVal,
          highlighted: evt ? evt.highlighted : false,
          pinned: evt ? evt.pinned : false
        });
        cancelEdit();
      } else {
        saveToCloud({
          name,
          date: parsedDate.toISOString(),
          notes: notes || null,
          reminder: reminderVal,
          highlighted: false,
          pinned: false
        });
        eventName.value = "";
        eventDate.value = "";
        eventNotes.value = "";
        setReminderUIFromMinutes(0);
        eventName.focus();
      }
    };

    cancelBtn.onclick = cancelEdit;

    eventName.onkeypress = e => {
      if (e.key === 'Enter') addBtn.click();
    };

    eventDate.onkeypress = e => {
      if (e.key === 'Enter') addBtn.click();
    };

    // Auto-advance: when datetime-local value is complete, focus stays for time editing
    eventDate.addEventListener('input', () => {
      const val = eventDate.value;
      // datetime-local format: YYYY-MM-DDTHH:MM
      if (val && val.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/)) {
        // Value is complete - user can now adjust time or press Enter
        // No action needed, browser handles focus within datetime-local
      }
    });

    const openClearModal = () => {
      if (!events.length) return;
      clearModal.classList.add("open");
    };

    const closeClearModal = () => {
      clearModal.classList.remove("open");
    };
    ctx.closeClearModal = closeClearModal;

    clearBtn.onclick = openClearModal;
    cancelClearModalBtn.onclick = closeClearModal;
    confirmClearBtn.onclick = () => {
      clearAllCloud();
      closeClearModal();
    };

    clearModal.addEventListener("click", (e) => {
      if (e.target === clearModal) closeClearModal();
    });

    const uiApi = initUi();
    const {
      openShortcuts,
      closeShortcuts,
      toggleShortcuts,
      openGuide,
      closeGuide,
      toggleGuide,
      openCommandPalette,
      closeCommandPalette,
      toggleCommandPalette,
      focusQuickAdd,
      goToToday,
      openPomodoro,
      toggleCalendarSidebar,
      openTasksView,
      openCountdownView,
      focusTaskSearch,
      toggleTheme
    } = uiApi;
    Object.assign(ctx, {
      openShortcuts,
      closeShortcuts,
      toggleShortcuts,
      openGuide,
      closeGuide,
      toggleGuide,
      openCommandPalette,
      closeCommandPalette,
      toggleCommandPalette,
      focusQuickAdd,
      goToToday,
      openPomodoro,
      toggleCalendarSidebar,
      openTasksView,
      openCountdownView,
      focusTaskSearch,
      toggleTheme
    });

    const isEditableTarget = (el) => {
      if (!el) return false;
      const tag = el.tagName;
      return el.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    };

    // ============ CONFETTI ANIMATION ============
    const CONFETTI_COLORS = ['#667eea', '#22c55e', '#f59e0b', '#ec4899', '#8b5cf6', '#06b6d4'];

    function createConfetti(x, y) {
      const container = document.createElement('div');
      container.className = 'confetti-container';
      container.style.left = x + 'px';
      container.style.top = y + 'px';

      for (let i = 0; i < 20; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.background = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
        piece.style.left = (Math.random() * 60 - 30) + 'px';
        piece.style.animationDelay = (Math.random() * 0.3) + 's';
        piece.style.animationDuration = (0.8 + Math.random() * 0.6) + 's';
        container.appendChild(piece);
      }

      document.body.appendChild(container);
      setTimeout(() => container.remove(), 1500);
    }

    // ============ UNDO/REDO STACK ============
    const undoStack = [];
    const redoStack = [];
    const MAX_UNDO_STACK = 50;
    const undoStackToast = $("undoStackToast");
    const undoStackMessage = $("undoStackMessage");
    const undoStackUndoBtn = $("undoStackUndo");
    const undoStackDismissBtn = $("undoStackDismiss");
    let undoStackTimeout = null;

    function pushToUndoStack(action) {
      undoStack.push(action);
      if (undoStack.length > MAX_UNDO_STACK) undoStack.shift();
      redoStack.length = 0; // Clear redo stack on new action
      showUndoStackToast(action.message);
    }
    ctx.pushToUndoStack = pushToUndoStack;

    function showUndoStackToast(message) {
      if (!undoStackToast) return;
      undoStackMessage.textContent = message;
      undoStackToast.classList.add('show');
      if (undoStackTimeout) clearTimeout(undoStackTimeout);
      undoStackTimeout = setTimeout(() => undoStackToast.classList.remove('show'), 8000);
    }

    function hideUndoStackToast() {
      if (!undoStackToast) return;
      undoStackToast.classList.remove('show');
      if (undoStackTimeout) clearTimeout(undoStackTimeout);
    }

    function performUndo() {
      const action = undoStack.pop();
      if (!action) return;
      redoStack.push(action);

      if (action.type === 'deleteTask' && action.taskData) {
        const { id, ...data } = action.taskData;
        createTask(data);
      } else if (action.type === 'deleteEvent' && action.eventData) {
        saveToCloud(action.eventData);
      } else if (action.type === 'completeTask' && action.taskId) {
        const task = tasks.find(t => t.id === action.taskId);
        if (task) {
          const { id, ...clean } = task;
          saveTask(action.taskId, { ...clean, completed: !task.completed }, task.subject);
        }
      }
      hideUndoStackToast();
    }

    function performRedo() {
      const action = redoStack.pop();
      if (!action) return;
      undoStack.push(action);

      if (action.type === 'deleteTask' && action.taskId) {
        const task = tasks.find(t => t.id === action.taskId);
        if (task) removeTask(task);
      } else if (action.type === 'deleteEvent' && action.eventId) {
        deleteFromCloud(action.eventId);
      }
    }

    if (undoStackUndoBtn) undoStackUndoBtn.onclick = performUndo;
    if (undoStackDismissBtn) undoStackDismissBtn.onclick = hideUndoStackToast;

    // Cmd+Z for undo, Cmd+Shift+Z for redo
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z') {
        if (isEditableTarget(e.target)) return; // Don't interfere with text editing
        e.preventDefault();
        if (e.shiftKey) {
          performRedo();
        } else {
          performUndo();
        }
      }
    });

    // ============ VIM-STYLE NAVIGATION ============
    let vimFocusedTaskIndex = -1;

    function updateVimFocus() {
      document.querySelectorAll('.task-item.vim-focused').forEach(el => el.classList.remove('vim-focused'));
      const taskItems = Array.from(document.querySelectorAll('.task-item:not(.completed-task)'));
      if (vimFocusedTaskIndex >= 0 && vimFocusedTaskIndex < taskItems.length) {
        taskItems[vimFocusedTaskIndex].classList.add('vim-focused');
        taskItems[vimFocusedTaskIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    document.addEventListener('keydown', (e) => {
      if (isEditableTarget(e.target)) return;
      if (e.metaKey || e.ctrlKey || e.altKey) return;

      const taskItems = Array.from(document.querySelectorAll('.task-item:not(.completed-task)'));
      if (taskItems.length === 0) return;

      if (e.key === 'j') {
        e.preventDefault();
        vimFocusedTaskIndex = Math.min(vimFocusedTaskIndex + 1, taskItems.length - 1);
        if (vimFocusedTaskIndex < 0) vimFocusedTaskIndex = 0;
        updateVimFocus();
      } else if (e.key === 'k') {
        e.preventDefault();
        vimFocusedTaskIndex = Math.max(vimFocusedTaskIndex - 1, 0);
        updateVimFocus();
      } else if (e.key === 'Enter' && vimFocusedTaskIndex >= 0) {
        e.preventDefault();
        const taskEl = taskItems[vimFocusedTaskIndex];
        if (taskEl) {
          const taskId = taskEl.dataset.id;
          if (taskId && typeof openTaskEditModal === 'function') openTaskEditModal(taskId);
        }
      } else if (e.key === 'x' && vimFocusedTaskIndex >= 0) {
        e.preventDefault();
        const taskEl = taskItems[vimFocusedTaskIndex];
        if (taskEl) {
          const checkbox = taskEl.querySelector('.task-checkbox');
          if (checkbox) checkbox.click();
        }
      }
    });

    // ============ ENHANCED RIGHT-CLICK CONTEXT MENUS ============

    // Helper to create context menu
    function createContextMenu(x, y, items, className = '') {
      document.querySelectorAll('.dynamic-context-menu').forEach(m => m.remove());

      const menu = document.createElement('div');
      menu.className = `context-menu dynamic-context-menu ${className}`.trim();
      menu.classList.add('open');
      menu.style.cssText = `position: fixed; left: ${x}px; top: ${y}px; z-index: 15000;`;

      items.forEach(item => {
        if (item.divider) {
          const div = document.createElement('div');
          div.className = 'context-menu-divider';
          menu.appendChild(div);
          return;
        }
        if (item.header) {
          const h = document.createElement('div');
          h.className = 'context-menu-header';
          h.style.cssText = 'padding: 8px 16px; font-size: 11px; color: var(--muted); font-weight: 600;';
          h.textContent = item.header;
          menu.appendChild(h);
          return;
        }
        const el = document.createElement('div');
        el.className = 'context-menu-item';
        if (item.shortcut) {
          el.innerHTML = `<span class="context-menu-item-icon">${item.icon}</span><span style="flex:1">${item.label}</span><span class="context-menu-item-shortcut">${item.shortcut}</span>`;
        } else {
          el.innerHTML = `<span class="context-menu-item-icon">${item.icon}</span>${item.label}`;
        }
        el.onclick = () => { menu.remove(); item.action(); };
        menu.appendChild(el);
      });

      document.body.appendChild(menu);

      // Ensure menu stays within viewport
      const rect = menu.getBoundingClientRect();
      if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
      if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';

      setTimeout(() => {
        const closeHandler = (e) => {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeHandler);
            document.removeEventListener('contextmenu', closeHandler);
          }
        };
        document.addEventListener('click', closeHandler);
        document.addEventListener('contextmenu', closeHandler);
      }, 0);

      return menu;
    }

    // Task Context Menu
    function showTaskContextMenu(x, y, taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      const priorityItems = [
        { header: '⚡ עדיפות' },
        { icon: '🔴', label: 'דחוף', action: () => updateTaskPriority(taskId, 'urgent') },
        { icon: '🟠', label: 'גבוה', action: () => updateTaskPriority(taskId, 'high') },
        { icon: '🟡', label: 'בינוני', action: () => updateTaskPriority(taskId, 'medium') },
        { icon: '🟢', label: 'נמוך', action: () => updateTaskPriority(taskId, 'low') },
        { icon: '⬜', label: 'ללא', action: () => updateTaskPriority(taskId, 'none') },
      ];

      const subjectItems = subjects.length > 0 ? [
        { header: '📁 העבר לנושא' },
        { icon: '📂', label: 'ללא נושא', action: () => moveTaskToSubject(taskId, null) },
        ...subjects.slice(0, 5).map(s => ({
          icon: '📁', label: s.name, action: () => moveTaskToSubject(taskId, s.id)
        }))
      ] : [];

      const dateItems = [
        { header: '📅 תאריך יעד' },
        { icon: '📆', label: 'היום', action: () => setTaskDueDate(taskId, 0) },
        { icon: '📆', label: 'מחר', action: () => setTaskDueDate(taskId, 1) },
        { icon: '📆', label: 'בעוד שבוע', action: () => setTaskDueDate(taskId, 7) },
        { icon: '🚫', label: 'הסר תאריך', action: () => setTaskDueDate(taskId, null) },
      ];

      const reminderItems = [
        { header: '⏰ תזכורת' },
        { icon: '🔔', label: '10 דקות לפני', action: () => setTaskReminder(taskId, 10) },
        { icon: '🔔', label: '30 דקות לפני', action: () => setTaskReminder(taskId, 30) },
        { icon: '🔔', label: 'שעה לפני', action: () => setTaskReminder(taskId, 60) },
        { icon: '🔔', label: 'יום לפני', action: () => setTaskReminder(taskId, 1440) },
        { icon: '🔕', label: 'ללא תזכורת', action: () => setTaskReminder(taskId, 0) },
      ];

      const items = [
        { icon: task.completed ? '⬜' : '✅', label: task.completed ? 'סמן כלא הושלם' : 'סמן כהושלם', shortcut: 'X', action: () => toggleTaskComplete(taskId) },
        { icon: '✏️', label: 'עריכה', shortcut: 'Enter', action: () => openTaskEditModal(taskId) },
        { icon: '📋', label: 'שכפל', action: () => duplicateTask(taskId) },
        { icon: '🗑️', label: 'מחק', action: () => deleteTaskById(taskId) },
        { divider: true },
        ...priorityItems,
        { divider: true },
        ...dateItems,
        { divider: true },
        ...reminderItems,
        ...(subjectItems.length > 0 ? [{ divider: true }, ...subjectItems] : []),
      ];

      createContextMenu(x, y, items, 'task-context-menu');
    }

    function setTaskReminder(taskId, minutes) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      const { id, isOwn, isShared, ...clean } = task;
      saveTask(taskId, { ...clean, reminder: minutes || null }, task.subject);
    }

    function updateTaskPriority(taskId, priority) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      const { id, isOwn, isShared, ...clean } = task;
      saveTask(taskId, { ...clean, priority }, task.subject);
    }

    function moveTaskToSubject(taskId, subjectId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      const { id, isOwn, isShared, ...clean } = task;
      saveTask(taskId, { ...clean, subject: subjectId || '' }, subjectId || '');
    }

    function setTaskDueDate(taskId, daysFromNow) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      const { id, isOwn, isShared, ...clean } = task;
      if (daysFromNow === null) {
        saveTask(taskId, { ...clean, dueDate: null }, task.subject);
      } else {
        const date = new Date();
        date.setDate(date.getDate() + daysFromNow);
        date.setHours(23, 59, 59, 0);
        saveTask(taskId, { ...clean, dueDate: date.toISOString() }, task.subject);
      }
    }

    function toggleTaskComplete(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      const nextCompleted = !task.completed;
      if (nextCompleted) {
        // Trigger confetti for completing via context menu
        const taskEl = document.querySelector(`.task-item[data-id="${taskId}"]`);
        if (taskEl && typeof createConfetti === 'function') {
          const rect = taskEl.getBoundingClientRect();
          createConfetti(rect.left + 20, rect.top + rect.height / 2);
        }
        if (typeof maybeCreateRecurringTask === 'function') maybeCreateRecurringTask(task);
        if (typeof pushToUndoStack === 'function') {
          pushToUndoStack({ type: 'completeTask', taskId, message: `✅ "${task.title}" הושלם` });
        }
      }
      const { id, isOwn, isShared, ...clean } = task;
      saveTask(taskId, { ...clean, completed: nextCompleted }, task.subject);
    }

    function duplicateTask(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (task) pushTaskClone(task);
    }

    function deleteTaskById(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (task) removeTask(task);
    }

    // Calendar Day Context Menu
    function showCalendarDayContextMenu(x, y, dateStr) {
      const items = [
        { icon: '✅', label: 'הוסף משימה ליום זה', action: () => addTaskToDate(dateStr) },
        { icon: '📅', label: 'הוסף אירוע ליום זה', action: () => addEventToDate(dateStr) },
        { divider: true },
        { icon: '📋', label: 'הצג פרטי יום', action: () => openDayDrawerForDate(dateStr) },
      ];
      createContextMenu(x, y, items, 'calendar-day-context-menu');
    }

    function addTaskToDate(dateStr) {
      if (typeof showView === 'function') showView('tasks');
      setTimeout(() => {
        if (newTaskDueDate) {
          newTaskDueDate.value = dateStr + 'T23:59';
        }
        newTaskTitle?.focus();
      }, 100);
    }

    function addEventToDate(dateStr) {
      if (typeof showView === 'function') showView('countdown');
      setTimeout(() => {
        if (eventDate) {
          eventDate.value = dateStr + 'T12:00';
        }
        eventName?.focus();
      }, 100);
    }

    function openDayDrawerForDate(dateStr) {
      const date = new Date(dateStr);
      if (typeof openDayDrawer === 'function') openDayDrawer(date);
    }

    // Header/Logo Context Menu
    function showHeaderContextMenu(x, y) {
      const items = [
        { icon: '⌨️', label: 'קיצורי מקלדת', shortcut: 'H', action: openShortcuts },
        { icon: '❓', label: 'מדריך', shortcut: '?', action: openGuide },
        { divider: true },
        { icon: '🌙', label: 'מצב כהה/בהיר', shortcut: 'D', action: toggleTheme },
        { icon: '🔍', label: 'פלטת פקודות', shortcut: '⌘K', action: openCommandPalette },
        { divider: true },
        { icon: '📅', label: 'עבור להיום', shortcut: 'T', action: goToToday },
        { icon: '🍅', label: 'פתח פומודורו', shortcut: 'P', action: openPomodoro },
        { icon: '✅', label: 'פתח משימות', shortcut: 'M', action: () => showView('tasks') },
      ];
      createContextMenu(x, y, items, 'header-context-menu');
    }

    // Countdown View Context Menu (for empty areas in countdown view)
    function showCountdownContextMenu(x, y) {
      const items = [
        { icon: '📅', label: 'הוסף אירוע חדש', action: () => { eventName?.focus(); } },
        { icon: '📅', label: 'אירוע למחר', action: () => addEventToDate(getTomorrowDateStr()) },
        { icon: '📅', label: 'אירוע לשבוע הבא', action: () => addEventToDate(getNextWeekDateStr()) },
        { divider: true },
        { icon: '✅', label: 'פתח משימות', shortcut: 'M', action: () => showView('tasks') },
        { icon: '🍅', label: 'פתח פומודורו', shortcut: 'P', action: openPomodoro },
        { divider: true },
        { icon: '⌨️', label: 'קיצורי מקלדת', shortcut: 'H', action: openShortcuts },
        { icon: '❓', label: 'מדריך', shortcut: '?', action: openGuide },
      ];
      createContextMenu(x, y, items, 'countdown-context-menu');
    }

    // Sidebar Context Menu
    function showSidebarContextMenu(x, y) {
      const items = [
        { icon: '📁', label: 'נושא חדש', action: () => { if (typeof openSubjectModal === 'function') openSubjectModal(); } },
        { divider: true },
        { icon: '📋', label: 'הכל', action: () => { currentSmartView = null; currentSubject = null; if (typeof renderTasks === 'function') renderTasks(); } },
        { icon: '📅', label: 'היום', action: () => { currentSmartView = 'today'; currentSubject = null; if (typeof renderTasks === 'function') renderTasks(); } },
        { icon: '📆', label: 'מחר', action: () => { currentSmartView = 'tomorrow'; currentSubject = null; if (typeof renderTasks === 'function') renderTasks(); } },
        { icon: '📅', label: 'השבוע', action: () => { currentSmartView = 'week'; currentSubject = null; if (typeof renderTasks === 'function') renderTasks(); } },
        { divider: true },
        { icon: '✅', label: 'הושלמו', action: () => { currentSmartView = 'completed'; currentSubject = null; if (typeof renderTasks === 'function') renderTasks(); } },
      ];
      createContextMenu(x, y, items, 'sidebar-context-menu');
    }

    // Pomodoro Area Context Menu
    function showPomodoroContextMenu(x, y) {
      const items = [
        { icon: '▶️', label: 'התחל/המשך', action: () => { if (typeof togglePomodoro === 'function') togglePomodoro(); } },
        { icon: '🔄', label: 'אפס טיימר', action: () => { if (typeof resetPomodoro === 'function') resetPomodoro(); } },
        { divider: true },
        { icon: '✅', label: 'פתח משימות', action: () => showView('tasks') },
        { icon: '📅', label: 'פתח אירועים', action: () => showView('countdown') },
        { divider: true },
        { icon: '❌', label: 'סגור פומודורו', action: closePomodoro },
      ];
      createContextMenu(x, y, items, 'pomodoro-context-menu');
    }

    // Helper functions for dates
    function getTomorrowDateStr() {
      const d = new Date();
      d.setDate(d.getDate() + 1);
      return d.toISOString().split('T')[0];
    }

    function getNextWeekDateStr() {
      const d = new Date();
      d.setDate(d.getDate() + 7);
      return d.toISOString().split('T')[0];
    }

    // Attach context menus to various areas
    document.addEventListener('contextmenu', (e) => {
      // Allow native context menu if Shift is held
      if (e.shiftKey) return;

      // Task items - full task menu
      const taskItem = e.target.closest('.task-item');
      if (taskItem) {
        e.preventDefault();
        const taskId = taskItem.dataset.id;
        if (taskId) showTaskContextMenu(e.clientX, e.clientY, taskId);
        return;
      }

      // Calendar day context menu
      const calendarDay = e.target.closest('.calendar-day');
      if (calendarDay && calendarDay.dataset.date) {
        e.preventDefault();
        showCalendarDayContextMenu(e.clientX, e.clientY, calendarDay.dataset.date);
        return;
      }

      // Header/logo context menu
      const header = e.target.closest('.header, .app-title');
      if (header) {
        e.preventDefault();
        showHeaderContextMenu(e.clientX, e.clientY);
        return;
      }

      // Pomodoro overlay context menu
      const pomodoroOverlay = e.target.closest('#pomodoroOverlay');
      if (pomodoroOverlay && pomodoroOverlay.classList.contains('open')) {
        e.preventDefault();
        showPomodoroContextMenu(e.clientX, e.clientY);
        return;
      }

      // Sidebar context menu (subjects list area)
      const sidebar = e.target.closest('.subjects-sidebar, .task-sidebar');
      if (sidebar && !e.target.closest('.subject-list-header') && !e.target.closest('.subject-child-item')) {
        e.preventDefault();
        showSidebarContextMenu(e.clientX, e.clientY);
        return;
      }

      // Skip event-row (has own menu)
      if (e.target.closest('.event-row')) return;

      // Countdown view empty areas (not event-list which has its own menu)
      const inTaskView = $("taskManagerOverlay")?.classList.contains('open');
      if (!inTaskView) {
        const mainContent = e.target.closest('.main-content');
        // Don't block system context menu for interactive elements
        if (['INPUT', 'TEXTAREA', 'BUTTON', 'A', 'SELECT', 'LABEL'].includes(e.target.tagName)) return;

        if (mainContent && !e.target.closest('.event-list') && !e.target.closest('.empty-state')) {
          e.preventDefault();
          showCountdownContextMenu(e.clientX, e.clientY);
          return;
        }
      }

      // Task manager empty areas
      const taskContent = e.target.closest('.task-list-container, .task-content');
      if (taskContent && inTaskView) {
        e.preventDefault();
        showQuickAddContextMenu(e.clientX, e.clientY, true);
        return;
      }
    });

    function showQuickAddContextMenu(x, y, isTaskView) {
      const items = [
        { icon: '✅', label: 'משימה חדשה', shortcut: 'N', action: () => { if (typeof showView === 'function') showView('tasks'); setTimeout(() => newTaskTitle?.focus(), 100); } },
        { icon: '📅', label: 'אירוע חדש', shortcut: 'G', action: () => { if (typeof showView === 'function') showView('countdown'); setTimeout(() => eventName?.focus(), 100); } },
        { divider: true },
        { icon: '🍅', label: 'פתח פומודורו', shortcut: 'P', action: openPomodoro },
        { icon: '📅', label: 'עבור להיום', shortcut: 'T', action: goToToday },
        { divider: true },
        { icon: '⌨️', label: 'קיצורי מקלדת', shortcut: 'H', action: openShortcuts },
        { icon: '❓', label: 'מדריך', shortcut: '?', action: openGuide },
      ];
      createContextMenu(x, y, items, 'quick-add-context-menu');
    }

    // ============ END ENHANCED CONTEXT MENUS ============

    eventList.onclick = e => {
      const row = e.target.closest(".event-row");
      if (!row) return;
      const id = row.dataset.id;

      // Don't handle clicks on inline edit targets or inputs
      if (e.target.closest('.event-name') || e.target.closest('.event-date') || e.target.tagName === 'INPUT') {
        return;
      }

      if (e.target.closest(".delete-btn")) {
        if (editingId === id) cancelEdit();
        const existing = pendingDeletes.get(id);
        if (existing) clearTimeout(existing.timer);
        const evt = events.find(evt => evt.id === id);
        const timer = setTimeout(() => {
          deleteFromCloud(id);
          pendingDeletes.delete(id);
          if (lastDeletedId === id) hideUndoToast();
        }, DELETE_TIMEOUT_MS);
        pendingDeletes.set(id, { timer });
        // Preserve scroll position during re-render
        const scrollPos = window.scrollY;
        render();
        requestAnimationFrame(() => window.scrollTo(0, scrollPos));
        showUndoToast(evt ? evt.name : 'Event', id);
      } else if (e.target.closest(".edit-btn")) {
        startEdit(id);
      } else if (e.target.closest(".star-btn")) {
        const evt = events.find(evt => evt.id === id);
        if (evt) {
          updateInCloud(id, { ...evt, highlighted: !evt.highlighted });
        }
      } else if (e.target.closest(".pin-btn")) {
        const evt = events.find(evt => evt.id === id);
        if (evt) {
          updateInCloud(id, { ...evt, pinned: !evt.pinned });
        }
      }
    };

    renderCalendar();
    startTicker();

    // ============ TASK MANAGER ============

    const taskManagerOverlay = $("taskManagerOverlay");

    const closeTaskManager = $("closeTaskManager");

    const toggleTasks = $("toggleTasks");
    const taskSearch = $("taskSearch");
    const quickAddTask = $("quickAddTask");
    const quickAddRow = $("quickAddRow");
    const newTaskTitle = $("newTaskTitle");
    const newTaskDue = $("newTaskDue");
    const newTaskRecurrence = $("newTaskRecurrence");
    const newTaskReminder = $("newTaskReminder");
    const addTaskBtn = $("addTaskBtn");
    const taskPriorityPicker = $("taskPriorityPicker");
    const activeTasks = $("activeTasks");
    const completedTasks = $("completedTasks");
    const activeSection = $("activeSection");
    const completedSection = $("completedSection");
    const tasksEmpty = $("tasksEmpty");
    const taskEditModal = $("taskEditModal");
    const editTaskTitle = $("editTaskTitle");
    const editTaskContent = $("editTaskContent");
    const editTaskChecklist = $("editTaskChecklist");
    const newChecklistItem = $("newChecklistItem");
    const addChecklistItem = $("addChecklistItem");
    const editTaskPriority = $("editTaskPriority");
    const editTaskDue = $("editTaskDue");
    const editTaskDuration = $("editTaskDuration");
    const editTaskRecurrence = $("editTaskRecurrence");
    const editTaskReminder = $("editTaskReminder");
    const clearDueBtn = $("clearDueBtn");
    const duplicateTaskBtn = $("duplicateTaskBtn");
    Object.assign(ctx, {
      taskManagerOverlay,
      taskSearch,
      quickAddRow,
      newTaskTitle
    });
    const deleteTaskBtn = $("deleteTaskBtn");
    const saveTaskBtn = $("saveTaskBtn");
    const quickTaskColorPicker = $("quickTaskColorPicker");
    const taskColorPicker = $("taskColorPicker");
    const addSubjectBtn = $("addSubjectBtn");
    const addSubjectSidebarBtn = $("addSubjectSidebarBtn");
    const smartViewsList = $("smartViewsList");
    const subjectModal = $("subjectModal");
    const subjectModalTitle = $("subjectModalTitle");
    const subjectNameInput = $("subjectNameInput");
    const subjectColorPicker = $("subjectColorPicker");
    const cancelSubjectBtn = $("cancelSubjectBtn");
    const deleteSubjectBtn = $("deleteSubjectBtn");
    const saveSubjectBtn = $("saveSubjectBtn");
    const newTaskSubject = $("newTaskSubject");
    const editTaskSubject = $("editTaskSubject");
    const parentSubjectSelect = $("parentSubjectSelect");
    const contextMenu = $("contextMenu");
    const eventContextMenu = $("eventContextMenu");
    const reminderModal = $("reminderModal");
    const subjectsList = $("subjectsList");

    // Task sort UI elements
    const taskSortBtn = $("taskSortBtn");
    const taskSortLabel = $("taskSortLabel");
    const taskSortMenu = $("taskSortMenu");
    let currentTaskSort = localStorage.getItem('task-sort-preference') || 'dueDate';
    const SORT_LABELS = {
      dueDate: '📅 תאריך',
      priority: '⚡ עדיפות',
      created: '🕐 חדש',
      createdOldest: '📆 ישן',
      title: '🔤 שם'
    };

    // Limit year input to 4 digits for all datetime-local inputs
    const dateInputs = [eventDate, newTaskDue, editTaskDue];
    dateInputs.forEach(input => {
      if (!input) return;

      input.addEventListener('input', (e) => {
        const value = e.target.value;
        if (!value) return;

        // Check if year exceeds 4 digits
        const yearMatch = value.match(/^(\d+)-/);
        if (yearMatch && yearMatch[1].length > 4) {
          // Truncate to 4 digits
          const truncatedYear = yearMatch[1].substring(0, 4);
          e.target.value = value.replace(/^\d+-/, truncatedYear + '-');
        }
      });

      // Also set max attribute
      input.setAttribute('max', '9999-12-31T23:59');
    });

    let tasks = [];
    let tasksLoaded = false;
    let hasTasksCache = false;
    Object.defineProperties(ctx, {
      tasks: { get: () => tasks, set: (val) => { tasks = val; } },
      tasksLoaded: { get: () => tasksLoaded, set: (val) => { tasksLoaded = val; } },
      hasTasksCache: { get: () => hasTasksCache, set: (val) => { hasTasksCache = val; } }
    });
    const pruneNotifiedTasks = () => {
      const ids = new Set(tasks.filter(task => !task.completed).map(task => task.id));
      pruneNotifiedMap(NOTIFY_KEYS.TASKS, notifiedTasks, ids);
    };
    let editingTaskId = null;
    let editingTask = null;
    let selectedTaskPriority = 'medium';
    let selectedTaskColor = '';
    let currentFilter = 'all';
    let taskTickerHandle = null;
    let taskReminderTickerHandle = null;
    // Shared subject state (used by Task Manager + Subjects sidebar)
    let subjects = [];
    Object.defineProperty(ctx, 'subjects', { get: () => subjects, set: (val) => { subjects = val; } });
    let currentSubject = 'all';
    let currentSmartView = null; // 'today', 'week', 'overdue', 'nodate'
    let editingSubjectId = null;
    let selectedSubjectColor = '#667eea';
    let contextMenuTarget = null;
    let eventContextMenuTarget = null;
    let expandedSubjects = new Set(); // Track which subjects are expanded


    const PRIORITY_ORDER = { urgent: 0, high: 1, medium: 2, low: 3, none: 4 };
    const PRIORITY_LABELS = { urgent: 'Urgent', high: 'High', medium: 'Medium', low: 'Low', none: '' };
    const RECURRENCE_LABELS = { daily: 'יומי', weekly: 'שבועי', monthly: 'חודשי' };

    // Task Reminder Custom Handling
    const newTaskReminderCustomWrap = $("newTaskReminderCustomWrap");
    const newTaskReminderCustomValue = $("newTaskReminderCustomValue");
    const newTaskReminderCustomUnit = $("newTaskReminderCustomUnit");
    const editTaskReminderCustomWrap = $("editTaskReminderCustomWrap");
    const editTaskReminderCustomValue = $("editTaskReminderCustomValue");
    const editTaskReminderCustomUnit = $("editTaskReminderCustomUnit");

    // Get reminder value in minutes from custom inputs
    function getTaskReminderMinutes(selectEl, customValueEl, customUnitEl) {
      if (!selectEl) return 0;
      if (selectEl.value === 'custom') {
        const val = parseInt(customValueEl?.value, 10) || 0;
        const unit = customUnitEl?.value || 'minutes';
        if (unit === 'hours') return val * 60;
        if (unit === 'days') return val * 1440;
        return val;
      }
      return parseInt(selectEl.value, 10) || 0;
    }

    // Set reminder UI from minutes value
    function setTaskReminderUI(selectEl, customWrapEl, customValueEl, customUnitEl, minutes) {
      if (!selectEl) return;
      const min = parseInt(minutes, 10) || 0;
      const optionExists = Array.from(selectEl.options).some(o => o.value === String(min) && o.value !== 'custom');

      if (min > 0 && !optionExists) {
        selectEl.value = 'custom';
        if (customWrapEl) customWrapEl.classList.remove('hidden');

        let unit = 'minutes';
        let value = min;
        if (min % 1440 === 0) {
          unit = 'days';
          value = Math.round(min / 1440);
        } else if (min % 60 === 0) {
          unit = 'hours';
          value = Math.round(min / 60);
        }
        if (customUnitEl) customUnitEl.value = unit;
        if (customValueEl) customValueEl.value = String(value);
        return;
      }

      selectEl.value = String(min);
      if (customWrapEl) customWrapEl.classList.add('hidden');
      if (customValueEl) customValueEl.value = '';
      if (customUnitEl) customUnitEl.value = 'minutes';
    }

    // New task reminder change handler
    if (newTaskReminder) {
      newTaskReminder.addEventListener('change', () => {
        const isCustom = newTaskReminder.value === 'custom';
        if (newTaskReminderCustomWrap) newTaskReminderCustomWrap.classList.toggle('hidden', !isCustom);
        if (isCustom) {
          if (newTaskReminderCustomUnit && !newTaskReminderCustomUnit.value) newTaskReminderCustomUnit.value = 'minutes';
          if (newTaskReminderCustomValue && !newTaskReminderCustomValue.value) newTaskReminderCustomValue.value = '10';
          if (newTaskReminderCustomValue) newTaskReminderCustomValue.focus();
        }
      });
    }

    // Edit task reminder change handler
    if (editTaskReminder) {
      editTaskReminder.addEventListener('change', () => {
        const isCustom = editTaskReminder.value === 'custom';
        if (editTaskReminderCustomWrap) editTaskReminderCustomWrap.classList.toggle('hidden', !isCustom);
        if (isCustom) {
          if (editTaskReminderCustomUnit && !editTaskReminderCustomUnit.value) editTaskReminderCustomUnit.value = 'minutes';
          if (editTaskReminderCustomValue && !editTaskReminderCustomValue.value) editTaskReminderCustomValue.value = '10';
          if (editTaskReminderCustomValue) editTaskReminderCustomValue.focus();
        }
      });
    }

    // Quick reminder button handlers
    document.querySelectorAll('.quick-reminder-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const minutes = parseInt(btn.dataset.minutes, 10) || 0;
        if (editTaskReminder) {
          setTaskReminderUI(editTaskReminder, editTaskReminderCustomWrap, editTaskReminderCustomValue, editTaskReminderCustomUnit, minutes);
        }
      });
    });

    function getDefaultSubjectId() {
      if (currentSmartView) return '';
      if (currentSubject && currentSubject !== 'all') return currentSubject;
      return '';
    }

    function syncQuickAddSubject() {
      if (!newTaskSubject) return;
      const defaultSubject = getDefaultSubjectId();
      if (defaultSubject) {
        newTaskSubject.value = defaultSubject;
      } else if (!newTaskSubject.value) {
        newTaskSubject.value = '';
      }
      updateQuickAddSubjectColorOption();
    }

    function getSubjectColorById(subjectId) {
      if (!subjectId) return '';
      return subjects.find(s => s.id === subjectId)?.color || '';
    }

    function updateQuickAddSubjectColorOption() {
      if (!newTaskSubject || !quickTaskColorPicker) return;
      const subjectColor = getSubjectColorById(newTaskSubject.value);
      updateSubjectColorOption(quickTaskColorPicker, subjectColor);
      if (!subjectColor && selectedTaskColor === 'subject') {
        selectedTaskColor = '';
        setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
      }
    }

    function setTaskColorSelection(picker, color) {
      if (!picker) return;
      const target = color || '';
      picker.querySelectorAll('.task-color-option').forEach(opt => {
        const optColor = opt.dataset.color || '';
        opt.classList.toggle('selected', optColor === target);
      });
    }

    function getTaskColorFromPicker(picker) {
      if (!picker) return '';
      const selected = picker.querySelector('.task-color-option.selected');
      return selected ? (selected.dataset.color || '') : '';
    }

    function bindTaskColorPicker(picker, onChange) {
      if (!picker) return;
      picker.addEventListener('click', (e) => {
        const option = e.target.closest('.task-color-option');
        if (!option) return;
        if (option.classList.contains('disabled')) return;
        const color = option.dataset.color || '';
        setTaskColorSelection(picker, color);
        if (typeof onChange === 'function') onChange(color);
      });
    }

    function updateSubjectColorOption(picker, subjectColor) {
      if (!picker) return;
      const option = picker.querySelector('.task-color-option.subject');
      if (!option) return;
      if (subjectColor) {
        option.style.background = subjectColor;
        option.classList.remove('disabled');
        option.title = 'Use subject color';
      } else {
        option.style.background = '';
        option.classList.add('disabled');
        option.title = 'Select a subject to use its color';
      }
    }

    function resolveTaskColor(task, subjectColor) {
      if (!task?.color) return '';
      if (task.color === 'subject') return subjectColor || '';
      return task.color;
    }

    function hasManualOrder(taskList = tasks) {
      return taskList.every(t => Number.isFinite(t.order));
    }

    function getNextTaskOrder(isCompleted = false) {
      const list = tasks.filter(t => !!t.completed === !!isCompleted);
      const maxOrder = list.reduce((max, t) => Number.isFinite(t.order) ? Math.max(max, t.order) : max, -1);
      return maxOrder + 1;
    }

    function normalizeRecurrence(value) {
      return value && value !== 'none' ? value : 'none';
    }

    function getNextRecurrenceDate(baseIso, recurrence) {
      const type = normalizeRecurrence(recurrence);
      if (type === 'none') return null;
      const now = new Date();
      let base = baseIso ? new Date(baseIso) : new Date();
      if (Number.isNaN(base.getTime())) return null;
      if (base < now) base = now;
      const next = new Date(base);

      switch (type) {
        case 'daily':
          next.setDate(next.getDate() + 1);
          break;
        case 'weekdays':
          // Skip to next weekday (Sunday=0, Saturday=6)
          do {
            next.setDate(next.getDate() + 1);
          } while (next.getDay() === 0 || next.getDay() === 6 || next.getDay() === 5);
          break;
        case 'weekly':
          next.setDate(next.getDate() + 7);
          break;
        case 'biweekly':
          next.setDate(next.getDate() + 14);
          break;
        case 'monthly':
          next.setMonth(next.getMonth() + 1);
          break;
        case 'yearly':
          next.setFullYear(next.getFullYear() + 1);
          break;
        default:
          return null;
      }
      return next;
    }

    function buildTaskClone(task, overrides = {}) {
      const { id, ...clean } = task;
      const orderValue = hasManualOrder() ? getNextTaskOrder(false) : null;
      const clone = {
        ...clean,
        completed: false,
        createdAt: new Date().toISOString(),
        ...(Number.isFinite(orderValue) ? { order: orderValue } : {})
      };
      return { ...clone, ...overrides };
    }

    function pushTaskClone(task, overrides = {}) {
      if (!task) return;
      const taskData = buildTaskClone(task, overrides);
      createTask(taskData);
    }

    function maybeCreateRecurringTask(task) {
      const recurrence = normalizeRecurrence(task?.recurrence);
      if (recurrence === 'none') return;
      const nextDate = getNextRecurrenceDate(task?.dueDate, recurrence);
      if (!nextDate) return;
      pushTaskClone(task, { dueDate: nextDate.toISOString(), completed: false });
    }

    // ============ POMODORO MODULE (self-contained) ============
    const Pomodoro = createPomodoro();
    ctx.Pomodoro = Pomodoro;

    // Toggle overlays - menu buttons switch between views
    // Four main views: Countdown (app-layout), Tasks (taskManagerOverlay), Pomodoro (pomodoroOverlay), Planner (plannerOverlay)
    const toggleCountdown = document.getElementById('toggleCountdown');
    const togglePlanner = document.getElementById('togglePlanner');
    const plannerOverlay = document.getElementById('plannerOverlay');
    const appLayout = document.querySelector('.app-layout');
    // Ensure current view state and commonly used DOM refs exist before showView
    let currentView = 'countdown';
    Object.defineProperty(ctx, 'currentView', { get: () => currentView, set: (val) => { currentView = val; } });

    function updateHeaderButtons() {
      try {
        ['toggleCountdown', 'toggleTasks', 'togglePomodoro', 'togglePlanner'].forEach(id => {
          const el = $(id);
          if (el) el.classList.remove('active');
        });
        if (currentView === 'countdown') {
          const el = $('toggleCountdown'); if (el) el.classList.add('active');
        } else if (currentView === 'tasks') {
          const el = $('toggleTasks'); if (el) el.classList.add('active');
        } else if (currentView === 'pomodoro') {
          const el = $('togglePomodoro'); if (el) el.classList.add('active');
        } else if (currentView === 'planner') {
          const el = $('togglePlanner'); if (el) el.classList.add('active');
        }
      } catch (e) {
        console.warn('updateHeaderButtons error', e);
      }
    }






    const showView = (view) => {
      // Hide all views
      appLayout.style.display = 'none';
      taskManagerOverlay.classList.remove('open');
      pomodoroOverlay.classList.remove('open');
      if (plannerOverlay) plannerOverlay.classList.remove('open');
      stopTaskTicker();

      // Show calendar button only for countdown view
      toggleSidebar.style.display = view === 'countdown' ? '' : 'none';

      // Show selected view
      if (view === 'countdown') {
        appLayout.style.display = '';
      } else if (view === 'tasks') {
        taskManagerOverlay.classList.add('open');
        renderSubjectsSidebar();
        renderTasks();
        startTaskTicker();
        if (typeof setupTaskCalendar === 'function') setupTaskCalendar();
        if (typeof renderTaskCalendar === 'function') renderTaskCalendar();
      } else if (view === 'pomodoro') {
        pomodoroOverlay.classList.add('open');
      } else if (view === 'planner') {
        if (plannerOverlay) {
          plannerOverlay.classList.add('open');
          if (typeof DailyPlanner !== 'undefined' && DailyPlanner.init) {
            DailyPlanner.init();
          }
        }
      }

      currentView = view;
      updateHeaderButtons();
      try { window.dispatchEvent(new CustomEvent('app:viewchange', { detail: { view } })); } catch (e) { }
    };

    // Expose for non-module scripts (e.g. mobile bottom nav handler)
    window.showView = showView;
    ctx.showView = showView;

    toggleCountdown.onclick = () => showView('countdown');
    toggleTasks.onclick = () => showView('tasks');
    togglePomodoro.onclick = () => showView('pomodoro');
    if (togglePlanner) togglePlanner.onclick = () => showView('planner');

    // Close task manager button
    if (closeTaskManager) {
      closeTaskManager.onclick = () => {
        taskManagerOverlay.classList.remove('open');
        stopTaskTicker();
        showView('countdown');
      };
    }

    // Initialize header button states
    updateHeaderButtons();
    newTaskTitle.addEventListener('focus', () => {
      quickAddRow.style.display = 'flex';
      syncQuickAddSubject();
    });

    // Collapse quick add when clicking outside
    taskManagerOverlay.addEventListener('click', (e) => {
      if (!quickAddTask.contains(e.target) && !newTaskTitle.value.trim()) {
        quickAddRow.style.display = 'none';
      }
    });

    // Priority picker in quick add
    taskPriorityPicker.addEventListener('click', (e) => {
      const option = e.target.closest('.priority-option');
      if (!option) return;
      taskPriorityPicker.querySelectorAll('.priority-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      selectedTaskPriority = option.dataset.priority;
    });

    bindTaskColorPicker(quickTaskColorPicker, (color) => {
      selectedTaskColor = color;
    });
    setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
    updateQuickAddSubjectColorOption();
    if (newTaskSubject) {
      newTaskSubject.addEventListener('change', () => {
        updateQuickAddSubjectColorOption();
      });
    }
    if (editTaskSubject) {
      editTaskSubject.addEventListener('change', () => {
        const subjectColor = getSubjectColorById(editTaskSubject.value);
        updateSubjectColorOption(taskColorPicker, subjectColor);
        if (!subjectColor && getTaskColorFromPicker(taskColorPicker) === 'subject') {
          setTaskColorSelection(taskColorPicker, '');
          if (editingTask) editingTask.color = '';
        }
      });
    }

    // ============ UNIFIED ADD TASK FUNCTION ============
    function addTask() {
      const title = newTaskTitle.value.trim();
      if (!title) return;

      const dueValue = newTaskDue.value;
      const dueDate = dueValue ? parseLocal(dueValue) : null;
      const recurrence = newTaskRecurrence ? newTaskRecurrence.value : 'none';
      const reminder = getTaskReminderMinutes(newTaskReminder, newTaskReminderCustomValue, newTaskReminderCustomUnit);
      const durationEl = document.getElementById('newTaskDuration');
      const duration = durationEl ? parseInt(durationEl.value, 10) || 0 : 0;

      const defaultSubjectId = getDefaultSubjectId();
      const selectedSubjectId = newTaskSubject ? (newTaskSubject.value || defaultSubjectId) : defaultSubjectId;
      const orderValue = hasManualOrder() ? getNextTaskOrder(false) : null;

      const taskData = {
        title,
        content: '',
        priority: selectedTaskPriority,
        dueDate: dueDate ? dueDate.toISOString() : null,
        subject: selectedSubjectId || '',
        checklist: [],
        completed: false,
        createdAt: new Date().toISOString(),
        ...(Number.isFinite(orderValue) ? { order: orderValue } : {}),
        ...(selectedTaskColor ? { color: selectedTaskColor } : {}),
        ...(recurrence && recurrence !== 'none' ? { recurrence } : {}),
        ...(reminder > 0 ? { reminder } : {}),
        ...(duration > 0 ? { duration } : {})
      };

      createTask(taskData);

      // Reset form
      newTaskTitle.value = '';
      newTaskDue.value = '';
      if (newTaskRecurrence) newTaskRecurrence.value = 'none';
      if (newTaskReminder) newTaskReminder.value = '0';
      if (newTaskReminderCustomWrap) newTaskReminderCustomWrap.classList.add('hidden');
      if (newTaskReminderCustomValue) newTaskReminderCustomValue.value = '';
      if (newTaskReminderCustomUnit) newTaskReminderCustomUnit.value = 'minutes';
      if (durationEl) durationEl.value = '0';
      if (newTaskSubject) newTaskSubject.value = '';
      if (quickAddRow) quickAddRow.style.display = 'none';
      selectedTaskPriority = 'medium';
      taskPriorityPicker.querySelectorAll('.priority-option').forEach(o => o.classList.remove('selected'));
      taskPriorityPicker.querySelector('[data-priority="medium"]').classList.add('selected');
      selectedTaskColor = '';
      setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
      syncQuickAddSubject();
      const taskSections = $("taskSections");
      if (taskSections) {
        taskSections.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Hook button to unified function
    addTaskBtn.onclick = addTask;

    // Filter pills
    document.querySelectorAll('.filter-pill').forEach(pill => {
      pill.addEventListener('click', () => {
        document.querySelectorAll('.filter-pill').forEach(p => p.classList.remove('active'));
        pill.classList.add('active');
        currentFilter = pill.dataset.filter;
        renderTasks();
      });
    });

    // Search
    taskSearch.addEventListener('input', () => {
      renderTasks();
    });

    const tasksEmptyDefaults = tasksEmpty ? {
      icon: tasksEmpty.querySelector('.tasks-empty-icon')?.textContent || '📝',
      title: tasksEmpty.querySelector('h3')?.textContent || 'אין משימות עדיין',
      desc: tasksEmpty.querySelector('p')?.textContent || 'הוסף משימה ראשונה למעלה כדי להתחיל!'
    } : null;

    const setTasksEmptyMessage = (icon, title, desc) => {
      if (!tasksEmpty) return;
      const iconEl = tasksEmpty.querySelector('.tasks-empty-icon');
      const titleEl = tasksEmpty.querySelector('h3');
      const descEl = tasksEmpty.querySelector('p');
      if (iconEl) iconEl.textContent = icon;
      if (titleEl) titleEl.textContent = title;
      if (descEl) descEl.textContent = desc;
    };

    const showTasksLoading = () => {
      activeSection.style.display = 'none';
      completedSection.style.display = 'none';
      tasksEmpty.style.display = 'block';
      setTasksEmptyMessage('⏳', 'טוען משימות...', 'מסנכרן משימות מהענן');
    };

    const resetTasksEmptyMessage = () => {
      if (!tasksEmptyDefaults) return;
      setTasksEmptyMessage(tasksEmptyDefaults.icon, tasksEmptyDefaults.title, tasksEmptyDefaults.desc);
    };
    Object.assign(ctx, { showTasksLoading, resetTasksEmptyMessage });

    const tasksApi = initTasks({
      onTasksUpdated: () => {
        pruneNotifiedTasks();
        if (taskManagerOverlay.classList.contains('open')) {
          renderTasks();
          renderSubjectsSidebar();
        }
        const trSidebar = $('taskRightSidebar');
        if (trSidebar && !trSidebar.classList.contains('hidden')) {
          renderTaskCalendar();
        }
      },
      onTasksCacheLoaded: () => {
        pruneNotifiedTasks();
        if (taskManagerOverlay.classList.contains('open')) {
          renderTasks();
          renderSubjectsSidebar();
        }
      }
    });
    const { getTaskRef, saveTask, removeTask, createTask } = tasksApi;
    Object.assign(ctx, { getTaskRef, saveTask, removeTask, createTask });

    function getFilteredTasks() {
      let filtered = [...tasks];

      // Apply search filter
      const searchTerm = taskSearch.value.trim().toLowerCase();
      const normalizedSearch = searchTerm.replace(/^#/, '');
      if (normalizedSearch) {
        filtered = filtered.filter(t => {
          const subject = subjects.find(s => s.id === t.subject);
          const subjectName = subject?.name?.toLowerCase() || '';
          const parentName = subject?.parentId
            ? (subjects.find(s => s.id === subject.parentId)?.name?.toLowerCase() || '')
            : '';
          const subjectLabel = parentName ? `${parentName} ${subjectName}` : subjectName;

          return (
            t.title.toLowerCase().includes(normalizedSearch) ||
            (t.content && t.content.toLowerCase().includes(normalizedSearch)) ||
            subjectName.includes(normalizedSearch) ||
            parentName.includes(normalizedSearch) ||
            subjectLabel.includes(normalizedSearch)
          );
        });
      }

      // Apply status filter
      if (currentFilter === 'active') {
        filtered = filtered.filter(t => !t.completed);
      } else if (currentFilter === 'completed') {
        filtered = filtered.filter(t => t.completed);
      } else if (currentFilter === 'tomorrow') {
        const now = new Date();
        const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
        const dayAfter = new Date(tomorrow);
        dayAfter.setDate(dayAfter.getDate() + 1);

        filtered = filtered.filter(t => {
          if (!t.dueDate) return false;
          const due = new Date(t.dueDate);
          return due >= tomorrow && due < dayAfter;
        });
      }

      // Apply date filter for calendar selection
      if (currentSmartView === 'date-filter' && window.taskFilterDate) {
        const dateStr = window.taskFilterDate.toDateString();
        filtered = filtered.filter(t => {
          if (!t.dueDate) return false;
          return new Date(t.dueDate).toDateString() === dateStr;
        });
      }

      return filtered;
    }

    function sortTasksDefault(taskList) {
      // Sort by: due date (soonest first), then by priority, then by created date (newest first)
      return taskList.sort((a, b) => {
        // Due date comparison (tasks with due dates come first, soonest first)
        if (a.dueDate && !b.dueDate) return -1;
        if (!a.dueDate && b.dueDate) return 1;
        if (a.dueDate && b.dueDate) {
          const dueDiff = new Date(a.dueDate) - new Date(b.dueDate);
          if (dueDiff !== 0) return dueDiff;
        }

        // Priority comparison (higher priority first)
        const priorityA = PRIORITY_ORDER[a.priority || 'none'];
        const priorityB = PRIORITY_ORDER[b.priority || 'none'];
        if (priorityA !== priorityB) return priorityA - priorityB;

        // Created date (newest first)
        return new Date(b.createdAt) - new Date(a.createdAt);
      });
    }

    function sortTasks(taskList) {
      // Check if any tasks have been manually reordered (have manualOrder flag)
      const manuallyOrdered = taskList.filter(t => t.manualOrder === true);
      const autoOrdered = taskList.filter(t => t.manualOrder !== true);

      // Sort auto-ordered tasks by selected sort preference
      const sortByPreference = (list) => {
        return list.sort((a, b) => {
          switch (currentTaskSort) {
            case 'priority':
              // Priority first (higher priority first)
              const priorityA = PRIORITY_ORDER[a.priority || 'none'];
              const priorityB = PRIORITY_ORDER[b.priority || 'none'];
              if (priorityA !== priorityB) return priorityA - priorityB;
              // Then by due date
              if (a.dueDate && !b.dueDate) return -1;
              if (!a.dueDate && b.dueDate) return 1;
              if (a.dueDate && b.dueDate) {
                const dueDiff = new Date(a.dueDate) - new Date(b.dueDate);
                if (dueDiff !== 0) return dueDiff;
              }
              return new Date(b.createdAt) - new Date(a.createdAt);

            case 'created':
              // Created date (newest first)
              return new Date(b.createdAt) - new Date(a.createdAt);

            case 'createdOldest':
              // Created date (oldest first)
              return new Date(a.createdAt) - new Date(b.createdAt);

            case 'title':
              // Title (A-Z, Hebrew aware)
              const titleA = (a.title || '').toLowerCase();
              const titleB = (b.title || '').toLowerCase();
              return titleA.localeCompare(titleB, 'he');

            case 'dueDate':
            default:
              // Due date (soonest first) - default
              if (a.dueDate && !b.dueDate) return -1;
              if (!a.dueDate && b.dueDate) return 1;
              if (a.dueDate && b.dueDate) {
                const dueDiff = new Date(a.dueDate) - new Date(b.dueDate);
                if (dueDiff !== 0) return dueDiff;
              }
              // Then by priority
              const prioA = PRIORITY_ORDER[a.priority || 'none'];
              const prioB = PRIORITY_ORDER[b.priority || 'none'];
              if (prioA !== prioB) return prioA - prioB;
              // Then by created date
              return new Date(b.createdAt) - new Date(a.createdAt);
          }
        });
      };

      sortByPreference(autoOrdered);

      // Sort manually ordered tasks by their order value
      manuallyOrdered.sort((a, b) => {
        const aOrder = Number.isFinite(a.order) ? a.order : Number.MAX_SAFE_INTEGER;
        const bOrder = Number.isFinite(b.order) ? b.order : Number.MAX_SAFE_INTEGER;
        return aOrder - bOrder;
      });

      // If there are manual orders, integrate them at their specified positions
      if (manuallyOrdered.length > 0) {
        // Manually ordered tasks go first, then auto-ordered
        return [...manuallyOrdered, ...autoOrdered];
      }

      return autoOrdered;
    }

    function calcTaskCountdown(dueDate) {
      if (!dueDate) return null;
      const now = Date.now();
      const due = new Date(dueDate).getTime();
      const diff = due - now;

      if (diff <= 0) {
        return { overdue: true, text: 'Overdue', urgency: 'overdue' };
      }

      const days = Math.floor(diff / 86400000);
      const hours = Math.floor((diff % 86400000) / 3600000);
      const mins = Math.floor((diff % 3600000) / 60000);

      let text = '';
      let urgency = '';

      if (days > 0) {
        text = `${days}d ${hours}h`;
      } else if (hours > 0) {
        text = `${hours}h ${mins}m`;
      } else {
        text = `${mins}m`;
      }

      // Urgency levels for styling
      if (days === 0 && hours < 6) {
        urgency = 'soon';
      } else if (days === 0) {
        urgency = 'today';
      }

      return { overdue: false, text, urgency, days, hours, mins };
    }

    function renderTasks() {
      if (!tasksLoaded && !hasTasksCache) {
        showTasksLoading();
        return;
      }
      const filtered = getFilteredTasks();
      const active = filtered.filter(t => !t.completed);
      const completed = filtered.filter(t => t.completed);

      // Update sidebar counts
      updateSmartViewCounts();
      renderSubjectsSidebar();

      // Update title for date filter
      const viewNameDisplay = document.querySelector('.task-manager-title');
      if (currentSmartView === 'date-filter' && window.taskFilterDate && viewNameDisplay) {
        const options = { weekday: 'long', day: 'numeric', month: 'long' };
        viewNameDisplay.textContent = `📅 ${window.taskFilterDate.toLocaleDateString('he-IL', options)}`;
      } else if (viewNameDisplay && !currentSmartView) {
        // Reset to default title if not in a smart view
        const subjectName = currentSubject ? subjects.find(s => s.id === currentSubject)?.name : null;
        viewNameDisplay.textContent = subjectName || 'כל המשימות';
      }

      // Sort tasks
      sortTasks(active);
      sortTasks(completed);

      // Check if showing suggested tasks for empty sub-subject
      const showingSuggested = window.showingSuggestedTasks;

      // Active tasks section
      if (active.length > 0 || currentFilter === 'all' || currentFilter === 'active') {
        activeSection.style.display = 'block';
        let suggestedBanner = '';
        if (showingSuggested && active.length > 0) {
          suggestedBanner = `
          <div class="suggested-tasks-banner">
            <span class="suggested-icon">💡</span>
            <span>אין משימות בתת-נושא זה. מוצגות משימות דחופות מכל הנושאים:</span>
          </div>
        `;
        }
        activeTasks.innerHTML = suggestedBanner + active.map(t => renderTaskItem(t, showingSuggested)).join('');
      } else {
        activeSection.style.display = 'none';
      }

      // Completed tasks section
      if (completed.length > 0 && (currentFilter === 'all' || currentFilter === 'completed') && !showingSuggested) {
        completedSection.style.display = 'block';
        completedTasks.innerHTML = completed.map(t => renderTaskItem(t)).join('');
      } else {
        completedSection.style.display = 'none';
      }

      // Empty state
      if (filtered.length === 0 && !showingSuggested) {
        tasksEmpty.style.display = 'block';
        activeSection.style.display = 'none';
      } else {
        tasksEmpty.style.display = 'none';
      }

      Pomodoro.updateTasks(tasks);

      // Event delegation is set up once below, no need to call attachTaskEventHandlers
    }
    ctx.renderTasks = renderTasks;

    function renderTaskItem(task, showSubjectTag = false) {
      const priority = task.priority || 'none';
      const countdown = calcTaskCountdown(task.dueDate);

      let dueDateHtml = `<span class="task-due add" data-due-iso="">+ תאריך</span>`;
      if (task.dueDate) {
        const dueDate = new Date(task.dueDate);
        const day = dueDate.getDate();
        const month = dueDate.toLocaleString('he-IL', { month: 'short' });
        const weekday = dueDate.toLocaleString('he-IL', { weekday: 'short' });
        const time = dueDate.toLocaleString('he-IL', { hour: '2-digit', minute: '2-digit' });
        const dateStr = `${weekday}, ${day} ${month}, ${time}`;
        const urgencyClass = countdown?.overdue ? 'overdue' : (countdown?.urgency === 'soon' ? 'soon' : '');
        dueDateHtml = `<span class="task-due ${urgencyClass}" data-due-iso="${task.dueDate}">📅 ${dateStr}</span>`;
      }

      let countdownHtml = '';
      if (countdown) {
        const countdownClass = countdown.overdue ? 'overdue' : (countdown.urgency === 'soon' ? 'soon' : '');
        countdownHtml = `<span class="task-countdown ${countdownClass}" data-due="${task.dueDate}">${countdown.text}</span>`;
      }

      let recurrenceHtml = '';
      const recurrence = normalizeRecurrence(task.recurrence);
      if (recurrence !== 'none') {
        const label = RECURRENCE_LABELS[recurrence] || recurrence;
        // Clear two-arrow repeat icon for better small-size rendering
        const icon = `<svg viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" style="width:13px;height:13px;stroke:currentColor;fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M8 16H3v5"></path></svg>`;
        recurrenceHtml = `<span class="task-recurrence">${icon}${label}</span>`;
      }

      let reminderHtml = '';
      const reminderMinutes = parseInt(task.reminder, 10) || 0;
      if (reminderMinutes > 0) {
        const reminderLabel = formatReminderOffset(reminderMinutes);
        reminderHtml = `<span class="task-reminder">🔔 ${reminderLabel}</span>`;
      }

      let durationHtml = '';
      const durationMinutes = parseInt(task.duration, 10) || 0;
      if (durationMinutes > 0) {
        const hours = Math.floor(durationMinutes / 60);
        const mins = durationMinutes % 60;
        let durationLabel = '';
        if (hours > 0 && mins > 0) {
          durationLabel = `${hours}:${mins.toString().padStart(2, '0')} שעות`;
        } else if (hours > 0) {
          durationLabel = `${hours} שעות`;
        } else {
          durationLabel = `${mins} דקות`;
        }
        durationHtml = `<span class="task-duration">⏱️ ${durationLabel}</span>`;
      }

      const subjectData = task.subject ? subjects.find(s => s.id === task.subject) : null;
      const subjectColor = subjectData ? subjectData.color : '';
      const resolvedTaskColor = resolveTaskColor(task, subjectColor);
      const styleParts = [];
      if (subjectColor) {
        styleParts.push(`--subject-color: ${subjectColor};`);
        styleParts.push(`--subject-tint: ${subjectColor}26;`);
      }
      if (resolvedTaskColor) {
        styleParts.push(`--task-color: ${resolvedTaskColor};`);
        styleParts.push(`--task-tint: ${resolvedTaskColor}22;`);
      }
      const taskStyle = styleParts.length ? ` style="${styleParts.join(' ')}"` : '';
      const taskColorDot = resolvedTaskColor ? `<span class="task-color-dot" style="background: ${resolvedTaskColor};"></span>` : '';

      // Subject badge - show when viewing "all" OR when explicitly requested (suggested tasks)
      let subjectHtml = '';
      if (subjectData) {
        const shouldShow = (currentSubject === 'all') || showSubjectTag;
        if (shouldShow) {
          // If it's a sub-subject and showing tag, show parent > child
          let displayName = subjectData.name;
          if (showSubjectTag && subjectData.parentId) {
            const parent = subjects.find(s => s.id === subjectData.parentId);
            if (parent) {
              displayName = `${parent.name} › ${subjectData.name}`;
            }
          }
          subjectHtml = `<span class="task-subject-badge" style="--subject-color: ${subjectData.color};">${escapeHtml(displayName)}</span>`;
        }
      }

      let subtasksHtml = '';
      if (task.checklist && task.checklist.length > 0) {
        const checked = task.checklist.filter(c => c.checked).length;
        const total = task.checklist.length;
        const maxShow = 3;
        const items = task.checklist.slice(0, maxShow);

        subtasksHtml = `
        <div class="task-subtasks">
          <div class="task-subtask-progress">${checked}/${total} completed</div>
          ${items.map((item, i) => `
            <div class="task-subtask ${item.checked ? 'checked' : ''}">
              <input type="checkbox" ${item.checked ? 'checked' : ''} data-index="${i}" />
              <span>${escapeHtml(item.text)}</span>
            </div>
          `).join('')}
          ${task.checklist.length > maxShow ? `<div style="font-size: 12px; color: var(--muted);">+${task.checklist.length - maxShow} more</div>` : ''}
        </div>
      `;
      }

      const priorityBadge = `<span class="task-priority-badge ${priority === 'none' ? 'muted' : ''}" data-priority="${priority}">${priority === 'none' ? 'קבע עדיפות' : PRIORITY_LABELS[priority]}</span>`;

      return `
      <div class="task-item priority-${priority} ${task.completed ? 'completed' : ''}" data-id="${task.id}" draggable="true"${taskStyle}>
        <div class="task-checkbox" data-action="toggle">${task.completed ? '✓' : ''}</div>
        <div class="task-main">
          <div class="task-title-row">
            <span class="task-title">${escapeHtml(task.title)}</span>
            ${taskColorDot}
            ${subjectHtml}
            ${priorityBadge}
          </div>
          <div class="task-meta">
            ${dueDateHtml}
            ${countdownHtml}
            ${recurrenceHtml}
            ${reminderHtml}
            ${durationHtml}
          </div>
          ${subtasksHtml}
        </div>
        <div class="task-actions">

          <div class="task-reminder-wrap">
            <button class="task-reminder-btn ${task.reminder ? 'has-reminder' : ''}" data-action="reminder" title="${task.reminder ? `תזכורת ${task.reminder} דקות לפני` : 'הגדר תזכורת'}">🔔</button>
            <div class="task-reminder-dropdown" data-task-id="${task.id}">
              <div class="task-reminder-option" data-minutes="1">דקה אחת</div>
              <div class="task-reminder-option" data-minutes="5">5 דקות</div>
              <div class="task-reminder-option" data-minutes="15">15 דקות</div>
              <div class="task-reminder-option" data-minutes="60">שעה</div>
              <div class="task-reminder-option" data-minutes="1440">יום</div>
              ${task.reminder ? '<div class="task-reminder-option remove" data-minutes="0">הסר תזכורת</div>' : ''}
            </div>
          </div>
          <button class="task-action-btn" data-action="edit" title="Edit" aria-label="עריכה">✏️</button>
          <button class="task-action-btn" data-action="duplicate" title="Duplicate" aria-label="שכפל">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </button>
          <button class="task-action-btn delete" data-action="delete" title="Delete" aria-label="מחק">🗑️</button>
        </div>
      </div>
    `;
    }

    function formatTaskDueDisplay(dueIso) {
      if (!dueIso) return '+ תאריך';
      const dueDate = new Date(dueIso);
      const day = dueDate.getDate();
      const month = dueDate.toLocaleDateString('he-IL', { month: 'short' });
      const time = dueDate.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
      return `${day} ${month}, ${time}`;
    }

    function startInlineTaskTitleEdit(titleEl, task) {
      if (titleEl.dataset.editing === '1') return;
      titleEl.dataset.editing = '1';

      const input = document.createElement('input');
      input.type = 'text';
      input.value = task.title || '';
      input.className = 'inline-edit-input';
      titleEl.replaceWith(input);
      input.focus();
      input.select();

      const finish = (commit) => {
        input.replaceWith(titleEl);
        delete titleEl.dataset.editing;
        if (commit) {
          const newTitle = input.value.trim() || task.title;
          titleEl.textContent = newTitle;
          const { id, isOwn, isShared, ...clean } = task;
          saveTask(task.id, { ...clean, title: newTitle }, task.subject);
        }
      };

      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') finish(true);
        else if (ev.key === 'Escape') finish(false);
      });
      input.addEventListener('blur', () => finish(true));
    }

    function startInlineTaskDueEdit(dueEl, task) {
      if (dueEl.dataset.editing === '1') return;
      dueEl.dataset.editing = '1';

      const input = document.createElement('input');
      input.type = 'datetime-local';
      input.value = task.dueDate ? toLocalDatetime(task.dueDate) : '';
      input.className = 'inline-edit-input small';
      dueEl.replaceWith(input);
      input.focus();

      const finish = (commit) => {
        input.replaceWith(dueEl);
        delete dueEl.dataset.editing;
        if (commit) {
          let newDue = null;
          if (input.value) {
            const parsed = parseLocal(input.value);
            if (parsed && !isNaN(parsed.getTime())) {
              newDue = parsed.toISOString();
            } else {
              // invalid -> keep original display
              dueEl.textContent = dueEl.textContent || '+ תאריך';
              return;
            }
          }
          const { id, isOwn, isShared, ...clean } = task;
          saveTask(task.id, { ...clean, dueDate: newDue }, task.subject);
          dueEl.dataset.dueIso = newDue || '';
          dueEl.textContent = newDue ? `📅 ${formatTaskDueDisplay(newDue)}` : '+ תאריך';
          dueEl.classList.toggle('add', !newDue);
        }
      };

      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') finish(true);
        else if (ev.key === 'Escape') finish(false);
      });
      input.addEventListener('blur', () => finish(true));
    }

    let activePriorityPopover = null;

    function closePriorityPopover() {
      if (activePriorityPopover) {
        activePriorityPopover.remove();
        activePriorityPopover = null;
      }
    }

    function startInlineTaskPriorityEdit(badgeEl, task) {
      closePriorityPopover();

      const pop = document.createElement('div');
      pop.className = 'priority-popover';

      ['urgent', 'high', 'medium', 'low', 'none'].forEach(key => {
        const btn = document.createElement('button');
        btn.textContent = key === 'none' ? 'ללא עדיפות' : (PRIORITY_LABELS[key] || key);
        btn.dataset.priority = key;
        btn.onclick = (ev) => {
          ev.stopPropagation();
          const { id, isOwn, isShared, ...clean } = task;
          saveTask(task.id, { ...clean, priority: key }, task.subject);
          badgeEl.textContent = key === 'none' ? 'קבע עדיפות' : (PRIORITY_LABELS[key] || key);
          badgeEl.dataset.priority = key;
          badgeEl.classList.toggle('muted', key === 'none');
          closePriorityPopover();
        };
        pop.appendChild(btn);
      });

      const rect = badgeEl.getBoundingClientRect();
      pop.style.top = `${rect.bottom + 8}px`;
      pop.style.left = `${Math.max(8, rect.left - 60)}px`;

      document.body.appendChild(pop);
      activePriorityPopover = pop;

      setTimeout(() => {
        const outsideHandler = (ev) => {
          if (!pop.contains(ev.target)) {
            closePriorityPopover();
            document.removeEventListener('click', outsideHandler);
          }
        };
        document.addEventListener('click', outsideHandler);
      }, 0);
    }

    let activeReminderPopover = null;

    function closeReminderPopover() {
      if (activeReminderPopover) {
        activeReminderPopover.remove();
        activeReminderPopover = null;
      }
    }

    function openTaskReminderPopover(btnElement, task) {
      closeReminderPopover();
      closePriorityPopover(); // Close others

      const pop = document.createElement('div');
      pop.className = 'task-reminder-dropdown open global-popover'; // Reuse class styles but add global tag

      // Copy styles for standalone positioning
      pop.style.position = 'fixed';
      pop.style.zIndex = '10005';
      pop.style.width = '200px';
      pop.style.background = 'var(--card)';
      pop.style.border = '1px solid var(--border)';
      pop.style.borderRadius = 'var(--radius-md)';
      pop.style.boxShadow = 'var(--shadow-lg)';
      pop.style.padding = '4px';

      const setReminder = (minutes) => {
        const { id, isOwn, isShared, ...cleanTask } = task;
        saveTask(task.id, { ...cleanTask, reminder: minutes || null }, task.subject);
        closeReminderPopover();
      };

      const options = [
        { label: 'דקה אחת', val: 1 },
        { label: '5 דקות', val: 5 },
        { label: '15 דקות', val: 15 },
        { label: 'שעה', val: 60 },
        { label: 'יום', val: 1440 }
      ];

      options.forEach(opt => {
        const div = document.createElement('div');
        div.className = 'task-reminder-option';
        div.textContent = opt.label;
        div.onclick = (e) => { e.stopPropagation(); setReminder(opt.val); };
        pop.appendChild(div);
      });

      if (task.reminder) {
        const removeDiv = document.createElement('div');
        removeDiv.className = 'task-reminder-option remove';
        removeDiv.textContent = 'הסר תזכורת';
        removeDiv.onclick = (e) => { e.stopPropagation(); setReminder(0); };
        pop.appendChild(removeDiv);
      }

      document.body.appendChild(pop);
      activeReminderPopover = pop;

      // Position logic
      const rect = btnElement.getBoundingClientRect();
      const popRect = pop.getBoundingClientRect();

      let top = rect.bottom + 5;
      let left = rect.left;

      // Flip if close to bottom
      if (top + popRect.height > window.innerHeight) {
        top = rect.top - popRect.height - 5;
      }

      // Flip if close to right edge (RTL) or left edge
      if (left + popRect.width > window.innerWidth) {
        left = window.innerWidth - popRect.width - 10;
      }
      if (left < 0) left = 10;

      pop.style.top = `${top}px`;
      pop.style.left = `${left}px`;

      // Close on outside click
      setTimeout(() => {
        const outsideHandler = (ev) => {
          if (!pop.contains(ev.target)) {
            closeReminderPopover();
            document.removeEventListener('click', outsideHandler);
          }
        };
        document.addEventListener('click', outsideHandler);
      }, 0);
    }

    // ============ EVENT DELEGATION FOR TASK LIST ============
    // Single click handler for all task interactions - much more efficient than per-item listeners
    function setupTaskEventDelegation() {
      const containers = [activeTasks, completedTasks];

      containers.forEach(container => {
        if (!container) return;

        container.addEventListener('click', (e) => {
          const taskItem = e.target.closest('.task-item');
          if (!taskItem) return;

          const taskId = taskItem.dataset.id;
          const task = tasks.find(t => t.id === taskId);
          if (!task) return;

          const titleEl = e.target.closest('.task-title');
          if (titleEl) {
            e.stopPropagation();
            startInlineTaskTitleEdit(titleEl, task);
            return;
          }

          const dueEl = e.target.closest('.task-due');
          if (dueEl) {
            e.stopPropagation();
            startInlineTaskDueEdit(dueEl, task);
            return;
          }

          const priorityEl = e.target.closest('.task-priority-badge');
          if (priorityEl) {
            e.stopPropagation();
            startInlineTaskPriorityEdit(priorityEl, task);
            return;
          }

          // Reminder button
          const reminderBtn = e.target.closest('.task-reminder-btn');
          if (reminderBtn) {
            e.stopPropagation();
            openTaskReminderPopover(reminderBtn, task);
            return;
          }

          // Check what was clicked
          const action = e.target.closest('[data-action]')?.dataset.action;
          const isSubtaskCheckbox = e.target.closest('.task-subtask input[type="checkbox"]');
          const isInlineInput = e.target.tagName === 'INPUT' && e.target.classList.contains('inline-edit-input');
          const isMainArea = e.target.closest('.task-main') && !isSubtaskCheckbox && !isInlineInput;

          if (action === 'toggle' || e.target.closest('.task-checkbox')) {
            // Toggle complete
            e.stopPropagation();
            const nextCompleted = !task.completed;
            if (nextCompleted) {
              maybeCreateRecurringTask(task);
              // Add confetti celebration animation
              if (typeof createConfetti === 'function') {
                const rect = taskItem.getBoundingClientRect();
                createConfetti(rect.left + 20, rect.top + rect.height / 2);
              }
              taskItem.classList.add('completing');
              setTimeout(() => taskItem.classList.remove('completing'), 500);
              // Push to undo stack
              if (typeof pushToUndoStack === 'function') {
                pushToUndoStack({ type: 'completeTask', taskId, message: `✅ "${task.title}" הושלם` });
              }
            }
            const { id, isOwn, isShared, ...cleanTask } = task;
            saveTask(taskId, { ...cleanTask, completed: nextCompleted }, task.subject);
          } else if (action === 'edit') {
            // Edit button
            e.stopPropagation();
            openTaskEditModal(taskId);

          } else if (action === 'duplicate') {
            // Duplicate button
            e.stopPropagation();
            pushTaskClone(task);
          } else if (action === 'delete') {
            // Delete button
            e.stopPropagation();
            removeTask(task);
          } else if (isSubtaskCheckbox) {
            // Subtask checkbox
            e.stopPropagation();
            const idx = parseInt(isSubtaskCheckbox.dataset.index);
            if (task.checklist && task.checklist[idx] !== undefined) {
              task.checklist[idx].checked = isSubtaskCheckbox.checked;
              const { id, isOwn, isShared, ...cleanTask } = task;
              saveTask(taskId, cleanTask, task.subject);
            }
          } else if (isMainArea) {
            // Click on main area to edit
            openTaskEditModal(taskId);
          }
        });
      });
    }

    // Initialize event delegation once
    setupTaskEventDelegation();

    // Close task reminder dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.task-reminder-wrap')) {
        document.querySelectorAll('.task-reminder-dropdown.open').forEach(d => d.classList.remove('open'));
      }
      // Close sort dropdown when clicking outside
      if (!e.target.closest('.task-sort-dropdown')) {
        if (taskSortMenu) taskSortMenu.classList.remove('open');
      }
    });

    // Task sort dropdown toggle and selection
    if (taskSortBtn && taskSortMenu) {
      // Set initial label from saved preference
      if (taskSortLabel && SORT_LABELS[currentTaskSort]) {
        taskSortLabel.textContent = SORT_LABELS[currentTaskSort];
      }
      // Update selected state
      taskSortMenu.querySelectorAll('.task-sort-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.sort === currentTaskSort);
      });

      taskSortBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        taskSortMenu.classList.toggle('open');
      });

      taskSortMenu.addEventListener('click', (e) => {
        const option = e.target.closest('.task-sort-option');
        if (!option) return;
        e.stopPropagation();

        const sortType = option.dataset.sort;
        currentTaskSort = sortType;
        localStorage.setItem('task-sort-preference', sortType);

        // Update UI
        if (taskSortLabel) taskSortLabel.textContent = SORT_LABELS[sortType] || sortType;
        taskSortMenu.querySelectorAll('.task-sort-option').forEach(opt => {
          opt.classList.toggle('selected', opt.dataset.sort === sortType);
        });
        taskSortMenu.classList.remove('open');

        // Re-render tasks with new sort
        renderTasks();
      });
    }

    let draggingTaskId = null;
    let dragSourceContainer = null;

    function ensureTaskOrderInitialized() {
      // Don't initialize order for tasks - let sortTasks handle the default sorting
      // Only tasks that have been manually dragged will have manualOrder: true
      return;
    }

    function updateTaskOrderFromContainer(container) {
      const items = Array.from(container.querySelectorAll('.task-item'));
      const updates = [];

      items.forEach((item, index) => {
        const taskId = item.dataset.id;
        const task = tasks.find(t => t.id === taskId);
        if (!task) return;
        if (task.order !== index || !task.manualOrder) {
          task.order = index;
          task.manualOrder = true; // Mark as manually ordered when dragged
          updates.push(task);
        }
      });

      updates.forEach((task) => {
        const { id, ...cleanTask } = task;
        saveTask(task.id, cleanTask, task.subject);
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];
      let closest = { offset: Number.NEGATIVE_INFINITY, element: null };

      draggableElements.forEach(child => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          closest = { offset, element: child };
        }
      });

      return closest.element;
    }

    function clearTaskDragState() {
      document.querySelectorAll('.task-item.dragging').forEach(el => el.classList.remove('dragging'));
      document.querySelectorAll('.subject-list-header.drag-over, .subject-child-item.drag-over').forEach(el => {
        el.classList.remove('drag-over');
      });
      draggingTaskId = null;
      dragSourceContainer = null;
    }

    function assignTaskToSubject(taskId, subjectId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task || task.subject === subjectId) {
        clearTaskDragState();
        return;
      }

      // When moving tasks between own/shared, need to delete from old location and create in new
      const oldSubject = subjects.find(s => s.id === task.subject);
      const newSubject = subjects.find(s => s.id === subjectId);
      const wasShared = oldSubject?.isShared;
      const willBeShared = newSubject?.isShared;

      if (wasShared !== willBeShared) {
        // Moving between own and shared - need to delete from old and create in new
        const { id, isShared, ...cleanTask } = task;
        cleanTask.subject = subjectId || '';

        // Remove from old location
        removeTask(task);

        // Create in new location
        if (willBeShared) {
          const newTaskRef = push(ref(db, `sharedSubjects/${subjectId}/tasks`));
          set(newTaskRef, cleanTask);
        } else {
          const newTaskRef = push(tasksRef);
          set(newTaskRef, cleanTask);
        }
      } else {
        // Same type - just update the subject field
        const { id, ...cleanTask } = task;
        saveTask(taskId, { ...cleanTask, subject: subjectId || '' }, subjectId || task.subject);
      }
      clearTaskDragState();
    }

    function setupTaskDragAndDrop() {
      const containers = [activeTasks, completedTasks];

      containers.forEach(container => {
        if (!container) return;

        container.addEventListener('dragstart', (e) => {
          // Prevent drag on mobile to avoid click conflicts
          if (isMobile()) {
            e.preventDefault();
            return;
          }
          const item = e.target.closest('.task-item');
          if (!item) return;
          if (e.target.closest('input, textarea, select, button, a')) {
            e.preventDefault();
            return;
          }
          draggingTaskId = item.dataset.id;
          dragSourceContainer = container;
          item.classList.add('dragging');
          ensureTaskOrderInitialized();
          if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggingTaskId);
          }
        });

        container.addEventListener('dragover', (e) => {
          if (!draggingTaskId || dragSourceContainer !== container) return;
          e.preventDefault();
          const draggingEl = container.querySelector('.task-item.dragging');
          if (!draggingEl) return;
          const afterElement = getDragAfterElement(container, e.clientY);
          if (afterElement == null) {
            container.appendChild(draggingEl);
          } else if (afterElement !== draggingEl) {
            container.insertBefore(draggingEl, afterElement);
          }
        });

        container.addEventListener('drop', (e) => {
          if (!draggingTaskId || dragSourceContainer !== container) return;
          e.preventDefault();
          updateTaskOrderFromContainer(container);
          clearTaskDragState();
        });

        container.addEventListener('dragend', () => {
          clearTaskDragState();
        });
      });
    }

    setupTaskDragAndDrop();

    // Task countdown ticker
    function startTaskTicker() {
      if (taskTickerHandle) return;
      const tick = () => {
        document.querySelectorAll('.task-countdown[data-due]').forEach(el => {
          const dueDate = el.dataset.due;
          const countdown = calcTaskCountdown(dueDate);
          if (countdown) {
            el.textContent = countdown.text;
            el.className = 'task-countdown ' + (countdown.overdue ? 'overdue' : (countdown.urgency === 'soon' ? 'soon' : ''));
          }
        });
      };
      tick();
      taskTickerHandle = setInterval(tick, 10000); // Check every 10 seconds for accuracy
    }
    ctx.startTaskTicker = startTaskTicker;

    function checkTaskReminders(nowMs = Date.now()) {
      const state = reminderCheckState.tasks;
      const { start, isCatchup } = getReminderWindow(state.lastCheck, nowMs);
      const candidates = [];

      tasks.forEach(task => {
        if (task.completed) return;
        const reminderMinutes = parseInt(task.reminder, 10) || 0;
        if (!reminderMinutes) return;
        if (!task.dueDate) return;
        const reminderKey = `${task.dueDate}|${reminderMinutes}`;
        const entry = notifiedTasks.get(task.id);
        if (entry && entry.key === reminderKey) return;
        const taskTime = new Date(task.dueDate).getTime();
        if (!Number.isFinite(taskTime)) return;
        const triggerTime = taskTime - (reminderMinutes * 60000);
        if (triggerTime < start || triggerTime > nowMs) return;
        candidates.push({ task, reminderKey, triggerTime });
      });

      if (candidates.length) {
        if (isCatchup && candidates.length > REMINDER_CATCHUP_MAX_COUNT) {
          candidates.sort((a, b) => b.triggerTime - a.triggerTime);
          candidates.length = REMINDER_CATCHUP_MAX_COUNT;
        } else {
          candidates.sort((a, b) => a.triggerTime - b.triggerTime);
        }
        candidates.forEach(item => {
          triggerTaskAlert(item.task);
          notifiedTasks.set(item.task.id, { key: item.reminderKey, ts: nowMs });
        });
        persistNotifiedMap(NOTIFY_KEYS.TASKS, notifiedTasks);
      }

      state.lastCheck = nowMs;
      persistLastCheck(state, nowMs);
    }

    function startTaskReminderTicker() {
      if (taskReminderTickerHandle) return;
      checkTaskReminders();
      taskReminderTickerHandle = setInterval(checkTaskReminders, 10000);
    }

    async function triggerTaskAlert(task) {
      const dueDate = new Date(task.dueDate);
      const dateStr = dueDate.toLocaleDateString('he-IL', { weekday: 'long', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const title = `📋 תזכורת משימה: ${task.title}`;
      const message = `מועד יעד: ${dateStr}`;

      // Play sound
      if (reminderAudio) {
        reminderAudio.currentTime = 0;
        reminderAudio.play().catch(() => { });
      }

      // Show browser notification if permitted - use Service Worker for mobile compatibility
      showSystemNotification(title, {
        body: message,
        tag: `task-${task.id}`,
        renotify: true
      }).catch(() => { });

      // Show in-app alert
      showEventAlert(title, message, true);
    }

    function stopTaskTicker() {
      if (taskTickerHandle) {
        clearInterval(taskTickerHandle);
        taskTickerHandle = null;
      }
    }

    // Task Edit Modal
    function openTaskEditModal(taskId) {
      editingTaskId = taskId;
      editingTask = JSON.parse(JSON.stringify(tasks.find(t => t.id === taskId)));
      if (!editingTask) return;

      editTaskTitle.value = editingTask.title || '';
      editTaskContent.value = editingTask.content || '';

      // Set priority
      editTaskPriority.querySelectorAll('.priority-option').forEach(o => {
        o.classList.toggle('selected', o.dataset.priority === (editingTask.priority || 'none'));
      });

      setTaskColorSelection(taskColorPicker, editingTask.color || '');
      updateSubjectColorOption(taskColorPicker, getSubjectColorById(editingTask.subject || ''));

      // Set due date
      if (editingTask.dueDate) {
        editTaskDue.value = toLocalDatetime(editingTask.dueDate);
      } else {
        editTaskDue.value = '';
      }

      // Set duration
      if (editTaskDuration) {
        editTaskDuration.value = editingTask.duration || 0;
      }

      if (editTaskRecurrence) {
        editTaskRecurrence.value = normalizeRecurrence(editingTask.recurrence);
      }

      // Set reminder with custom support
      if (editTaskReminder) {
        setTaskReminderUI(editTaskReminder, editTaskReminderCustomWrap, editTaskReminderCustomValue, editTaskReminderCustomUnit, editingTask.reminder || 0);
      }

      // Render checklist
      renderEditChecklist();

      taskEditModal.classList.add('open');
    }

    function closeTaskEditModal() {
      taskEditModal.classList.remove('open');
      editingTaskId = null;
      editingTask = null;
    }
    ctx.closeTaskEditModal = closeTaskEditModal;

    taskEditModal.addEventListener('click', (e) => {
      if (e.target === taskEditModal) closeTaskEditModal();
    });

    // Edit modal priority picker
    editTaskPriority.addEventListener('click', (e) => {
      const option = e.target.closest('.priority-option');
      if (!option || !editingTask) return;
      editTaskPriority.querySelectorAll('.priority-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      editingTask.priority = option.dataset.priority;
    });

    bindTaskColorPicker(taskColorPicker, (color) => {
      if (editingTask) {
        editingTask.color = color || '';
      }
    });

    // Clear due date
    // Quick Date Options Handler
    const quickDateContainer = document.querySelector('.quick-date-options');
    if (quickDateContainer) {
      quickDateContainer.addEventListener('click', (e) => {
        if (!e.target.classList.contains('quick-date-btn')) return;
        const action = e.target.dataset.action;
        const now = new Date();
        let targetDate = new Date();

        switch (action) {
          case 'today':
            // Today at 23:59
            targetDate.setHours(23, 59, 0, 0);
            break;
          case 'tomorrow':
            // Tomorrow at 09:00
            targetDate.setDate(now.getDate() + 1);
            targetDate.setHours(9, 0, 0, 0);
            break;
          case 'nextWeek':
            // Next week (+7 days) at 09:00
            targetDate.setDate(now.getDate() + 7);
            targetDate.setHours(9, 0, 0, 0);
            break;
          case 'clear':
            if (editTaskDue) editTaskDue.value = '';
            return;
        }

        // Format to YYYY-MM-DDTHH:mm
        const year = targetDate.getFullYear();
        const month = String(targetDate.getMonth() + 1).padStart(2, '0');
        const day = String(targetDate.getDate()).padStart(2, '0');
        const hours = String(targetDate.getHours()).padStart(2, '0');
        const minutes = String(targetDate.getMinutes()).padStart(2, '0');

        if (editTaskDue) {
          editTaskDue.value = `${year}-${month}-${day}T${hours}:${minutes}`;
        }
      });
    }

    function renderEditChecklist() {
      if (!editingTask.checklist) editingTask.checklist = [];
      editTaskChecklist.innerHTML = editingTask.checklist.map((item, i) => `
      <div class="task-checklist-item ${item.checked ? 'checked' : ''}">
        <input type="checkbox" ${item.checked ? 'checked' : ''} data-index="${i}" />
        <span>${escapeHtml(item.text)}</span>
        <button class="task-action-btn delete" data-index="${i}" style="margin-left: auto;">×</button>
      </div>
    `).join('');

      // Add handlers
      editTaskChecklist.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('change', () => {
          const idx = parseInt(cb.dataset.index);
          editingTask.checklist[idx].checked = cb.checked;
          renderEditChecklist();
        });
      });

      editTaskChecklist.querySelectorAll('.task-action-btn.delete').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.dataset.index);
          editingTask.checklist.splice(idx, 1);
          renderEditChecklist();
        });
      });
    }

    addChecklistItem.onclick = () => {
      const text = newChecklistItem.value.trim();
      if (!text || !editingTask) return;
      editingTask.checklist.push({ text, checked: false });
      newChecklistItem.value = '';
      renderEditChecklist();
    };

    newChecklistItem.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addChecklistItem.click();
    });

    // Delete task
    deleteTaskBtn.onclick = () => {
      if (!editingTaskId) return;
      remove(ref(db, `users/${currentUser}/tasks/${editingTaskId}`));
      closeTaskEditModal();
    };

    if (duplicateTaskBtn) {
      duplicateTaskBtn.onclick = () => {
        if (!editingTask) return;
        pushTaskClone(editingTask);
        closeTaskEditModal();
      };
    }

    // Save task
    saveTaskBtn.onclick = () => {
      if (!editingTaskId || !editingTask) return;

      const oldSubjectId = editingTask.subject;
      const newSubjectId = editTaskSubject.value || '';

      editingTask.title = editTaskTitle.value.trim() || 'Untitled';
      editingTask.content = editTaskContent.value.trim();
      editingTask.subject = newSubjectId;
      editingTask.color = getTaskColorFromPicker(taskColorPicker) || '';
      const recurrenceValue = editTaskRecurrence ? editTaskRecurrence.value : 'none';
      if (recurrenceValue && recurrenceValue !== 'none') {
        editingTask.recurrence = recurrenceValue;
      } else {
        delete editingTask.recurrence;
      }

      // Update reminder (with custom support)
      const reminderValue = getTaskReminderMinutes(editTaskReminder, editTaskReminderCustomValue, editTaskReminderCustomUnit);
      if (reminderValue > 0) {
        editingTask.reminder = reminderValue;
      } else {
        delete editingTask.reminder;
      }

      // Update due date
      const dueValue = editTaskDue.value;
      if (dueValue) {
        const parsedDue = parseLocal(dueValue);
        editingTask.dueDate = parsedDue ? parsedDue.toISOString() : null;
      } else {
        editingTask.dueDate = null;
      }

      // Update duration
      if (editTaskDuration) {
        const durationValue = parseInt(editTaskDuration.value, 10) || 0;
        if (durationValue > 0) {
          editingTask.duration = durationValue;
        } else {
          delete editingTask.duration;
        }
      }

      // Check if moving between own/shared subjects
      const oldSubject = subjects.find(s => s.id === oldSubjectId);
      const newSubject = subjects.find(s => s.id === newSubjectId);
      const wasShared = oldSubject?.isShared || editingTask.isShared;
      const willBeShared = newSubject?.isShared;

      // Remove id and isShared before saving to Firebase
      const { id, isShared, ...cleanTask } = editingTask;

      if (wasShared !== willBeShared && oldSubjectId !== newSubjectId) {
        // Moving between own and shared - delete from old, create in new
        if (wasShared) {
          remove(ref(db, `sharedSubjects/${oldSubjectId}/tasks/${editingTaskId}`));
        } else {
          remove(ref(db, `users/${currentUser}/tasks/${editingTaskId}`));
        }

        if (willBeShared) {
          const newTaskRef = push(ref(db, `sharedSubjects/${newSubjectId}/tasks`));
          set(newTaskRef, cleanTask);
        } else {
          const newTaskRef = push(tasksRef);
          set(newTaskRef, cleanTask);
        }
      } else {
        // Same type - just update in place
        saveTask(editingTaskId, cleanTask, newSubjectId || oldSubjectId);
      }
      closeTaskEditModal();
    };

    // Enter key to save, Escape key to close for task edit modal
    [editTaskTitle, editTaskContent, editTaskDue].forEach(el => {
      if (el) {
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey && e.target.tagName !== 'TEXTAREA') {
            e.preventDefault();
            saveTaskBtn.click();
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            closeTaskEditModal();
          }
        });
      }
    });

    // Global Escape key handler for modals
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        // Close task edit modal if open
        if (taskEditModal && taskEditModal.style.display !== 'none' && taskEditModal.classList.contains('show')) {
          closeTaskEditModal();
          e.preventDefault();
          return;
        }
        // Close event edit modal if open
        if (eventModal && eventModal.style.display !== 'none') {
          eventModal.style.display = 'none';
          editingId = null;
          e.preventDefault();
          return;
        }
        // Close subject modal if open
        if (subjectModal && subjectModal.style.display !== 'none') {
          subjectModal.style.display = 'none';
          e.preventDefault();
          return;
        }
      }
    });

    // ============ SUBJECTS / CATEGORIES ============

    const cachedSubjectsKey = `${CACHE_KEYS.SUBJECTS_PREFIX}${currentUser}`;
    const cachedSubjects = readCache(cachedSubjectsKey);
    if (cachedSubjects && cachedSubjects.length) {
      subjects = cachedSubjects;
      syncCacheUsed.subjects = true;
      markSyncReady('subjects', 'cache');
      updateSyncBadge();
      renderSubjectsSidebar();
      updateSubjectSelectors();
      updateParentSubjectSelector();
    } else {
      startSyncTimeout('subjects', SUBJECTS_NO_CACHE_TIMEOUT_MS, 'no-cache', () => {
        renderSubjectsSidebar();
        updateSubjectSelectors();
        updateParentSubjectSelector();
      });
    }

    // Listen to subjects from Firebase
    startSyncTimeout('subjects', SYNC_TIMEOUT_MS, 'firebase', () => {
      renderSubjectsSidebar();
      updateSubjectSelectors();
      updateParentSubjectSelector();
    });

    // Own subjects
    let ownSubjects = [];
    // Shared subjects (from sharedSubjects where current user is a member)
    let sharedSubjects = [];

    function mergeSubjects() {
      // Combine own subjects with shared subjects
      subjects = [...ownSubjects, ...sharedSubjects];
      renderSubjectsSidebar();
      updateSubjectSelectors();
      updateParentSubjectSelector();
    }

    onValue(subjectsRef, (snapshot) => {
      clearSyncTimeouts('subjects');
      const data = snapshot.val();
      if (data) {
        ownSubjects = Object.keys(data).map(key => ({ id: key, ...data[key], isOwn: true }));
      } else {
        ownSubjects = [];
      }
      writeCache(cachedSubjectsKey, ownSubjects, 200);
      markSyncReady('subjects', 'firebase');
      mergeSubjects();
    }, (error) => {
      console.error('Subjects sync error:', error);
      clearSyncTimeouts('subjects');
      markSyncReady('subjects', 'error');
      updateSyncBadge();
    });

    // Listen to shared subjects
    const sharedSubjectsRef = ref(db, 'sharedSubjects');
    onValue(sharedSubjectsRef, (snapshot) => {
      const data = snapshot.val();
      if (data) {
        sharedSubjects = Object.keys(data)
          .map(key => ({ id: key, ...data[key], isShared: true }))
          .filter(s => {
            // Only include subjects where current user is owner or member
            const members = s.members || {};
            return s.owner === currentUser || members[currentUser];
          });
      } else {
        sharedSubjects = [];
      }
      mergeSubjects();
      // Also sync shared tasks
      syncSharedTasks();
    });

    // Shared tasks storage
    let sharedTasks = [];
    let sharedTasksListeners = []; // Store unsubscribe functions

    function syncSharedTasks() {
      // Unsubscribe from previous listeners
      sharedTasksListeners.forEach(unsub => unsub());
      sharedTasksListeners = [];
      sharedTasks = [];

      // Set up listeners for each shared subject's tasks
      sharedSubjects.forEach(subject => {
        const tasksRef = ref(db, `sharedSubjects/${subject.id}/tasks`);
        const unsubscribe = onValue(tasksRef, (snap) => {
          const tasksData = snap.val();
          // Remove old tasks for this subject
          sharedTasks = sharedTasks.filter(t => t.subject !== subject.id);
          // Add new tasks
          if (tasksData) {
            Object.keys(tasksData).forEach(taskId => {
              sharedTasks.push({
                id: taskId,
                ...tasksData[taskId],
                subject: subject.id,
                isShared: true
              });
            });
          }
          mergeTasks();
        });
        sharedTasksListeners.push(unsubscribe);
      });

      // If no shared subjects, just merge
      if (sharedSubjects.length === 0) {
        mergeTasks();
      }
    }

    // Own tasks storage
    let ownTasks = [];
    Object.defineProperty(ctx, 'ownTasks', { get: () => ownTasks, set: (val) => { ownTasks = val; } });

    function mergeTasks() {
      tasks = [...ownTasks, ...sharedTasks];
      if (taskManagerOverlay.classList.contains('open')) {
        renderTasks();
      }
      // Update daily planner if open
      if (typeof DailyPlanner !== 'undefined' && DailyPlanner.refreshTasks) {
        DailyPlanner.refreshTasks();
      }
    }
    ctx.mergeTasks = mergeTasks;

    // Get top-level subjects (no parent)
    function getTopLevelSubjects() {
      return subjects.filter(s => !s.parentId);
    }

    // Get children of a subject
    function getChildSubjects(parentId) {
      return subjects.filter(s => s.parentId === parentId);
    }

    // Count tasks for a subject including children
    function countSubjectTasks(subjectId, includeChildren = true) {
      let count = tasks.filter(t => t.subject === subjectId && !t.completed).length;
      if (includeChildren) {
        const children = getChildSubjects(subjectId);
        children.forEach(c => {
          count += tasks.filter(t => t.subject === c.id && !t.completed).length;
        });
      }
      return count;
    }

    // ============ SMART VIEWS COUNTS ============
    function updateSmartViewCounts() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const weekLater = new Date(today);
      weekLater.setDate(weekLater.getDate() + 7);

      const activeTasks = tasks.filter(t => !t.completed);

      const allCount = activeTasks.length;
      const todayCount = activeTasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        return due >= today && due < tomorrow;
      }).length;
      const tomorrowCount = activeTasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        return due >= tomorrow && due < weekLater && due < new Date(tomorrow.getTime() + 86400000); // Only exactly tomorrow
      }).length;

      const weekCount = activeTasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        return due >= today && due < weekLater;
      }).length;
      const overdueCount = activeTasks.filter(t => {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        return due < now; // Use 'now' for accurate overdue detection
      }).length;
      const noDateCount = activeTasks.filter(t => !t.dueDate).length;

      // Update counts
      const countAll = $('countAll');
      const countToday = $('countToday');
      const countTomorrow = $('countTomorrow');
      const countWeek = $('countWeek');
      const countOverdue = $('countOverdue');
      const countNoDate = $('countNoDate');

      if (countAll) countAll.textContent = allCount;
      if (countToday) countToday.textContent = todayCount;
      if (countTomorrow) countTomorrow.textContent = tomorrowCount;
      if (countWeek) countWeek.textContent = weekCount;
      if (countOverdue) countOverdue.textContent = overdueCount;
      if (countNoDate) countNoDate.textContent = noDateCount;
    }

    // ============ TASK CALENDAR ============
    let currentTaskMonth = new Date();
    Object.defineProperty(ctx, 'currentTaskMonth', { get: () => currentTaskMonth, set: (val) => { currentTaskMonth = val; } });
    let taskCalendarExpanded = false;
    let taskCalendarView = 'month';
    let taskCalendarFocusDate = new Date();
    const taskCalendarGrid = $("taskCalendarGrid");
    const taskCalendarTitle = $("taskCalendarTitle");
    const taskMonthEvents = $("taskMonthEvents");
    const taskMonthEventsTitle = $("taskMonthEventsTitle");
    const toggleTaskCalendarSize = $("toggleTaskCalendarSize");
    const taskCalendarViewToggle = $("taskCalendarViewToggle");
    const taskRightSidebar = $("taskRightSidebar");

    // Event delegation for Task calendar in Task Manager
    if (taskCalendarGrid) {
      taskCalendarGrid.addEventListener('click', (e) => {
        const chip = e.target.closest('.calendar-event-chip');
        if (chip) {
          e.stopPropagation();
          const taskId = chip.dataset.taskId;
          if (taskId) {
            const taskRow = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (taskRow) {
              taskRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
              taskRow.style.transition = 'box-shadow 0.3s';
              taskRow.style.boxShadow = '0 0 0 3px var(--accent)';
              setTimeout(() => { taskRow.style.boxShadow = ''; }, 800);
            }
          }
          return;
        }

        const day = e.target.closest('.calendar-day:not(.other-month)');
        if (day) {
          const dateKey = day.dataset.date;
          if (!dateKey) return;
          const focusDate = new Date(`${dateKey}T00:00`);
          if (!Number.isNaN(focusDate.getTime())) {
            setTaskCalendarFocus(focusDate);
          }
          const taskDueInput = $("newTaskDue");
          const taskTitleInput = $("newTaskTitle");
          const quickRow = $("quickAddRow");
          if (taskDueInput) taskDueInput.value = dateKey + 'T23:59';
          if (taskTitleInput) taskTitleInput.focus();
          if (quickRow) quickRow.style.display = 'flex';
          if (quickAddTask) {
            quickAddTask.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      });
    }

    function getTaskCalendarMaxShow() {
      if (taskCalendarView === 'day') return taskCalendarExpanded ? 15 : 8;
      if (taskCalendarView === 'week') return taskCalendarExpanded ? 8 : 4;
      return taskCalendarExpanded ? 5 : 3;
    }

    function updateTaskCalendarViewToggle() {
      if (!taskCalendarViewToggle) return;
      taskCalendarViewToggle.querySelectorAll('button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === taskCalendarView);
      });
    }

    function updateTaskCalendarViewClasses() {
      if (!taskRightSidebar) return;
      taskRightSidebar.classList.toggle('calendar-view-week', taskCalendarView === 'week');
      taskRightSidebar.classList.toggle('calendar-view-day', taskCalendarView === 'day');
    }

    function setTaskCalendarView(view) {
      const prevView = taskCalendarView;
      taskCalendarView = view;
      if (taskCalendarView === 'month') {
        currentTaskMonth = new Date(taskCalendarFocusDate.getFullYear(), taskCalendarFocusDate.getMonth(), 1);
      } else if (prevView === 'month') {
        const base = new Date(currentTaskMonth.getFullYear(), currentTaskMonth.getMonth(), taskCalendarFocusDate.getDate() || 1);
        setTaskCalendarFocus(base);
      }
      updateTaskCalendarViewToggle();
      updateTaskCalendarViewClasses();
      renderTaskCalendar();
    }

    function setTaskCalendarFocus(date) {
      const d = new Date(date);
      if (Number.isNaN(d.getTime())) return;
      d.setHours(0, 0, 0, 0);
      taskCalendarFocusDate = d;
    }

    function getStartOfWeek(date) {
      const d = new Date(date);
      const dayIndex = d.getDay();
      d.setDate(d.getDate() - dayIndex);
      d.setHours(0, 0, 0, 0);
      return d;
    }

    function formatHebrewShortDate(date) {
      return date.toLocaleDateString('he-IL', { day: 'numeric', month: 'short' });
    }
    Object.assign(ctx, { getStartOfWeek, formatHebrewShortDate });

    function renderTaskCalendar() {
      if (!taskCalendarGrid || !taskCalendarTitle) return;

      updateTaskCalendarViewToggle();
      updateTaskCalendarViewClasses();

      const today = new Date();
      const todayKey = toDateKey(today);

      // Build task map by date (exclude countdowns/events)
      const tasksByDate = {};
      tasks.forEach(task => {
        if (!task.dueDate) return;
        if (task.isCountdown || task.isEvent) return;
        const key = toDateKey(task.dueDate);
        if (!tasksByDate[key]) tasksByDate[key] = [];
        tasksByDate[key].push(task);
      });

      let html = '';
      const maxShow = getTaskCalendarMaxShow();

      if (taskCalendarView === 'month') {
        const year = currentTaskMonth.getFullYear();
        const month = currentTaskMonth.getMonth();
        taskCalendarTitle.textContent = `${HEBREW_MONTHS[month]} ${year}`;

        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const startDay = firstDay.getDay();
        const daysInMonth = lastDay.getDate();

        for (let i = 0; i < 7; i++) {
          html += `<div class="calendar-day-name">${HEBREW_DAYS[i]}</div>`;
        }

        const prevMonth = new Date(year, month, 0);
        const prevDays = prevMonth.getDate();
        for (let i = startDay - 1; i >= 0; i--) {
          const day = prevDays - i;
          html += `<div class="calendar-day other-month"><div class="calendar-day-number">${day}</div></div>`;
        }

        for (let day = 1; day <= daysInMonth; day++) {
          const dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          const isToday = dateKey === todayKey;
          const dayTasks = tasksByDate[dateKey] || [];
          let classes = 'calendar-day';
          if (isToday) classes += ' today';

          let eventsHtml = '<div class="calendar-day-events">';
          const showTime = dayTasks.length > 1;
          dayTasks.slice(0, maxShow).forEach(task => {
            const subjectColor = subjects.find(s => s.id === task.subject)?.color;
            const resolvedColor = resolveTaskColor(task, subjectColor);
            const color = resolvedColor || subjectColor || '#667eea';
            const safeName = escapeHtml(task.title);
            const evtDate = new Date(task.dueDate);
            const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2, '0')}:${String(evtDate.getMinutes()).padStart(2, '0')} ` : '';
            const displayText = timeStr + safeName;
            eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-task-id="${task.id}">${displayText}</div>`;
          });
          if (dayTasks.length > maxShow) {
            eventsHtml += `<div class="calendar-more">+${dayTasks.length - maxShow} עוד</div>`;
          }
          eventsHtml += '</div>';

          html += `<div class="${classes}" data-date="${dateKey}">
          <div class="calendar-day-number">${day}</div>
          ${eventsHtml}
        </div>`;
        }

        const totalCells = startDay + daysInMonth;
        const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
        for (let i = 1; i <= remainingCells; i++) {
          html += `<div class="calendar-day other-month"><div class="calendar-day-number">${i}</div></div>`;
        }
      } else if (taskCalendarView === 'week') {
        const focus = taskCalendarFocusDate || new Date();
        const start = getStartOfWeek(focus);
        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        taskCalendarTitle.textContent = `שבוע ${formatHebrewShortDate(start)} - ${formatHebrewShortDate(end)}`;

        for (let i = 0; i < 7; i++) {
          const dayDate = new Date(start);
          dayDate.setDate(start.getDate() + i);
          html += `<div class="calendar-day-name">${HEBREW_DAYS[dayDate.getDay()]}</div>`;
        }

        for (let i = 0; i < 7; i++) {
          const dayDate = new Date(start);
          dayDate.setDate(start.getDate() + i);
          const dateKey = toDateKey(dayDate);
          const dayTasks = tasksByDate[dateKey] || [];
          const isToday = dateKey === todayKey;
          const isOtherMonth = dayDate.getMonth() !== focus.getMonth();
          let classes = 'calendar-day';
          if (isToday) classes += ' today';
          if (isOtherMonth) classes += ' other-month';

          let eventsHtml = '<div class="calendar-day-events">';
          const showTime = true;
          dayTasks.slice(0, maxShow).forEach(task => {
            const subjectColor = subjects.find(s => s.id === task.subject)?.color;
            const resolvedColor = resolveTaskColor(task, subjectColor);
            const color = resolvedColor || subjectColor || '#667eea';
            const safeName = escapeHtml(task.title);
            const evtDate = new Date(task.dueDate);
            const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2, '0')}:${String(evtDate.getMinutes()).padStart(2, '0')} ` : '';
            const displayText = timeStr + safeName;
            eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-task-id="${task.id}">${displayText}</div>`;
          });
          if (dayTasks.length > maxShow) {
            eventsHtml += `<div class="calendar-more">+${dayTasks.length - maxShow} עוד</div>`;
          }
          eventsHtml += '</div>';

          html += `<div class="${classes}" data-date="${dateKey}">
          <div class="calendar-day-number">${dayDate.getDate()}</div>
          ${eventsHtml}
        </div>`;
        }
      } else {
        const focus = taskCalendarFocusDate || new Date();
        const dateKey = toDateKey(focus);
        taskCalendarTitle.textContent = focus.toLocaleDateString('he-IL', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
        html += `<div class="calendar-day-name">${HEBREW_DAYS[focus.getDay()]}</div>`;

        const dayTasks = tasksByDate[dateKey] || [];
        const isToday = dateKey === todayKey;
        let classes = 'calendar-day';
        if (isToday) classes += ' today';

        let eventsHtml = '<div class="calendar-day-events">';
        const showTime = true;
        dayTasks.slice(0, maxShow).forEach(task => {
          const subjectColor = subjects.find(s => s.id === task.subject)?.color;
          const resolvedColor = resolveTaskColor(task, subjectColor);
          const color = resolvedColor || subjectColor || '#667eea';
          const safeName = escapeHtml(task.title);
          const evtDate = new Date(task.dueDate);
          const timeStr = showTime ? `${String(evtDate.getHours()).padStart(2, '0')}:${String(evtDate.getMinutes()).padStart(2, '0')} ` : '';
          const displayText = timeStr + safeName;
          eventsHtml += `<div class="calendar-event-chip" style="background: ${color}" title="${safeName}" aria-label="${safeName}" data-task-id="${task.id}">${displayText}</div>`;
        });
        if (dayTasks.length > maxShow) {
          eventsHtml += `<div class="calendar-more">+${dayTasks.length - maxShow} עוד</div>`;
        }
        eventsHtml += '</div>';

        html += `<div class="${classes}" data-date="${dateKey}">
        <div class="calendar-day-number">${focus.getDate()}</div>
        ${eventsHtml}
      </div>`;
      }

      taskCalendarGrid.innerHTML = html;
      renderTaskMonthList();
    }
    ctx.renderTaskCalendar = renderTaskCalendar;

    function renderTaskMonthList() {
      if (!taskMonthEvents || !taskMonthEventsTitle) return;

      let rangeStart;
      let rangeEnd;
      let titleText = '';
      let emptyText = 'אין משימות בטווח';

      if (taskCalendarView === 'month') {
        const year = currentTaskMonth.getFullYear();
        const month = currentTaskMonth.getMonth();
        rangeStart = new Date(year, month, 1);
        rangeEnd = new Date(year, month + 1, 0, 23, 59, 59, 999);
        titleText = `משימות (ללא ספירות לאחור) ${HEBREW_MONTHS[month]}`;
        emptyText = 'אין משימות החודש';
      } else if (taskCalendarView === 'week') {
        const focus = taskCalendarFocusDate || new Date();
        const start = getStartOfWeek(focus);
        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        rangeStart = start;
        rangeEnd = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59, 999);
        titleText = `משימות לשבוע ${formatHebrewShortDate(start)} - ${formatHebrewShortDate(end)}`;
        emptyText = 'אין משימות השבוע';
      } else {
        const focus = taskCalendarFocusDate || new Date();
        rangeStart = new Date(focus.getFullYear(), focus.getMonth(), focus.getDate());
        rangeEnd = new Date(focus.getFullYear(), focus.getMonth(), focus.getDate(), 23, 59, 59, 999);
        titleText = `משימות ליום ${focus.toLocaleDateString('he-IL', { day: 'numeric', month: 'long' })}`;
        emptyText = 'אין משימות היום';
      }

      taskMonthEventsTitle.textContent = titleText;

      const rangeTasks = tasks.filter(t => {
        if (!t.dueDate) return false;
        if (t.isCountdown || t.isEvent) return false;
        const d = new Date(t.dueDate);
        return d >= rangeStart && d <= rangeEnd;
      }).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));

      if (rangeTasks.length === 0) {
        taskMonthEvents.innerHTML = `<div class="no-events-msg">${emptyText}</div>`;
        return;
      }

      taskMonthEvents.innerHTML = rangeTasks.map(task => {
        const subjectColor = subjects.find(s => s.id === task.subject)?.color;
        const resolvedColor = resolveTaskColor(task, subjectColor);
        const color = resolvedColor || subjectColor || '#667eea';
        const d = new Date(task.dueDate);
        const dateStr = d.toLocaleDateString('he-IL', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
        return `
        <div class="month-event-item" style="border-right-color: ${color}">
          <div class="month-event-color" style="background: ${color}"></div>
          <div class="month-event-info">
            <div class="month-event-name" style="${task.completed ? 'text-decoration: line-through; opacity: 0.7;' : ''}">${escapeHtml(task.title)}</div>
            <div class="month-event-date">${dateStr}</div>
          </div>
        </div>
      `;
      }).join('');
    }

    function shiftTaskCalendar(step) {
      if (taskCalendarView === 'month') {
        currentTaskMonth.setMonth(currentTaskMonth.getMonth() + step);
        setTaskCalendarFocus(new Date(currentTaskMonth.getFullYear(), currentTaskMonth.getMonth(), 1));
      } else if (taskCalendarView === 'week') {
        const next = new Date(taskCalendarFocusDate);
        next.setDate(next.getDate() + step * 7);
        setTaskCalendarFocus(next);
      } else {
        const next = new Date(taskCalendarFocusDate);
        next.setDate(next.getDate() + step);
        setTaskCalendarFocus(next);
      }
      renderTaskCalendar();
    }

    function jumpTaskCalendarToToday() {
      const today = new Date();
      currentTaskMonth = new Date(today.getFullYear(), today.getMonth(), 1);
      setTaskCalendarFocus(today);
      renderTaskCalendar();
    }

    // Task Calendar Navigation
    $("prevTaskMonth").onclick = () => {
      shiftTaskCalendar(-1);
    };
    if (taskCalendarViewToggle) {
      taskCalendarViewToggle.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-view]');
        if (!btn) return;
        setTaskCalendarView(btn.dataset.view);
      });
    }

    // Toggle Task Calendar
    const toggleTaskCalendar = $("toggleTaskCalendar");
    if (toggleTaskCalendarSize && taskRightSidebar) {
      toggleTaskCalendarSize.onclick = () => {
        taskCalendarExpanded = !taskCalendarExpanded;
        taskRightSidebar.classList.toggle('calendar-expanded', taskCalendarExpanded);
        toggleTaskCalendarSize.textContent = taskCalendarExpanded ? '⤡' : '⤢';
        const label = taskCalendarExpanded ? 'הקטן' : 'הגדל';
        toggleTaskCalendarSize.title = label;
        toggleTaskCalendarSize.setAttribute('aria-label', label);
        renderTaskCalendar();
      };
    }
    if (toggleTaskCalendar && taskRightSidebar) {
      toggleTaskCalendar.onclick = () => {
        console.log('toggleTaskCalendar clicked');
        const wasHidden = taskRightSidebar.classList.contains("hidden") || getComputedStyle(taskRightSidebar).display === 'none';
        console.log('taskRightSidebar wasHidden=', wasHidden);
        if (wasHidden) {
          taskRightSidebar.classList.remove('hidden');
          taskRightSidebar.style.display = '';
          jumpTaskCalendarToToday();
        } else {
          taskRightSidebar.classList.add('hidden');
          taskRightSidebar.style.display = 'none';
        }
      };
    }
    // Toggle Task Manager Sidebar (subjects)
    const toggleTaskSidebarBtn = $("toggleTaskSidebar");
    const taskSidebar = $("taskSidebar");
    if (toggleTaskSidebarBtn && taskSidebar) {
      toggleTaskSidebarBtn.onclick = () => {
        console.log('toggleTaskSidebar clicked');
        const wasHidden = taskSidebar.classList.contains('hidden') || getComputedStyle(taskSidebar).display === 'none';
        console.log('taskSidebar wasHidden=', wasHidden);
        if (wasHidden) {
          taskSidebar.classList.remove('hidden');
          taskSidebar.style.display = '';
        } else {
          taskSidebar.classList.add('hidden');
          taskSidebar.style.display = 'none';
        }
      };
    }
    $("nextTaskMonth").onclick = () => {
      shiftTaskCalendar(1);
    };
    $("todayTaskBtn").onclick = () => {
      jumpTaskCalendarToToday();
    };



















    // ============ SIDEBAR SUBJECTS RENDERING ============
    function renderSubjectsSidebar() {
      if (!subjectsList) return;

      updateSmartViewCounts();

      let html = '';
      const topLevel = getTopLevelSubjects();

      topLevel.forEach(s => {
        const children = getChildSubjects(s.id);
        const hasChildren = children.length > 0;
        const isExpanded = expandedSubjects.has(s.id);
        const isActive = currentSubject === s.id && !currentSmartView;
        const taskCount = countSubjectTasks(s.id, true);
        const isShared = s.isShared;
        const sharedBadge = isShared ? `<span class="shared-badge" title="משותף">👥</span>` : '';

        html += `
        <div class="subject-list-item ${isExpanded ? 'expanded' : ''}" data-subject-id="${s.id}">
          <div class="subject-list-header ${isActive ? 'active' : ''}" data-subject="${s.id}" title="${escapeHtml(s.name)}">
            ${hasChildren ? `<span class="collapse-arrow">▼</span>` : ''}
            ${sharedBadge}
            ${taskCount > 0 ? `<span class="subject-count">${taskCount}</span>` : ''}
            <span class="subject-color-dot" style="background: ${s.color};"></span>
            <span class="subject-name">${escapeHtml(s.name)}</span>
            <div class="subject-actions">
              <button class="subject-action-btn" data-action="add-sub" title="הוסף תת-נושא" aria-label="הוסף תת-נושא">➕</button>
              <button class="subject-action-btn" data-action="edit" title="עריכה" aria-label="עריכה">✏️</button>
              <button class="subject-action-btn delete" data-action="delete" title="מחק" aria-label="מחק">🗑️</button>
            </div>
          </div>
          ${hasChildren ? `
            <div class="subject-list-children">
              ${children.map(c => {
          const childCount = tasks.filter(t => t.subject === c.id && !t.completed).length;
          const childActive = currentSubject === c.id && !currentSmartView;
          const childShared = c.isShared;
          const childSharedBadge = childShared ? `<span class="shared-badge" title="משותף">👥</span>` : '';
          return `
                  <div class="subject-child-item ${childActive ? 'active' : ''}" data-subject="${c.id}" title="${escapeHtml(c.name)}">
                    ${childSharedBadge}
                    ${childCount > 0 ? `<span class="child-count">${childCount}</span>` : ''}
                    <span class="child-color" style="background: ${c.color};"></span>
                    <span class="child-name">${escapeHtml(c.name)}</span>
                    <div class="subject-actions">
                      <button class="subject-action-btn" data-action="edit" title="עריכה">✏️</button>
                      <button class="subject-action-btn delete" data-action="delete" title="מחק">🗑️</button>
                    </div>
                  </div>
                `;
        }).join('')}
            </div>
          ` : ''}
        </div>
      `;
      });

      subjectsList.innerHTML = html;

      // Setup event handlers
      setupSubjectsSidebarHandlers();
      setupSmartViewsHandlers();
    }
    ctx.renderSubjectsSidebar = renderSubjectsSidebar;

    function setupSubjectsSidebarHandlers() {
      // Subject headers click - toggle collapse OR select subject
      subjectsList.querySelectorAll('.subject-list-header').forEach(header => {
        header.addEventListener('click', (e) => {
          // Don't do anything if clicking action buttons
          if (e.target.closest('.subject-actions')) {
            return;
          }

          const subjectId = header.dataset.subject;

          // Always select the subject
          currentSmartView = null;
          currentSubject = subjectId;
          syncQuickAddSubject();
          renderSubjectsSidebar();
          renderTasks();
        });

        // Right-click context menu
        header.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showContextMenu(e.clientX, e.clientY, header.dataset.subject);
        });

        attachSubjectDropHandlers(header, header.dataset.subject);
      });

      // Collapse arrows - clicking arrow only toggles (doesn't select)
      subjectsList.querySelectorAll('.collapse-arrow').forEach(arrow => {
        arrow.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent header click from also firing
          const subjectId = arrow.closest('.subject-list-item').dataset.subjectId;
          toggleSubjectExpanded(subjectId);
        });
      });

      // Subject action buttons (edit, delete, add-sub)
      subjectsList.querySelectorAll('.subject-action-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const action = btn.dataset.action;
          const subjectId = btn.closest('[data-subject]').dataset.subject;

          if (action === 'edit') {
            openSubjectModal(subjectId);
          } else if (action === 'add-sub') {
            openSubjectModal(null, subjectId);
          } else if (action === 'delete') {
            if (confirm('האם אתה בטוח שברצונך למחוק את הנושא הזה?')) {
              deleteSubjectById(subjectId);
            }
          }
        });
      });

      // Child items click
      subjectsList.querySelectorAll('.subject-child-item').forEach(child => {
        child.addEventListener('click', (e) => {
          // Don't select if clicking action buttons
          if (e.target.closest('.subject-actions')) {
            return;
          }

          currentSmartView = null;
          currentSubject = child.dataset.subject;
          syncQuickAddSubject();
          renderSubjectsSidebar();
          renderTasks();
        });

        // Right-click context menu
        child.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showContextMenu(e.clientX, e.clientY, child.dataset.subject);
        });

        attachSubjectDropHandlers(child, child.dataset.subject);
      });
    }

    function attachSubjectDropHandlers(element, subjectId) {
      if (!element) return;
      element.addEventListener('dragover', (e) => {
        if (!draggingTaskId) return;
        e.preventDefault();
        element.classList.add('drag-over');
      });
      element.addEventListener('dragleave', () => {
        element.classList.remove('drag-over');
      });
      element.addEventListener('drop', (e) => {
        if (!draggingTaskId) return;
        e.preventDefault();
        element.classList.remove('drag-over');
        assignTaskToSubject(draggingTaskId, subjectId);
      });
    }

    function toggleSubjectExpanded(subjectId) {
      const item = subjectsList.querySelector(`.subject-list-item[data-subject-id="${subjectId}"]`);

      if (expandedSubjects.has(subjectId)) {
        expandedSubjects.delete(subjectId);
        if (item) item.classList.remove('expanded');
      } else {
        expandedSubjects.add(subjectId);
        if (item) item.classList.add('expanded');
      }
    }

    function setupSmartViewsHandlers() {
      if (!smartViewsList) return;

      // Clone and replace to remove all old event listeners
      smartViewsList.querySelectorAll('.smart-view-item').forEach(item => {
        const newItem = item.cloneNode(true);
        item.parentNode.replaceChild(newItem, item);
      });

      smartViewsList.querySelectorAll('.smart-view-item').forEach(item => {
        item.addEventListener('click', () => {
          const view = item.dataset.view;
          if (view === 'all') {
            currentSmartView = null;
            currentSubject = 'all';
          } else {
            currentSmartView = view;
            currentSubject = 'all';
          }
          syncQuickAddSubject();

          // Update active states
          smartViewsList.querySelectorAll('.smart-view-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');

          renderSubjectsSidebar();
          renderTasks();
        });
      });

      // Set initial active state
      const activeView = currentSmartView || 'all';
      smartViewsList.querySelectorAll('.smart-view-item').forEach(item => {
        item.classList.toggle('active', item.dataset.view === activeView);
      });
    }

    // Add subject sidebar button handler
    if (addSubjectSidebarBtn) {
      addSubjectSidebarBtn.addEventListener('click', () => openSubjectModal());
    }
    // Add subject button in header
    if (addSubjectBtn) {
      addSubjectBtn.addEventListener('click', () => {
        console.log('addSubjectBtn clicked');
        openSubjectModal();
      });
    }

    // ============ CONTEXT MENU ============
    function showContextMenu(x, y, subjectId) {
      contextMenuTarget = subjectId;
      const subject = subjects.find(s => s.id === subjectId);

      // Update menu items based on subject type
      const addSubItem = contextMenu.querySelector('[data-action="add-sub"]');
      if (subject && subject.parentId) {
        // It's a sub-subject, hide "add sub" option
        addSubItem.style.display = 'none';
      } else {
        addSubItem.style.display = 'flex';
      }

      // Position and show menu
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.classList.add('open');
    }

    function hideContextMenu() {
      contextMenu.classList.remove('open');
      contextMenuTarget = null;
      hideEventContextMenu();
    }

    // ============ EVENT CONTEXT MENU ============
    function showEventContextMenu(x, y, eventId) {
      eventContextMenuTarget = eventId;
      const evt = events.find(e => e.id === eventId);

      // Update menu items based on current state
      const starItem = eventContextMenu.querySelector('[data-action="star"]');
      const pinItem = eventContextMenu.querySelector('[data-action="pin"]');

      if (starItem && evt) {
        starItem.innerHTML = evt.highlighted ? '⭐ הסר מועדף' : '⭐ סמן כמועדף';
      }

      if (pinItem && evt) {
        pinItem.innerHTML = evt.pinned ? '📌 בטל נעיצה' : '📌 נעץ למעלה';
      }

      // Position and show menu
      eventContextMenu.style.left = x + 'px';
      eventContextMenu.style.top = y + 'px';
      eventContextMenu.classList.add('open');
    }

    function hideEventContextMenu() {
      if (eventContextMenu) {
        eventContextMenu.classList.remove('open');
      }
      eventContextMenuTarget = null;
      hideAddEventContextMenu();
    }

    // ============ ADD EVENT CONTEXT MENU ============
    const addEventContextMenu = $("addEventContextMenu");

    function showAddEventContextMenu(x, y) {
      if (!addEventContextMenu) return;

      // Position and show menu
      addEventContextMenu.style.left = x + 'px';
      addEventContextMenu.style.top = y + 'px';
      addEventContextMenu.classList.add('open');
    }

    function hideAddEventContextMenu() {
      if (addEventContextMenu) {
        addEventContextMenu.classList.remove('open');
      }
    }
    Object.assign(ctx, {
      hideContextMenu,
      hideEventContextMenu,
      hideAddEventContextMenu
    });

    // Add event context menu item clicks
    if (addEventContextMenu) {
      addEventContextMenu.addEventListener('click', (e) => {
        const action = e.target.closest('.context-menu-item')?.dataset.action;
        if (!action) return;

        const now = new Date();
        let targetDate = new Date();

        if (action === 'add') {
          // Focus on the input panel
          eventName.focus();
          hideAddEventContextMenu();
          return;
        } else if (action === 'add-tomorrow') {
          targetDate.setDate(targetDate.getDate() + 1);
          targetDate.setHours(12, 0, 0, 0);
        } else if (action === 'add-week') {
          targetDate.setDate(targetDate.getDate() + 7);
          targetDate.setHours(12, 0, 0, 0);
        }

        // Pre-fill the date - format from local date directly (not via ISO/UTC)
        const pad = n => String(n).padStart(2, '0');
        const localDateStr = `${targetDate.getFullYear()}-${pad(targetDate.getMonth() + 1)}-${pad(targetDate.getDate())}T${pad(targetDate.getHours())}:${pad(targetDate.getMinutes())}`;
        eventDate.value = localDateStr;
        eventName.focus();

        hideAddEventContextMenu();
      });
    }

    // Add right-click on event list area to show add event menu
    eventList.addEventListener('contextmenu', (e) => {
      // Only show add menu if not clicking on an event row
      if (!e.target.closest('.event-row')) {
        e.preventDefault();
        hideContextMenu();
        showAddEventContextMenu(e.clientX, e.clientY);
      }
    });

    // Also add to empty state
    emptyState.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      hideContextMenu();
      showAddEventContextMenu(e.clientX, e.clientY);
    });

    // Event context menu item clicks
    if (eventContextMenu) {
      eventContextMenu.addEventListener('click', (e) => {
        const action = e.target.closest('.context-menu-item')?.dataset.action;
        if (!action || !eventContextMenuTarget) return;

        const evt = events.find(ev => ev.id === eventContextMenuTarget);

        if (action === 'edit') {
          startEdit(eventContextMenuTarget);
        } else if (action === 'pin') {
          if (evt) {
            updateInCloud(eventContextMenuTarget, { ...evt, pinned: !evt.pinned });
          }
        } else if (action === 'star') {
          if (evt) {
            updateInCloud(eventContextMenuTarget, { ...evt, highlighted: !evt.highlighted });
          }
        } else if (action === 'duplicate') {
          if (evt) {
            saveToCloud({
              name: evt.name + ' (העתק)',
              date: evt.date,
              notes: evt.notes || null,
              reminder: evt.reminder || 0,
              highlighted: false,
              pinned: false
            });
          }
        } else if (action === 'delete') {
          const existing = pendingDeletes.get(eventContextMenuTarget);
          if (existing) clearTimeout(existing.timer);
          const timer = setTimeout(() => {
            deleteFromCloud(eventContextMenuTarget);
            pendingDeletes.delete(eventContextMenuTarget);
            if (lastDeletedId === eventContextMenuTarget) hideUndoToast();
          }, DELETE_TIMEOUT_MS);
          pendingDeletes.set(eventContextMenuTarget, { timer });
          render();
          showUndoToast(evt ? evt.name : 'Event', eventContextMenuTarget);
        }

        hideEventContextMenu();
      });
    }

    // Context menu item clicks (subjects)
    contextMenu.addEventListener('click', (e) => {
      const action = e.target.closest('.context-menu-item')?.dataset.action;
      if (!action || !contextMenuTarget) return;

      if (action === 'edit') {
        openSubjectModal(contextMenuTarget);
      } else if (action === 'share') {
        openShareSubjectModal(contextMenuTarget);
      } else if (action === 'add-sub') {
        openSubjectModal(null, contextMenuTarget);
      } else if (action === 'delete') {
        deleteSubjectById(contextMenuTarget);
      }

      hideContextMenu();
    });

    // Hide context menu on click outside
    document.addEventListener('click', (e) => {
      if (!contextMenu.contains(e.target) &&
        (!eventContextMenu || !eventContextMenu.contains(e.target)) &&
        (!addEventContextMenu || !addEventContextMenu.contains(e.target))) {
        hideContextMenu();
        hideAddEventContextMenu();
      }
    });

    document.addEventListener('contextmenu', (e) => {
      // Hide menus when right-clicking elsewhere
      if (!e.target.closest('.subject-list-header') && !e.target.closest('.subject-child-item')) {
        hideContextMenu();
      }
      if (!e.target.closest('.event-row') && !e.target.closest('.event-list') && !e.target.closest('.empty-state')) {
        hideEventContextMenu();
        hideAddEventContextMenu();
      }
    });

    function updateSubjectSelectors() {
      // Build hierarchical options for task subject selectors
      let options = `<option value="">ללא נושא</option>`;

      const topLevel = getTopLevelSubjects();
      topLevel.forEach(s => {
        options += `<option value="${s.id}">${escapeHtml(s.name)}</option>`;
        const children = getChildSubjects(s.id);
        children.forEach(c => {
          options += `<option value="${c.id}">&nbsp;&nbsp;↳ ${escapeHtml(c.name)}</option>`;
        });
      });

      newTaskSubject.innerHTML = options;
      editTaskSubject.innerHTML = options;
      syncQuickAddSubject();
    }

    function updateParentSubjectSelector() {
      // Only top-level subjects can be parents
      let options = `<option value="">ללא (נושא ראשי)</option>`;
      const topLevel = getTopLevelSubjects();
      topLevel.forEach(s => {
        // Don't allow setting itself as parent when editing
        if (s.id !== editingSubjectId) {
          options += `<option value="${s.id}">${escapeHtml(s.name)}</option>`;
        }
      });
      parentSubjectSelect.innerHTML = options;
    }

    // Update getFilteredTasks to include subject filter AND smart views
    const originalGetFilteredTasks = getFilteredTasks;
    getFilteredTasks = function () {
      let filtered = originalGetFilteredTasks();

      // Apply smart view filter
      if (currentSmartView) {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const weekLater = new Date(today);
        weekLater.setDate(weekLater.getDate() + 7);

        if (currentSmartView === 'today') {
          filtered = filtered.filter(t => {
            if (!t.dueDate) return false;
            const due = new Date(t.dueDate);
            return due >= today && due < tomorrow;
          });
        } else if (currentSmartView === 'week') {
          filtered = filtered.filter(t => {
            if (!t.dueDate) return false;
            const due = new Date(t.dueDate);
            return due >= today && due < weekLater;
          });
        } else if (currentSmartView === 'overdue') {
          filtered = filtered.filter(t => {
            if (!t.dueDate || t.completed) return false;
            return new Date(t.dueDate) < now;
          });
        } else if (currentSmartView === 'nodate') {
          filtered = filtered.filter(t => !t.dueDate && !t.completed);
        }
      }

      // Apply subject filter
      if (currentSubject !== 'all' && !currentSmartView) {
        const selectedSubject = subjects.find(s => s.id === currentSubject);
        const isSubSubject = selectedSubject && selectedSubject.parentId;

        // Get all valid subject IDs (current + children if parent)
        const validIds = [currentSubject];
        const children = getChildSubjects(currentSubject);
        children.forEach(c => validIds.push(c.id));

        const subjectFiltered = filtered.filter(t => validIds.includes(t.subject));

        // If this is a sub-subject with no tasks, show high priority tasks from all subjects due today/tomorrow
        if (isSubSubject && subjectFiltered.filter(t => !t.completed).length === 0) {
          const now = new Date();
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const dayAfterTomorrow = new Date(today);
          dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2);

          // Get high priority tasks (urgent, high) due today or tomorrow from all subjects
          filtered = filtered.filter(t => {
            if (t.completed) return false;
            const isHighPriority = t.priority === 'urgent' || t.priority === 'high';
            const hasDueDate = t.dueDate;
            if (!hasDueDate) return isHighPriority; // Include high priority without date
            const due = new Date(t.dueDate);
            const isDueSoon = due >= today && due < dayAfterTomorrow;
            return isHighPriority || isDueSoon;
          });

          // Sort by priority then by due date
          filtered.sort((a, b) => {
            const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3, none: 4 };
            const pDiff = (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
            if (pDiff !== 0) return pDiff;
            if (!a.dueDate && !b.dueDate) return 0;
            if (!a.dueDate) return 1;
            if (!b.dueDate) return -1;
            return new Date(a.dueDate) - new Date(b.dueDate);
          });

          // Mark that we're showing suggested tasks
          window.showingSuggestedTasks = true;
        } else {
          filtered = subjectFiltered;
          window.showingSuggestedTasks = false;
        }
      } else {
        window.showingSuggestedTasks = false;
      }

      return filtered;
    };



    // Sharing state for subject modal
    let pendingSharedUsers = [];
    const shareWithUserInput = $("shareWithUserInput");
    const addShareUserBtn = $("addShareUserBtn");
    const sharedWithList = $("sharedWithList");
    const shareError = $("shareError");

    function renderSharedUsersList() {
      if (!sharedWithList) return;
      if (pendingSharedUsers.length === 0) {
        sharedWithList.innerHTML = '<div style="font-size: 12px; color: var(--muted);">לא משותף עם אף אחד</div>';
        return;
      }
      sharedWithList.innerHTML = pendingSharedUsers.map((user, idx) => `
      <span class="shared-user-pill ${user === currentUser ? 'owner' : ''}">
        👤 ${escapeHtml(user)}${user === currentUser ? ' (אתה)' : ''}
        ${user !== currentUser ? `<span class="remove-share" data-idx="${idx}">×</span>` : ''}
      </span>
    `).join('');

      // Add remove handlers
      sharedWithList.querySelectorAll('.remove-share').forEach(btn => {
        btn.onclick = () => {
          const idx = parseInt(btn.dataset.idx);
          pendingSharedUsers.splice(idx, 1);
          renderSharedUsersList();
        };
      });
    }

    if (addShareUserBtn) {
      addShareUserBtn.onclick = () => {
        const username = shareWithUserInput.value.trim().toLowerCase();
        if (!username) return;
        if (username === currentUser) {
          shareError.textContent = 'לא ניתן לשתף עם עצמך';
          shareError.style.display = 'block';
          return;
        }
        if (pendingSharedUsers.includes(username)) {
          shareError.textContent = 'המשתמש כבר נמצא ברשימה';
          shareError.style.display = 'block';
          return;
        }
        shareError.style.display = 'none';
        pendingSharedUsers.push(username);
        shareWithUserInput.value = '';
        renderSharedUsersList();
      };

      shareWithUserInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          addShareUserBtn.click();
        }
      });
    }

    function openSubjectModal(subjectId, parentId = null) {
      console.log('openSubjectModal called', { subjectId, parentId });
      editingSubjectId = subjectId;
      updateParentSubjectSelector();
      if (shareError) shareError.style.display = 'none';
      if (shareWithUserInput) shareWithUserInput.value = '';

      if (subjectId) {
        const subject = subjects.find(s => s.id === subjectId);
        if (!subject) return;
        subjectModalTitle.textContent = 'ערוך נושא';
        subjectNameInput.value = subject.name;
        selectedSubjectColor = subject.color;
        parentSubjectSelect.value = subject.parentId || '';
        deleteSubjectBtn.style.display = 'block';

        // Load shared users
        if (subject.isShared) {
          const members = subject.members || {};
          pendingSharedUsers = Object.keys(members);
        } else {
          pendingSharedUsers = [];
        }

        // If editing a parent with children, disable parent selector
        const children = getChildSubjects(subjectId);
        parentSubjectSelect.disabled = children.length > 0;
      } else {
        subjectModalTitle.textContent = parentId ? 'הוסף תת-נושא' : 'הוסף נושא חדש';
        subjectNameInput.value = '';
        selectedSubjectColor = '#667eea';
        parentSubjectSelect.value = parentId || '';
        parentSubjectSelect.disabled = false;
        deleteSubjectBtn.style.display = 'none';
        pendingSharedUsers = [];
      }

      renderSharedUsersList();

      // Update color picker selection
      subjectColorPicker.querySelectorAll('.subject-color-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.color === selectedSubjectColor);
      });

      subjectModal.classList.add('open');
      subjectNameInput.focus();
    }

    function closeSubjectModal() {
      subjectModal.classList.remove('open');
      editingSubjectId = null;
    }

    // Quick share function - opens subject modal focused on sharing section
    function openShareSubjectModal(subjectId) {
      if (!subjectId) return;
      const subject = subjects.find(s => s.id === subjectId);
      if (!subject) return;

      // Open the regular edit modal
      openSubjectModal(subjectId);

      // Scroll to and focus on sharing section
      setTimeout(() => {
        const sharingSection = document.getElementById('subjectSharingSection');
        if (sharingSection) {
          sharingSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Highlight the sharing section briefly
          sharingSection.style.transition = 'background 0.3s, box-shadow 0.3s';
          sharingSection.style.background = 'rgba(102, 126, 234, 0.15)';
          sharingSection.style.boxShadow = '0 0 0 2px var(--accent)';
          if (shareWithUserInput) {
            shareWithUserInput.focus();
          }
          setTimeout(() => {
            sharingSection.style.background = '';
            sharingSection.style.boxShadow = '';
          }, 1500);
        }
      }, 100);
    }

    subjectModal.addEventListener('click', (e) => {
      if (e.target === subjectModal) closeSubjectModal();
    });

    // Color picker
    subjectColorPicker.addEventListener('click', (e) => {
      const option = e.target.closest('.subject-color-option');
      if (!option) return;
      subjectColorPicker.querySelectorAll('.subject-color-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      selectedSubjectColor = option.dataset.color;
    });

    // Cancel button
    cancelSubjectBtn.onclick = closeSubjectModal;

    // Save subject
    saveSubjectBtn.onclick = async () => {
      console.log('saveSubjectBtn clicked, name=', subjectNameInput.value);
      const name = subjectNameInput.value.trim();
      if (!name) return;

      const parentId = parentSubjectSelect.value || null;
      const hasSharing = pendingSharedUsers.length > 0;
      console.log('Saving subject:', { name, parentId, hasSharing, pendingSharedUsers, editingSubjectId });

      try {
        if (hasSharing) {
          // Save as shared subject
          const members = {};
          pendingSharedUsers.forEach(user => {
            if (user !== currentUser) {
              members[user] = true;
            }
          });
          // Also add owner to members for easier querying
          members[currentUser] = true;

          const sharedSubjectData = {
            name,
            color: selectedSubjectColor,
            parentId,
            owner: currentUser,
            members,
            createdAt: new Date().toISOString()
          };

          console.log('Shared subject data:', sharedSubjectData);

          if (editingSubjectId) {
            const existingSubject = subjects.find(s => s.id === editingSubjectId);

            if (existingSubject?.isShared) {
              // Update existing shared subject
              await set(ref(db, `sharedSubjects/${editingSubjectId}`), sharedSubjectData);
            } else if (existingSubject?.isOwn) {
              // Convert from own to shared - move tasks
              const subjectTasks = tasks.filter(t => t.subject === editingSubjectId);

              // Create in shared location
              const newSharedRef = push(ref(db, 'sharedSubjects'));
              const newSharedId = newSharedRef.key;
              await set(newSharedRef, sharedSubjectData);

              // Move tasks to shared location
              for (const task of subjectTasks) {
                const { id, isOwn, ...taskData } = task;
                taskData.subject = newSharedId;
                await set(ref(db, `sharedSubjects/${newSharedId}/tasks/${id}`), taskData);
                await remove(ref(db, `users/${currentUser}/tasks/${id}`));
              }

              // Delete from own subjects
              await remove(ref(db, `users/${currentUser}/subjects/${editingSubjectId}`));
            }
          } else {
            // Create new shared subject
            console.log('Creating new shared subject...');
            const newSharedRef = push(ref(db, 'sharedSubjects'));
            console.log('New shared ref key:', newSharedRef.key);
            await set(newSharedRef, sharedSubjectData);
            console.log('Shared subject created successfully');
          }
        } else {
          // Save as own subject (not shared)
          const subjectData = {
            name,
            color: selectedSubjectColor,
            parentId,
            createdAt: new Date().toISOString()
          };

          console.log('Own subject data:', subjectData);

          if (editingSubjectId) {
            const existingSubject = subjects.find(s => s.id === editingSubjectId);

            if (existingSubject?.isShared && existingSubject?.owner === currentUser) {
              // Convert from shared to own - move tasks back
              const subjectTasks = tasks.filter(t => t.subject === editingSubjectId);

              // Create in own location
              const newOwnRef = push(subjectsRef);
              const newOwnId = newOwnRef.key;
              await set(newOwnRef, subjectData);

              // Move tasks to own location
              for (const task of subjectTasks) {
                const { id, isShared, ...taskData } = task;
                taskData.subject = newOwnId;
                await set(ref(db, `users/${currentUser}/tasks/${id}`), taskData);
              }

              // Delete shared subject
              await remove(ref(db, `sharedSubjects/${editingSubjectId}`));
            } else {
              // Update existing own subject
              await set(ref(db, `users/${currentUser}/subjects/${editingSubjectId}`), subjectData);
            }
          } else {
            // Create new own subject
            console.log('Creating new own subject...');
            const newSubjectRef = push(subjectsRef);
            await set(newSubjectRef, subjectData);
            console.log('Own subject created successfully');
          }
        }

        closeSubjectModal();
      } catch (error) {
        console.error('Error saving subject:', error);
        alert('שגיאה בשמירת הנושא: ' + error.message);
      }
    };

    subjectNameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') saveSubjectBtn.click();
    });

    // Delete subject by ID (used from dropdown buttons)
    function deleteSubjectById(subjectId) {
      const subject = subjects.find(s => s.id === subjectId);
      if (!subject) return;

      // For shared subjects, handle differently based on ownership
      if (subject.isShared) {
        if (subject.owner === currentUser) {
          // Owner can delete the shared subject entirely
          if (confirm(`Delete shared subject "${subject.name}"? This will delete all tasks and remove access for all shared users.`)) {
            // Delete the shared subject (tasks are stored under it)
            remove(ref(db, `sharedSubjects/${subjectId}`));
            if (currentSubject === subjectId) {
              currentSubject = 'all';
            }
          }
        } else {
          // Non-owner can only leave the shared subject
          if (confirm(`Leave shared subject "${subject.name}"? You will no longer see tasks in this subject.`)) {
            // Remove current user from members
            remove(ref(db, `sharedSubjects/${subjectId}/members/${currentUser}`));
            if (currentSubject === subjectId) {
              currentSubject = 'all';
            }
          }
        }
        return;
      }

      const children = getChildSubjects(subjectId);
      let message = `Delete "${subject.name}"?`;
      if (children.length > 0) {
        message += ` This will also delete ${children.length} sub-subject(s).`;
      }
      message += ' Tasks will remain but become uncategorized.';

      if (confirm(message)) {
        // Delete children first
        children.forEach(child => {
          tasks.forEach(task => {
            if (task.subject === child.id) {
              // Use the proper reference based on task location
              const taskRef = getTaskRef(task);
              if (taskRef) {
                set(ref(db, taskRef.toString().replace(db._repoInternal.repoInfo_.toString(), '') + '/subject'), '');
              }
            }
          });
          remove(ref(db, `users/${currentUser}/subjects/${child.id}`));
        });

        // Remove subject from all tasks that have it
        tasks.forEach(task => {
          if (task.subject === subjectId) {
            // For own tasks only (shared tasks would have been handled above)
            if (!task.isShared) {
              set(ref(db, `users/${currentUser}/tasks/${task.id}/subject`), '');
            }
          }
        });

        // Delete the subject
        remove(ref(db, `users/${currentUser}/subjects/${subjectId}`));

        // Reset to all if we were viewing that subject
        if (currentSubject === subjectId || children.some(c => c.id === currentSubject)) {
          currentSubject = 'all';
        }
      }
    }

    // Delete subject from modal
    deleteSubjectBtn.onclick = () => {
      if (!editingSubjectId) return;
      deleteSubjectById(editingSubjectId);
      closeSubjectModal();
    };

    // Update openTaskEditModal to set subject
    const originalOpenTaskEditModal = openTaskEditModal;
    openTaskEditModal = function (taskId) {
      originalOpenTaskEditModal(taskId);
      if (editingTask) {
        editTaskSubject.value = editingTask.subject || '';
      }
    };

    // ============ IMPROVED NATURAL LANGUAGE PARSING (Hebrew + English RTL-Safe) ============
    function parseNaturalLanguage(input) {
      let title = input;
      let dueDate = null;
      let priority = 'medium';
      let subjectId = '';

      // Helper: Normalize text by removing ALL spaces and converting to lowercase
      const normalize = (str) => str.replace(/\s+/g, '').toLowerCase();

      // ============ STEP 1: EXTRACT & REMOVE PRIORITY ============
      const priorityPatterns = [
        { level: 'urgent', patterns: [/\b(דחוף|מיידי|urgent|asap|!!!|!!)\b/gi] },
        { level: 'high', patterns: [/\b(גבוה|חשוב|high|important|!)\b/gi] },
        { level: 'medium', patterns: [/\b(בינוני|רגיל|medium|normal)\b/gi] },
        { level: 'low', patterns: [/\b(נמוך|לא דחוף|low)\b/gi] }
      ];

      for (const { level, patterns } of priorityPatterns) {
        for (const pattern of patterns) {
          const matches = title.match(pattern);
          if (matches) {
            priority = level;
            // Remove all matches
            matches.forEach(match => {
              title = title.replace(match, ' ');
            });
            break;
          }
        }
        if (priority !== 'medium') break;
      }
      title = title.trim();

      // ============ STEP 2: EXTRACT & REMOVE TIME ============
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      let hours = 23, minutes = 59;

      // Time patterns - support multiple formats
      const timePatterns = [
        /\b(\d{1,2}):(\d{2})\b/g,                    // 14:30, 9:00
        /\bבשעה\s*(\d{1,2}):(\d{2})\b/gi,           // בשעה 14:30
        /\bat\s*(\d{1,2}):(\d{2})\b/gi,              // at 14:30
        /\b(\d{1,2})\.(\d{2})\b/g,                   // 14.30
        /\b(\d{1,2}):(\d{2})\s*(am|pm)\b/gi,        // 2:30 PM
        /\bב-?(\d{1,2}):(\d{2})\b/gi                 // ב-14:30
      ];

      for (const pattern of timePatterns) {
        const match = title.match(pattern);
        if (match) {
          const firstMatch = match[0];
          const timeMatch = firstMatch.match(/(\d{1,2})[:.](\d{2})/);
          if (timeMatch) {
            hours = parseInt(timeMatch[1]);
            minutes = parseInt(timeMatch[2]);

            // Handle AM/PM
            const isPM = /pm/i.test(firstMatch);
            const isAM = /am/i.test(firstMatch);
            if (isPM && hours < 12) hours += 12;
            if (isAM && hours === 12) hours = 0;

            // Validate time
            if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
              title = title.replace(firstMatch, ' ').trim();
              break;
            }
          }
        }
      }

      // ============ STEP 3: EXTRACT & REMOVE DATE ============
      const dateKeywords = [
        { patterns: [/מחרתיים/gi], days: 2 },
        { patterns: [/בעוד יומיים/gi, /in 2 days/gi], days: 2 },
        { patterns: [/בעוד 3 ימים/gi, /in 3 days/gi], days: 3 },
        { patterns: [/בעוד 4 ימים/gi, /in 4 days/gi], days: 4 },
        { patterns: [/בעוד 5 ימים/gi, /in 5 days/gi], days: 5 },
        { patterns: [/להיום/gi, /היום/gi, /today/gi], days: 0 },
        { patterns: [/למחר/gi, /מחר/gi, /tomorrow/gi], days: 1 },
        { patterns: [/בעוד שבועיים/gi, /in 2 weeks/gi], days: 14 },
        { patterns: [/בעוד שבוע/gi, /in a week/gi], days: 7 },
        { patterns: [/השבוע/gi, /בשבוע הבא/gi, /this week/gi, /next week/gi], days: 7 },
        { patterns: [/בעוד חודש/gi, /in a month/gi], days: 30 },
      ];

      for (const { patterns, days } of dateKeywords) {
        let matched = false;
        for (const pattern of patterns) {
          const matches = title.match(pattern);
          if (matches) {
            dueDate = new Date(today);
            dueDate.setDate(dueDate.getDate() + days);
            dueDate.setHours(hours, minutes, 0, 0);
            // Remove all matches
            matches.forEach(match => {
              title = title.replace(match, ' ');
            });
            matched = true;
            break;
          }
        }
        if (matched) break;
      }

      // Hebrew & English day names
      if (!dueDate) {
        const hebrewDays = ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'];
        const englishDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

        for (let i = 0; i < 7; i++) {
          const hebrewPattern = new RegExp(`(ביום\\s+|יום\\s+)?${hebrewDays[i]}`, 'gi');
          const englishPattern = new RegExp(`(on\\s+)?${englishDays[i]}`, 'gi');

          const heMatches = title.match(hebrewPattern);
          const enMatches = title.match(englishPattern);

          if (heMatches || enMatches) {
            const currentDay = today.getDay();
            let daysToAdd = i - currentDay;
            if (daysToAdd <= 0) daysToAdd += 7;

            dueDate = new Date(today);
            dueDate.setDate(dueDate.getDate() + daysToAdd);
            dueDate.setHours(hours, minutes, 0, 0);

            if (heMatches) heMatches.forEach(m => title = title.replace(m, ' '));
            if (enMatches) enMatches.forEach(m => title = title.replace(m, ' '));
            break;
          }
        }
      }

      // Specific date formats: DD/MM or DD.MM
      if (!dueDate) {
        const datePattern = /\b(\d{1,2})[\/\.](\d{1,2})\b/g;
        const match = title.match(datePattern);
        if (match) {
          const firstMatch = match[0];
          const parts = firstMatch.split(/[\/\.]/);
          const day = parseInt(parts[0]);
          const month = parseInt(parts[1]) - 1; // JS months are 0-indexed

          if (day >= 1 && day <= 31 && month >= 0 && month <= 11) {
            dueDate = new Date(today.getFullYear(), month, day, hours, minutes, 0, 0);

            // If date is in the past, assume next year
            if (dueDate < now) {
              dueDate.setFullYear(dueDate.getFullYear() + 1);
            }

            title = title.replace(firstMatch, ' ').trim();
          }
        }
      }

      // ============ STEP 4: ENHANCED SUBJECT DETECTION ============
      // Sort subjects by name length (longest first) to prevent partial matches
      const sortedSubjects = [...subjects].sort((a, b) => b.name.length - a.name.length);
      let matchedSubject = null;
      let textToRemove = '';

      // METHOD 1: Hashtag with hierarchy #parent/child or #parent/child/grandchild
      const hierarchyMatch = title.match(/#([^#\s]+)\/([^#\s\/]+)(?:\/([^#\s\/]+))?/);
      if (hierarchyMatch) {
        const parentSearch = normalize(hierarchyMatch[1].replace(/_/g, ' '));
        const childSearch = normalize(hierarchyMatch[2].replace(/_/g, ' '));
        const grandchildSearch = hierarchyMatch[3] ? normalize(hierarchyMatch[3].replace(/_/g, ' ')) : null;

        // Find parent
        const parent = sortedSubjects.find(s =>
          !s.parentId && normalize(s.name).includes(parentSearch)
        );

        if (parent) {
          // Find child
          let child = subjects.find(s =>
            s.parentId === parent.id && normalize(s.name).includes(childSearch)
          );

          // If grandchild specified, find it
          if (child && grandchildSearch) {
            const grandchild = subjects.find(s =>
              s.parentId === child.id && normalize(s.name).includes(grandchildSearch)
            );
            if (grandchild) {
              matchedSubject = grandchild;
            } else {
              matchedSubject = child; // Fallback to child if grandchild not found
            }
          } else if (child) {
            matchedSubject = child;
          }

          if (matchedSubject) {
            textToRemove = hierarchyMatch[0];
          }
        }
      }

      // METHOD 2: Explicit Hashtag - Search ALL subjects (parent and children)
      if (!matchedSubject) {
        const hashIndex = title.indexOf('#');

        if (hashIndex !== -1) {
          const afterHash = title.substring(hashIndex + 1);

          // Check for quoted format first
          const quotedMatch = afterHash.match(/^"([^"]+)"/);
          if (quotedMatch) {
            const searchNorm = normalize(quotedMatch[1]);
            // Search in ALL subjects (including children)
            matchedSubject = sortedSubjects.find(s => normalize(s.name) === searchNorm);
            if (matchedSubject) {
              textToRemove = '#"' + quotedMatch[1] + '"';
            }
          }

          // Check for underscore format
          if (!matchedSubject) {
            const underscoreMatch = afterHash.match(/^([^\s]+)/);
            if (underscoreMatch) {
              const searchText = underscoreMatch[1].replace(/_/g, ' ');
              const searchNorm = normalize(searchText);
              // Search in ALL subjects (including children)
              matchedSubject = sortedSubjects.find(s => normalize(s.name) === searchNorm);
              if (matchedSubject) {
                textToRemove = '#' + underscoreMatch[1];
              }
            }
          }

          // Character-by-character matching (space-insensitive)
          if (!matchedSubject) {
            const afterHashNormalized = normalize(afterHash);

            // Search in ALL subjects (including children)
            for (const subject of sortedSubjects) {
              const subjectNormalized = normalize(subject.name);

              if (afterHashNormalized.startsWith(subjectNormalized)) {
                matchedSubject = subject;

                // Calculate exact length to remove
                let matchLength = 0;
                let subjectCharIdx = 0;
                const subjectNoSpaces = subject.name.replace(/\s+/g, '').toLowerCase();

                for (let i = 0; i < afterHash.length; i++) {
                  const char = afterHash[i].toLowerCase();
                  if (/\s/.test(char)) {
                    matchLength++;
                    continue;
                  }
                  if (char === subjectNoSpaces[subjectCharIdx]) {
                    matchLength++;
                    subjectCharIdx++;
                    if (subjectCharIdx >= subjectNoSpaces.length) break;
                  } else {
                    break;
                  }
                }

                textToRemove = '#' + afterHash.substring(0, matchLength);
                break;
              }
            }
          }
        }
      }

      // METHOD 3: Auto-detect subject name anywhere in text (without #)
      // Search ALL subjects - children are prioritized because sortedSubjects is by length
      if (!matchedSubject) {
        for (const subject of sortedSubjects) {
          // Create flexible regex that allows optional spaces between letters
          const words = subject.name.split(/\s+/);
          const pattern = words.map(w =>
            w.split('').map(c => c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('\\s*')
          ).join('\\s+');
          const boundary = "(?:^|\\s|[\\.,!\\?;:\\-\\(\\)\\[\\]{}\"'])";
          const regex = new RegExp(`${boundary}(${pattern})(?=$|\\s|[\\.,!\\?;:\\-\\(\\)\\[\\]{}\"'])`, 'i');

          const match = title.match(regex);
          if (match) {
            matchedSubject = subject;
            textToRemove = match[1] || match[0];
            break;
          }
        }
      }

      // Apply subject match
      if (matchedSubject) {
        subjectId = matchedSubject.id;
        if (textToRemove) {
          title = title.replace(textToRemove, ' ').trim();
        }
      }

      // ============ STEP 5: FINAL CLEANUP ============
      title = title.replace(/#\s*/g, ' ');
      title = title.replace(/\s+/g, ' ').trim();
      title = title.replace(/^[,.:;\-]+\s*/, '').replace(/\s*[,.:;\-]+$/, '').trim();

      return { title, dueDate, priority, subjectId };
    }

    // Legacy helper - kept for compatibility
    function normalizeForComparison(text) {
      return text.toLowerCase().replace(/\s+/g, '').trim();
    }

    // Helper function to find best matching subject (used by some methods)
    function findBestSubjectMatch(searchTerm, sortedSubjects) {
      const normalize = (str) => str.replace(/\s+/g, '').toLowerCase();
      const searchNorm = normalize(searchTerm);
      const searchLower = searchTerm.toLowerCase().trim(); // Define searchLower for fuzzy matching

      // 1. Exact match (space-insensitive)
      let found = sortedSubjects.find(s => normalize(s.name) === searchNorm);
      if (found) return found;

      // 2. Starts with
      found = sortedSubjects.find(s => normalize(s.name).startsWith(searchNorm));
      if (found) return found;

      // 3. Search term starts with subject name
      found = sortedSubjects.find(s => searchNorm.startsWith(normalize(s.name)));
      if (found) return found;

      // 4. Contains
      found = sortedSubjects.find(s => normalize(s.name).includes(searchNorm));
      if (found) return found;

      // 5. Reverse contains
      found = sortedSubjects.find(s => searchLower.includes(s.name.toLowerCase()));
      if (found) return found;

      // 6. Fuzzy match - check if all words from search appear in subject name
      const searchWords = searchLower.split(/\s+/);
      found = sortedSubjects.find(s => {
        const subjectLower = s.name.toLowerCase();
        return searchWords.every(word => subjectLower.includes(word));
      });
      if (found) return found;

      return null;
    }

    // Smart quick add with natural language + Enter to add
    newTaskTitle.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      const input = newTaskTitle.value.trim();
      if (!input) return;

      const parsed = parseNaturalLanguage(input);
      const hasParsed = parsed.dueDate || parsed.subjectId || parsed.priority !== 'medium';

      if (hasParsed) {
        const defaultSubjectId = getDefaultSubjectId();
        const selectedSubjectId = parsed.subjectId || defaultSubjectId;
        const orderValue = hasManualOrder() ? getNextTaskOrder(false) : null;
        const recurrence = newTaskRecurrence ? newTaskRecurrence.value : 'none';

        const taskData = {
          title: parsed.title || input,
          content: '',
          priority: parsed.priority,
          dueDate: parsed.dueDate ? parsed.dueDate.toISOString() : null,
          subject: selectedSubjectId || '',
          checklist: [],
          completed: false,
          createdAt: new Date().toISOString(),
          ...(Number.isFinite(orderValue) ? { order: orderValue } : {}),
          ...(selectedTaskColor ? { color: selectedTaskColor } : {}),
          ...(recurrence && recurrence !== 'none' ? { recurrence } : {})
        };

        createTask(taskData);

        const taskSections = $("taskSections");
        if (taskSections) {
          taskSections.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        newTaskTitle.value = '';
        quickAddRow.style.display = 'none';
        selectedTaskColor = '';
        if (newTaskRecurrence) newTaskRecurrence.value = 'none';
        setTaskColorSelection(quickTaskColorPicker, selectedTaskColor);
        syncQuickAddSubject();
      } else {
        addTask();
      }
    });

    if (newTaskDue) {
      newTaskDue.addEventListener('keydown', (e) => {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        addTask();
      });
    }

    // Kick off Pomodoro UI
    Pomodoro.init();
    startTaskReminderTicker();

    // ============ DAILY REMINDER ============
    const closeReminderBtn = $("closeReminderBtn");
    const reminderDate = $("reminderDate");
    const todayTasksList = $("todayTasksList");
    const tomorrowTasksList = $("tomorrowTasksList");
    const todayTasksSection = $("todayTasksSection");
    const tomorrowTasksSection = $("tomorrowTasksSection");

    function showDailyReminder() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const dayAfterTomorrow = new Date(tomorrow);
      dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);

      // Format date in Hebrew
      const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
      reminderDate.textContent = now.toLocaleDateString('he-IL', dateOptions);

      // Get today's tasks
      const todayTasks = tasks.filter(t => {
        if (!t.dueDate || t.completed) return false;
        const due = new Date(t.dueDate);
        return due >= today && due < tomorrow;
      }).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));

      // Get tomorrow's tasks
      const tomorrowTasks = tasks.filter(t => {
        if (!t.dueDate || t.completed) return false;
        const due = new Date(t.dueDate);
        return due >= tomorrow && due < dayAfterTomorrow;
      }).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));

      // Render today's tasks
      if (todayTasks.length > 0) {
        todayTasksSection.style.display = 'block';
        todayTasksList.innerHTML = todayTasks.map(t => renderReminderTask(t)).join('');
      } else {
        todayTasksSection.style.display = 'block';
        todayTasksList.innerHTML = '<div class="reminder-empty">🎉 אין משימות להיום!</div>';
      }

      // Render tomorrow's tasks
      if (tomorrowTasks.length > 0) {
        tomorrowTasksSection.style.display = 'block';
        tomorrowTasksList.innerHTML = tomorrowTasks.map(t => renderReminderTask(t)).join('');
      } else {
        tomorrowTasksSection.style.display = 'none';
      }

      reminderModal.classList.add('open');
    }

    function renderReminderTask(task) {
      const priorityColors = {
        urgent: '#ef4444',
        high: '#f97316',
        medium: '#eab308',
        low: '#22c55e',
        none: '#6b7280'
      };
      const color = priorityColors[task.priority || 'none'];
      const time = task.dueDate ? new Date(task.dueDate).toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' }) : '';

      return `
      <div class="reminder-task-item">
        <div class="task-priority-dot" style="background: ${color};"></div>
        <div class="task-info">
          <div class="task-title">${escapeHtml(task.title)}</div>
          ${time ? `<div class="task-time">⏰ ${time}</div>` : ''}
        </div>
      </div>
    `;
    }

    closeReminderBtn.onclick = () => {
      reminderModal.classList.remove('open');
      localStorage.setItem('lastReminderDate', new Date().toDateString());
    };

    // Check if we should show reminder (at 9:00 AM)
    function checkDailyReminder() {
      const now = new Date();
      const lastReminder = localStorage.getItem('lastReminderDate');
      const todayString = now.toDateString();

      // If already shown today, skip
      if (lastReminder === todayString) return;

      // If it's between 9:00 and 9:30 AM, show reminder
      if (now.getHours() === 9 && now.getMinutes() < 30) {
        // Wait for tasks to load
        if (tasks.length > 0 || subjects.length > 0) {
          showDailyReminder();
        }
      }
    }

    // Check every minute
    setInterval(checkDailyReminder, 60000);

    // Also check on page load (with delay to let data load)
    setTimeout(checkDailyReminder, 3000);

    // ============ INITIALIZE SMART VIEWS ============
    setupSmartViewsHandlers();

    // ============ DAILY PLANNER MODULE ============
    const DailyPlanner = (() => {
      // State
      let currentDate = new Date();
      let plannerView = 'day'; // 'day' or 'week'
      let plannerBlocks = [];
      let editingBlockId = null;
      let miniCalendarDate = new Date();
      let initialized = false;

      // Storage key
      const STORAGE_KEY = 'dailyPlannerBlocks';

      // DOM References
      const refs = {
        overlay: null,
        currentDate: null,
        prevDay: null,
        nextDay: null,
        todayBtn: null,
        viewToggle: null,
        timeline: null,
        dayView: null,
        weekView: null,
        miniGrid: null,
        miniTitle: null,
        quickTasks: null,
        addModal: null,
        totalBlocks: null,
        totalHours: null,
        completedBlocks: null,
        progress: null,
        dayTitle: null,
        daySummary: null,
        countdownsList: null,
        scheduledTasksList: null,
        syncAllBtn: null,
        syncCountdownsBtn: null,
        syncTasksBtn: null,
        aiDayPlanModal: null,
        aiDayPlanList: null,
        aiDayPlanTitle: null,
        aiDayPlanDesc: null,
        aiApplyPlanMergeBtn: null,
        aiApplyPlanReplaceBtn: null,
        aiCancelPlanBtn: null
      };

      // Hebrew day names
      const hebrewDays = ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'];
      const hebrewMonths = ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'];

      // Priority colors
      const priorityColors = {
        urgent: { color: '#ef4444', bg: '#fef2f2' },
        high: { color: '#f97316', bg: '#fff7ed' },
        medium: { color: '#eab308', bg: '#fefce8' },
        low: { color: '#22c55e', bg: '#f0fdf4' },
        none: { color: '#6b7280', bg: '#f3f4f6' }
      };

      // Category icons
      const categoryIcons = {
        work: '💼',
        study: '📚',
        health: '🏃',
        personal: '🏠',
        social: '👥',
        creative: '🎨',
        rest: '🧘'
      };

      // Templates
      const templates = {
        morning: [
          { title: 'התעוררות והתארגנות', start: '06:00', duration: 30, priority: 'medium', category: 'personal' },
          { title: 'ארוחת בוקר', start: '06:30', duration: 30, priority: 'low', category: 'health' },
          { title: 'פעילות גופנית', start: '07:00', duration: 45, priority: 'high', category: 'health' },
          { title: 'מקלחת והתארגנות', start: '07:45', duration: 30, priority: 'medium', category: 'personal' }
        ],
        work: [
          { title: 'בדיקת מיילים ותכנון יום', start: '09:00', duration: 30, priority: 'medium', category: 'work' },
          { title: 'עבודה ממוקדת - בלוק 1', start: '09:30', duration: 90, priority: 'high', category: 'work' },
          { title: 'הפסקה קצרה', start: '11:00', duration: 15, priority: 'low', category: 'rest' },
          { title: 'עבודה ממוקדת - בלוק 2', start: '11:15', duration: 90, priority: 'high', category: 'work' },
          { title: 'ארוחת צהריים', start: '12:45', duration: 45, priority: 'medium', category: 'health' },
          { title: 'פגישות / שיחות', start: '13:30', duration: 60, priority: 'medium', category: 'work' },
          { title: 'עבודה ממוקדת - בלוק 3', start: '14:30', duration: 90, priority: 'high', category: 'work' },
          { title: 'סיכום יום ותכנון מחר', start: '16:00', duration: 30, priority: 'medium', category: 'work' }
        ],
        study: [
          { title: 'לימוד - נושא ראשי', start: '08:00', duration: 90, priority: 'high', category: 'study' },
          { title: 'הפסקה וחטיף', start: '09:30', duration: 15, priority: 'low', category: 'rest' },
          { title: 'תרגול ופתרון בעיות', start: '09:45', duration: 60, priority: 'high', category: 'study' },
          { title: 'ארוחת צהריים', start: '10:45', duration: 45, priority: 'medium', category: 'health' },
          { title: 'לימוד - נושא משני', start: '11:30', duration: 75, priority: 'medium', category: 'study' },
          { title: 'הפסקה ארוכה', start: '12:45', duration: 30, priority: 'low', category: 'rest' },
          { title: 'חזרה וסיכום', start: '13:15', duration: 60, priority: 'medium', category: 'study' },
          { title: 'הכנת שיעורי בית', start: '14:15', duration: 90, priority: 'high', category: 'study' }
        ],
        relax: [
          { title: 'התעוררות טבעית', start: '09:00', duration: 30, priority: 'low', category: 'rest' },
          { title: 'ארוחת בוקר נינוחה', start: '09:30', duration: 45, priority: 'low', category: 'health' },
          { title: 'קריאה / מדיטציה', start: '10:15', duration: 60, priority: 'low', category: 'rest' },
          { title: 'טיול / פעילות חוץ', start: '11:15', duration: 90, priority: 'medium', category: 'health' },
          { title: 'ארוחת צהריים', start: '12:45', duration: 60, priority: 'low', category: 'health' },
          { title: 'תחביב / פעילות יצירתית', start: '13:45', duration: 120, priority: 'medium', category: 'creative' },
          { title: 'זמן חברתי / משפחתי', start: '16:00', duration: 120, priority: 'medium', category: 'social' }
        ]
      };

      // Load blocks from storage
      const loadBlocks = () => {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) {
            plannerBlocks = JSON.parse(saved);
          }
        } catch (e) {
          console.error('Error loading planner blocks:', e);
          plannerBlocks = [];
        }
      };

      // Save blocks to storage
      const saveBlocks = () => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(plannerBlocks));
        } catch (e) {
          console.error('Error saving planner blocks:', e);
        }
      };

      // Generate unique ID
      const generateId = () => 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

      // Format date for display
      const formatDate = (date) => {
        const day = hebrewDays[date.getDay()];
        const dayNum = date.getDate();
        const month = hebrewMonths[date.getMonth()];
        const year = date.getFullYear();
        return `יום ${day}, ${dayNum} ב${month} ${year}`;
      };

      // Check if two dates are the same day
      const isSameDay = (d1, d2) => {
        return d1.getFullYear() === d2.getFullYear() &&
          d1.getMonth() === d2.getMonth() &&
          d1.getDate() === d2.getDate();
      };

      // Check if date is today
      const isToday = (date) => isSameDay(date, new Date());

      // Get date string for storage (YYYY-MM-DD)
      const getDateKey = (date) => {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
      };

      // Parse time string to minutes from midnight
      const parseTime = (timeStr) => {
        if (!timeStr) return 0;
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + (m || 0);
      };

      // Format minutes to time string
      const formatTime = (minutes) => {
        const h = Math.floor(minutes / 60);
        const m = minutes % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
      };

      // Ensure recurring blocks are instantiated for the target date
      const ensureRecurringForDate = (date) => {
        const dateKey = getDateKey(date);
        let created = 0;
        plannerBlocks
          .filter(b => b.repeat)
          .forEach(base => {
            if (!base.date) return;
            const baseDate = new Date(base.date);
            // Only create occurrences after (or same as) the base date
            if (baseDate > date || isSameDay(baseDate, date)) return;
            // Avoid duplicate clones
            const alreadyExists = plannerBlocks.some(b => b.originId === (base.originId || base.id) && b.date === dateKey);
            if (alreadyExists) return;
            const clone = {
              ...base,
              id: generateId(),
              date: dateKey,
              completed: false,
              repeat: false, // clones themselves do not auto-repeat; the base drives future creation
              originId: base.originId || base.id,
              createdAt: new Date().toISOString()
            };
            plannerBlocks.push(clone);
            created++;
          });
        if (created > 0) saveBlocks();
      };

      // Get blocks for a specific date
      const getBlocksForDate = (date) => {
        ensureRecurringForDate(date);
        const dateKey = getDateKey(date);
        return plannerBlocks
          .filter(b => b.date === dateKey)
          .sort((a, b) => parseTime(a.start) - parseTime(b.start));
      };

      // Calculate stats for a date
      const calculateStats = (date) => {
        const blocks = getBlocksForDate(date);
        const total = blocks.length;
        const completed = blocks.filter(b => b.completed).length;
        const totalMinutes = blocks.reduce((sum, b) => sum + (b.duration || 60), 0);
        const hours = Math.floor(totalMinutes / 60);
        const mins = totalMinutes % 60;
        const progress = total > 0 ? Math.round((completed / total) * 100) : 0;

        return { total, completed, hours, mins, progress, totalMinutes };
      };

      // Update stats display
      const updateStats = () => {
        const stats = calculateStats(currentDate);

        if (refs.totalBlocks) refs.totalBlocks.textContent = stats.total;
        if (refs.totalHours) {
          refs.totalHours.textContent = stats.mins > 0 ? `${stats.hours}:${String(stats.mins).padStart(2, '0')} שעות` : `${stats.hours} שעות`;
        }
        if (refs.completedBlocks) refs.completedBlocks.textContent = stats.completed;
        if (refs.progress) refs.progress.textContent = `${stats.progress}%`;
        if (refs.daySummary) {
          refs.daySummary.textContent = `${stats.total} פעילויות • ${stats.hours}:${String(stats.mins).padStart(2, '0')} שעות`;
        }
      };

      // Render timeline for day view
      const renderTimeline = () => {
        if (!refs.timeline) return;

        const blocks = getBlocksForDate(currentDate);
        const now = new Date();
        const isCurrentDay = isToday(currentDate);
        const currentMinutes = now.getHours() * 60 + now.getMinutes();

        let html = '';

        // Generate hour rows (6 AM to 11 PM)
        for (let hour = 6; hour <= 23; hour++) {
          const hourLabel = `${String(hour).padStart(2, '0')}:00`;
          const hourMinutes = hour * 60;

          // Find blocks that start in this hour
          const hourBlocks = blocks.filter(b => {
            const startMin = parseTime(b.start);
            return startMin >= hourMinutes && startMin < hourMinutes + 60;
          });

          html += `
          <div class="planner-hour-row" data-hour="${hour}">
            <div class="planner-hour-label">${hourLabel}</div>
            <div class="planner-hour-content" data-hour="${hour}">
              <span class="planner-empty-hour">+ לחץ להוספה</span>
              ${hourBlocks.map(block => renderBlock(block, hourMinutes)).join('')}
              ${isCurrentDay && currentMinutes >= hourMinutes && currentMinutes < hourMinutes + 60 ? renderNowLine(currentMinutes - hourMinutes) : ''}
            </div>
          </div>
        `;
        }

        refs.timeline.innerHTML = html;

        // Add click handlers for hour content
        refs.timeline.querySelectorAll('.planner-hour-content').forEach(el => {
          el.addEventListener('click', (e) => {
            if (Date.now() < suppressBlockClickUntil) return;
            if (e.target.closest('.planner-block')) return;
            const hour = parseInt(el.dataset.hour);
            openAddModal(hour);
          });

          // Drag and drop handlers for tasks from sidebar
          el.addEventListener('dragover', (e) => {
            e.preventDefault();
            el.classList.add('drop-target');
          });
          el.addEventListener('dragleave', () => {
            el.classList.remove('drop-target');
          });
          el.addEventListener('drop', (e) => {
            e.preventDefault();
            el.classList.remove('drop-target');
            const taskId = e.dataTransfer.getData('text/plain');
            if (taskId) {
              handleTaskDrop(taskId, parseInt(el.dataset.hour));
            }
          });
        });

        // Add click handlers for blocks
        refs.timeline.querySelectorAll('.planner-block').forEach(el => {
          el.addEventListener('click', (e) => {
            if (Date.now() < suppressBlockClickUntil) return;
            if (e.target.classList.contains('planner-block-resize-handle')) return;
            if (e.target.classList.contains('planner-block-checkbox')) return;
            openEditModal(el.dataset.id);
          });
        });

        // Add checkbox handlers
        refs.timeline.querySelectorAll('.planner-block-checkbox').forEach(el => {
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleBlockComplete(el.dataset.id);
          });
        });

        // Update day title
        if (refs.dayTitle) {
          const dayName = hebrewDays[currentDate.getDay()];
          const dayLabel = isToday(currentDate) ? 'היום' : (isSameDay(currentDate, new Date(Date.now() + 86400000)) ? 'מחר' : `יום ${dayName}`);
          refs.dayTitle.textContent = `${dayLabel} - יום ${dayName}`;
        }

        updateStats();
      };

      // Handle dropping a task from sidebar onto the timeline
      const handleTaskDrop = (taskId, hour) => {
        // Find the task
        const task = (typeof tasks !== 'undefined' ? tasks : []).find(t => t.id === taskId);
        if (!task) return;

        // Get duration from task or default to 30 minutes
        const duration = task.duration || 30;

        // Create a new block from the task
        const newBlock = {
          id: generateId(),
          title: task.title,
          start: formatTime(hour * 60),
          duration: duration,
          category: '',
          notes: '',
          repeat: false,
          priority: task.priority || 'medium',
          color: task.color || '',
          reminder: 0,
          completed: false,
          date: getDateKey(currentDate),
          createdAt: new Date().toISOString(),
          linkedTaskId: taskId // Link to original task
        };
        plannerBlocks.push(newBlock);

        saveBlocks();
        render();
      };

      // Render a single block
      const renderBlock = (block, hourMinutes) => {
        const startMin = parseTime(block.start);
        const offsetMin = startMin - hourMinutes;
        const duration = block.duration || 60;
        const heightPx = Math.max(15, duration * 1); // 1px per minute, min 15px
        const topPx = offsetMin * 1;

        // Determine compact mode based on duration
        let compactClass = '';
        if (duration <= 15) {
          compactClass = 'extra-compact';
        } else if (duration <= 30) {
          compactClass = 'compact';
        }

        const priority = block.priority || 'none';
        const defaultColors = priorityColors[priority] || priorityColors.none;
        // Use custom color if set, otherwise use priority color
        const blockColor = block.color || defaultColors.color;
        const blockBg = block.color ? `${block.color}20` : defaultColors.bg;
        const categoryIcon = block.category ? (categoryIcons[block.category] || '') : '';
        const endTime = formatTime(startMin + duration);
        const reminderText = block.reminder > 0 ? `🔔 ${block.reminder} דק׳ לפני` : '';

        // Determine notes display for day view (not compact/weekly)
        let notesHtml = '';
        if (!compactClass && block.notes && block.notes.trim()) {
          const notesText = escapeHtml(block.notes.trim());
          const notesLength = block.notes.length;
          // Calculate available space based on duration
          // Each line ~30 chars, each line takes ~14px
          const availableHeight = heightPx - 32; // subtract title and time area
          const maxLines = Math.min(4, Math.max(1, Math.floor(availableHeight / 14)));

          // Determine font size class based on notes length and available lines
          let fontClass = '';
          if (notesLength > maxLines * 40) {
            fontClass = 'tiny-text';
          } else if (notesLength > maxLines * 30) {
            fontClass = 'small-text';
          }

          // Only show notes if we have at least 45px height (45 min+)
          if (duration >= 45) {
            notesHtml = `<div class="planner-block-notes ${fontClass}" style="--notes-lines: ${maxLines};">${notesText}</div>`;
          }
        }

        return `
	        <div class="planner-block priority-${priority} ${block.completed ? 'planner-block-completed' : ''} ${compactClass}" 
	             data-id="${block.id}" 
	             style="top: ${topPx}px; height: ${heightPx}px; --priority-color: ${blockColor}; --priority-bg: ${blockBg};">
	          <div class="planner-block-checkbox ${block.completed ? 'checked' : ''}" data-id="${block.id}"></div>
	          <div class="planner-block-title">${categoryIcon} ${escapeHtml(block.title)}</div>
	          <div class="planner-block-time">${block.start} - ${endTime}${reminderText ? ' · ' + reminderText : ''}</div>
	          ${notesHtml}
	          <div class="planner-block-resize-handle" data-id="${block.id}" aria-label="Resize block"></div>
	        </div>
	      `;
      };

      // Drag/Resize planner blocks directly on the timeline (Google Calendar-like)
      const DAY_START_MINUTES = 6 * 60;
      const DAY_END_MINUTES = 24 * 60;
      const DRAG_SNAP_MINUTES = 15;
      const MIN_BLOCK_MINUTES = 15;
      let suppressBlockClickUntil = 0;
      let timelineDragState = null;
      let timelineGhostEl = null;

      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      const snapMinutes = (minutes) => Math.round(minutes / DRAG_SNAP_MINUTES) * DRAG_SNAP_MINUTES;

      const getMinuteFromClientY = (clientY) => {
        if (!refs.timeline) return DAY_START_MINUTES;
        const rect = refs.timeline.getBoundingClientRect();
        const y = clientY - rect.top + refs.timeline.scrollTop;
        const minutes = DAY_START_MINUTES + y; // 1px per minute
        return clamp(minutes, DAY_START_MINUTES, DAY_END_MINUTES);
      };

      const getBlocksForCurrentDateExcluding = (blockId) => {
        const dateKey = getDateKey(currentDate);
        return plannerBlocks
          .filter(b => b && b.date === dateKey && b.id !== blockId)
          .filter(b => Number.isFinite(parseTime(b.start)));
      };

      const rangesOverlap = (aStart, aEnd, bStart, bEnd) => aStart < bEnd && aEnd > bStart;

      const canPlace = (startMinutes, durationMinutes, others) => {
        const endMinutes = startMinutes + durationMinutes;
        if (startMinutes < DAY_START_MINUTES) return false;
        if (endMinutes > DAY_END_MINUTES) return false;
        return !others.some(o => {
          const oStart = parseTime(o.start);
          const oEnd = oStart + (o.duration || 60);
          return rangesOverlap(startMinutes, endMinutes, oStart, oEnd);
        });
      };

      const findNearestNonOverlappingStart = (proposedStart, duration, others) => {
        const minStart = DAY_START_MINUTES;
        const maxStart = DAY_END_MINUTES - duration;
        const base = clamp(snapMinutes(proposedStart), minStart, maxStart);
        if (canPlace(base, duration, others)) return base;
        // Try within closer range first for better UX
        for (let delta = DRAG_SNAP_MINUTES; delta <= 4 * 60; delta += DRAG_SNAP_MINUTES) {
          const forward = base + delta;
          if (forward <= maxStart && canPlace(forward, duration, others)) return forward;
          const backward = base - delta;
          if (backward >= minStart && canPlace(backward, duration, others)) return backward;
        }
        // If still not found, allow placement without checking overlap
        return base;
      };

      const adjustDurationToAvoidOverlap = (startMinutes, desiredDuration, others) => {
        const minDuration = MIN_BLOCK_MINUTES;
        const maxDuration = DAY_END_MINUTES - startMinutes;
        let duration = clamp(desiredDuration, minDuration, maxDuration);
        const desiredEnd = startMinutes + duration;

        let limitingEnd = desiredEnd;
        others.forEach(o => {
          const oStart = parseTime(o.start);
          if (!Number.isFinite(oStart)) return;
          if (oStart <= startMinutes) return;
          if (oStart < limitingEnd) {
            limitingEnd = oStart;
          }
        });

        duration = limitingEnd - startMinutes;
        if (duration < minDuration) duration = minDuration; // Allow minimum duration
        return duration;
      };

      const ensureTimelineGhost = () => {
        if (!refs.timeline) return null;
        // Check if ghost element is still attached to the DOM (it may be destroyed after render())
        if (timelineGhostEl && !refs.timeline.contains(timelineGhostEl)) {
          timelineGhostEl = null;
        }
        if (!timelineGhostEl) {
          timelineGhostEl = document.createElement('div');
          timelineGhostEl.className = 'planner-block-ghost';
          timelineGhostEl.style.display = 'none';
          timelineGhostEl.innerHTML = '<div class="planner-ghost-time"></div>';
          refs.timeline.appendChild(timelineGhostEl);
        }
        // Always recalculate positioning to ensure accuracy
        const timelineRect = refs.timeline.getBoundingClientRect();
        const content = refs.timeline.querySelector('.planner-hour-content');
        if (content) {
          const contentRect = content.getBoundingClientRect();
          const left = contentRect.left - timelineRect.left + 4;
          const right = timelineRect.right - contentRect.right + 4;
          timelineGhostEl.style.left = `${left}px`;
          timelineGhostEl.style.right = `${right}px`;
        } else {
          timelineGhostEl.style.left = '78px';
          timelineGhostEl.style.right = '8px';
        }
        return timelineGhostEl;
      };

      const showGhost = (startMinutes, durationMinutes) => {
        const ghost = ensureTimelineGhost();
        if (!ghost) return;

        // Force re-layout for smooth transition
        ghost.style.display = 'block';
        void ghost.offsetHeight; // Force reflow

        ghost.style.top = `${startMinutes - DAY_START_MINUTES}px`;
        ghost.style.height = `${Math.max(15, durationMinutes)}px`;

        // Show time range in ghost
        const timeLabel = ghost.querySelector('.planner-ghost-time');
        if (timeLabel) {
          const startTime = formatTime(startMinutes);
          const endTime = formatTime(startMinutes + durationMinutes);
          timeLabel.textContent = `${startTime} - ${endTime} (${durationMinutes} דק׳)`;
        }
      };

      const hideGhost = () => {
        if (!timelineGhostEl) return;
        timelineGhostEl.style.display = 'none';
        // Reset transform and other properties
        timelineGhostEl.style.transform = '';
      };

      const updateBlockTime = (blockId, nextStartMinutes, nextDurationMinutes) => {
        const block = plannerBlocks.find(b => b.id === blockId);
        if (!block) return false;
        block.start = formatTime(nextStartMinutes);
        block.duration = nextDurationMinutes;
        saveBlocks();
        render();
        return true;
      };

      const onTimelinePointerMove = (e) => {
        if (!timelineDragState) return;
        e.preventDefault();
        e.stopPropagation(); // Prevent event bubbling

        const minute = getMinuteFromClientY(e.clientY);
        const movedPx = Math.abs(e.clientY - timelineDragState.startClientY);
        if (movedPx > 3) timelineDragState.moved = true;

        if (timelineDragState.mode === 'move') {
          const proposedStart = minute - timelineDragState.offsetMinutes;
          const start = clamp(snapMinutes(proposedStart), DAY_START_MINUTES, DAY_END_MINUTES - timelineDragState.duration);
          timelineDragState.proposedStart = start;

          // Update ghost with smooth animation
          requestAnimationFrame(() => {
            showGhost(start, timelineDragState.duration);
          });

          // Update cursor
          document.body.style.cursor = 'grabbing';
        } else {
          const end = snapMinutes(minute);
          const duration = clamp(end - timelineDragState.startMinutes, MIN_BLOCK_MINUTES, DAY_END_MINUTES - timelineDragState.startMinutes);
          timelineDragState.proposedDuration = duration;

          // Update ghost with smooth animation
          requestAnimationFrame(() => {
            showGhost(timelineDragState.startMinutes, duration);
          });

          // Update cursor and add resizing class
          document.body.style.cursor = 'ns-resize';
          if (timelineDragState.el) {
            timelineDragState.el.classList.add('resizing');
          }
        }
      };

      const onTimelinePointerUp = (e) => {
        if (!timelineDragState) return;

        const { el, blockId, mode, startMinutes, duration, proposedStart, proposedDuration, moved, pointerId } = timelineDragState;

        // Clean up pointer capture first
        if (el && pointerId !== undefined) {
          try {
            el.releasePointerCapture(pointerId);
          } catch (err) {
            // Ignore errors if capture was already released
          }
        }

        // Remove event listeners before clearing state
        window.removeEventListener('pointermove', onTimelinePointerMove, { passive: false });
        window.removeEventListener('pointerup', onTimelinePointerUp);
        window.removeEventListener('pointercancel', onTimelinePointerUp);

        // Clean up visual state
        document.body.style.cursor = '';
        if (el) {
          el.classList.remove('dragging');
          el.classList.remove('resizing');
        }

        // Hide ghost with animation
        requestAnimationFrame(() => {
          hideGhost();
        });

        // Clear drag state
        timelineDragState = null;

        if (!moved) return;
        suppressBlockClickUntil = Date.now() + 350;

        const others = getBlocksForCurrentDateExcluding(blockId);

        if (mode === 'move') {
          const targetStart = Number.isFinite(proposedStart) ? proposedStart : startMinutes;
          const resolvedStart = findNearestNonOverlappingStart(targetStart, duration, others);
          if (resolvedStart !== null) {
            updateBlockTime(blockId, resolvedStart, duration);
          }
        } else {
          const targetDuration = Number.isFinite(proposedDuration) ? proposedDuration : duration;
          const adjusted = adjustDurationToAvoidOverlap(startMinutes, targetDuration, others);
          if (adjusted !== null) {
            updateBlockTime(blockId, startMinutes, adjusted);
          }
        }
      };

      const onTimelinePointerDown = (e) => {
        const blockEl = e.target.closest('.planner-block');
        if (!blockEl || !refs.timeline || !refs.timeline.contains(blockEl)) return;
        if (e.target.classList.contains('planner-block-checkbox')) return;

        const isResize = !!e.target.closest('.planner-block-resize-handle');
        const blockId = blockEl.dataset.id;
        const block = plannerBlocks.find(b => b.id === blockId);
        if (!block) return;

        e.preventDefault();
        e.stopPropagation();

        const startMinutes = parseTime(block.start);
        const duration = block.duration || 60;
        const minute = getMinuteFromClientY(e.clientY);
        const offsetMinutes = clamp(minute - startMinutes, 0, duration);

        timelineDragState = {
          el: blockEl,
          blockId,
          mode: isResize ? 'resize' : 'move',
          startClientY: e.clientY,
          startMinutes,
          duration,
          offsetMinutes: isResize ? 0 : offsetMinutes,
          moved: false,
          proposedStart: startMinutes,
          proposedDuration: duration,
          pointerId: e.pointerId
        };

        blockEl.classList.add('dragging');
        showGhost(startMinutes, duration);

        // Capture pointer for better tracking
        if (e.pointerId !== undefined) {
          blockEl.setPointerCapture(e.pointerId);
        }

        window.addEventListener('pointermove', onTimelinePointerMove, { passive: false });
        window.addEventListener('pointerup', onTimelinePointerUp);
        window.addEventListener('pointercancel', onTimelinePointerUp);
      };

      // Render current time indicator
      const renderNowLine = (offsetMinutes) => {
        const topPx = offsetMinutes * 1;
        const now = new Date();
        const timeStr = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        return `
        <div class="planner-now-line" style="top: ${topPx}px;">
          <span class="planner-now-label">${timeStr}</span>
        </div>
      `;
      };

      // Render week view
      const renderWeekView = () => {
        if (!refs.weekView) return;

        const startOfWeek = new Date(currentDate);
        const dayOfWeek = startOfWeek.getDay();
        startOfWeek.setDate(startOfWeek.getDate() - dayOfWeek);

        let html = '';

        for (let i = 0; i < 7; i++) {
          const date = new Date(startOfWeek);
          date.setDate(date.getDate() + i);
          const blocks = getBlocksForDate(date);
          const isCurrentDay = isToday(date);
          const isSelected = isSameDay(date, currentDate);

          html += `
          <div class="planner-week-day ${isCurrentDay ? 'today' : ''} ${isSelected ? 'selected' : ''}" data-date="${getDateKey(date)}">
            <div class="planner-week-day-header">
              <div class="planner-week-day-name">${hebrewDays[date.getDay()]}</div>
              <div class="planner-week-day-number">${date.getDate()}</div>
            </div>
            <div class="planner-week-day-content">
              ${blocks.slice(0, 8).map(block => `
                <div class="planner-week-block priority-${block.priority || 'none'}" data-id="${block.id}"
                     style="--priority-color: ${(priorityColors[block.priority] || priorityColors.none).color}; --priority-bg: ${(priorityColors[block.priority] || priorityColors.none).bg};">
                  <div class="planner-week-block-time">${block.start}</div>
                  <div class="planner-week-block-title">${escapeHtml(block.title)}</div>
                </div>
              `).join('')}
              ${blocks.length > 8 ? `<div style="text-align: center; font-size: 11px; color: var(--muted);">+${blocks.length - 8} עוד</div>` : ''}
            </div>
          </div>
        `;
        }

        refs.weekView.innerHTML = html;

        // Add click handlers for week days
        refs.weekView.querySelectorAll('.planner-week-day').forEach(el => {
          el.addEventListener('click', (e) => {
            if (e.target.closest('.planner-week-block')) {
              const blockEl = e.target.closest('.planner-week-block');
              openEditModal(blockEl.dataset.id);
            } else {
              const parts = el.dataset.date.split('-');
              currentDate = new Date(parts[0], parts[1] - 1, parts[2]);
              plannerView = 'day';
              updateViewToggle();
              render();
            }
          });
        });

        updateStats();
      };

      // Render mini calendar
      const renderMiniCalendar = () => {
        if (!refs.miniGrid || !refs.miniTitle) return;

        const year = miniCalendarDate.getFullYear();
        const month = miniCalendarDate.getMonth();

        refs.miniTitle.textContent = `${hebrewMonths[month]} ${year}`;

        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const startOffset = firstDay.getDay();

        let html = '';

        // Day names
        const dayNames = ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ש'];
        dayNames.forEach(name => {
          html += `<div class="planner-mini-day-name">${name}</div>`;
        });

        // Empty cells before first day
        for (let i = 0; i < startOffset; i++) {
          const prevDate = new Date(year, month, -(startOffset - i - 1));
          html += `<div class="planner-mini-day other-month" data-date="${getDateKey(prevDate)}">${prevDate.getDate()}</div>`;
        }

        // Days of month
        for (let d = 1; d <= lastDay.getDate(); d++) {
          const date = new Date(year, month, d);
          const hasEvents = getBlocksForDate(date).length > 0;
          const isCurrentDay = isToday(date);
          const isSelected = isSameDay(date, currentDate);

          html += `<div class="planner-mini-day ${isCurrentDay ? 'today' : ''} ${isSelected ? 'selected' : ''} ${hasEvents ? 'has-events' : ''}" data-date="${getDateKey(date)}">${d}</div>`;
        }

        // Empty cells after last day
        const endOffset = 6 - lastDay.getDay();
        for (let i = 1; i <= endOffset; i++) {
          const nextDate = new Date(year, month + 1, i);
          html += `<div class="planner-mini-day other-month" data-date="${getDateKey(nextDate)}">${i}</div>`;
        }

        refs.miniGrid.innerHTML = html;

        // Add click handlers
        refs.miniGrid.querySelectorAll('.planner-mini-day').forEach(el => {
          el.addEventListener('click', () => {
            const parts = el.dataset.date.split('-');
            currentDate = new Date(parts[0], parts[1] - 1, parts[2]);
            miniCalendarDate = new Date(currentDate);
            render();
          });
        });
      };

      // Render unscheduled tasks from the task manager
      const renderQuickTasks = () => {
        if (!refs.quickTasks) return;

        // Get tasks without due date or without time
        const unscheduledTasks = (typeof tasks !== 'undefined' ? tasks : [])
          .filter(t => !t.completed && (!t.dueDate || !t.dueDate.includes('T')))
          .slice(0, 10);

        if (unscheduledTasks.length === 0) {
          refs.quickTasks.innerHTML = '<div class="no-events-msg" id="plannerNoTasks">אין משימות ללא תזמון</div>';
          return;
        }

        refs.quickTasks.innerHTML = unscheduledTasks.map(task => {
          const subject = (typeof subjects !== 'undefined' ? subjects : []).find(s => s.id === task.subject);
          const color = subject ? subject.color : '#667eea';
          const priorityLabel = { urgent: '🔴', high: '🟠', medium: '🟡', low: '🟢', none: '⚪' };
          const taskDuration = task.duration || 30; // Default to 30 minutes if not set
          const durationText = taskDuration >= 60
            ? (taskDuration % 60 === 0 ? `${taskDuration / 60} שעות` : `${Math.floor(taskDuration / 60)}:${String(taskDuration % 60).padStart(2, '0')}`)
            : `${taskDuration} דק׳`;

          return `
          <div class="planner-task-item" draggable="true" data-task-id="${task.id}" data-duration="${taskDuration}">
            <div class="task-color-dot" style="background: ${color};"></div>
            <div class="task-info">
              <div class="task-title">${priorityLabel[task.priority || 'none']} ${escapeHtml(task.title)}</div>
              ${subject ? `<div class="task-subject">${subject.name}</div>` : ''}
            </div>
            <div class="task-duration">${durationText}</div>
          </div>
        `;
        }).join('');

        // Add drag handlers
        refs.quickTasks.querySelectorAll('.planner-task-item').forEach(el => {
          el.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', el.dataset.taskId);
            el.classList.add('dragging');
          });
          el.addEventListener('dragend', () => {
            el.classList.remove('dragging');
          });
        });
      };

      // Render countdowns for the current date
      const renderCountdowns = () => {
        if (!refs.countdownsList) return;

        const currentDateKey = getDateKey(currentDate);
        const currentBlocks = getBlocksForDate(currentDate);

        // Get countdowns (events) for the current date
        const countdownsForDate = (typeof events !== 'undefined' ? events : [])
          .filter(evt => {
            if (!evt.date) return false;
            const evtDate = new Date(evt.date);
            return getDateKey(evtDate) === currentDateKey;
          })
          .slice(0, 10);

        if (countdownsForDate.length === 0) {
          refs.countdownsList.innerHTML = '<div class="no-events-msg">אין ספירות לאחור להיום</div>';
          return;
        }

        refs.countdownsList.innerHTML = countdownsForDate.map(evt => {
          const evtDate = new Date(evt.date);
          const timeStr = evtDate.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
          const color = evt.color || '#667eea';

          // Check if already synced to planner
          const isSynced = currentBlocks.some(b => b.linkedEventId === evt.id);

          // Calculate time left
          const now = new Date();
          const diff = evtDate - now;
          let timeLeft = '';
          if (diff > 0) {
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            if (hours > 0) {
              timeLeft = `${hours} שעות`;
            } else {
              timeLeft = `${mins} דקות`;
            }
          } else {
            timeLeft = 'עבר';
          }

          return `
          <div class="planner-countdown-item" data-event-id="${evt.id}">
            <div class="countdown-color-dot" style="background: ${color};"></div>
            <div class="countdown-info">
              <div class="countdown-title">${escapeHtml(evt.name || 'אירוע')}</div>
              <div class="countdown-date">${timeStr}</div>
            </div>
            <div class="countdown-time-left">${timeLeft}</div>
            ${isSynced
              ? '<span class="planner-synced-indicator">✓ סונכרן</span>'
              : `<button class="add-to-planner-btn" data-event-id="${evt.id}" title="הוסף ליומן">+</button>`
            }
          </div>
        `;
        }).join('');

        // Add click handlers for adding to planner
        refs.countdownsList.querySelectorAll('.add-to-planner-btn').forEach(el => {
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            const eventId = el.dataset.eventId;
            addCountdownToPlanner(eventId);
          });
        });
      };

      // Render scheduled tasks (tasks with due date/time) for the current date
      const renderScheduledTasks = () => {
        if (!refs.scheduledTasksList) return;

        const currentDateKey = getDateKey(currentDate);
        const currentBlocks = getBlocksForDate(currentDate);

        // Get tasks with due date matching current date
        const scheduledTasks = (typeof tasks !== 'undefined' ? tasks : [])
          .filter(t => {
            if (t.completed || !t.dueDate) return false;
            const dueDate = new Date(t.dueDate);
            return getDateKey(dueDate) === currentDateKey;
          })
          .slice(0, 10);

        if (scheduledTasks.length === 0) {
          refs.scheduledTasksList.innerHTML = '<div class="no-events-msg">אין משימות מתוזמנות להיום</div>';
          return;
        }

        const priorityLabel = { urgent: '🔴', high: '🟠', medium: '🟡', low: '🟢', none: '⚪' };

        refs.scheduledTasksList.innerHTML = scheduledTasks.map(task => {
          const subject = (typeof subjects !== 'undefined' ? subjects : []).find(s => s.id === task.subject);
          const color = subject ? subject.color : '#10b981';
          const dueDate = new Date(task.dueDate);
          const hasTime = task.dueDate.includes('T');
          const timeStr = hasTime ? dueDate.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' }) : 'כל היום';


          // Check if already synced to planner
          const isSynced = currentBlocks.some(b => b.linkedTaskId === task.id);

          return `
          <div class="planner-scheduled-task-item" data-task-id="${task.id}">
            <div class="task-color-dot" style="background: ${color};"></div>
            <div class="task-info">
              <div class="task-title">${priorityLabel[task.priority || 'none']} ${escapeHtml(task.title)}</div>
              <div class="task-due">${timeStr}</div>
            </div>
            ${isSynced
              ? '<span class="planner-synced-indicator">✓ סונכרן</span>'
              : `<button class="add-to-planner-btn" data-task-id="${task.id}" title="הוסף ליומן">+</button>`
            }
          </div>
        `;
        }).join('');

        // Add click handlers for adding to planner
        refs.scheduledTasksList.querySelectorAll('.add-to-planner-btn').forEach(el => {
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            const taskId = el.dataset.taskId;
            addScheduledTaskToPlanner(taskId);
          });
        });
      };

      // Add a countdown event to the planner (standalone copy)
      const addCountdownToPlanner = (eventId) => {
        const evt = (typeof events !== 'undefined' ? events : []).find(e => e.id === eventId);
        if (!evt) return;

        const evtDate = new Date(evt.date);
        const startMinutes = evtDate.getHours() * 60 + evtDate.getMinutes();

        // Create a standalone block (copy, not linked for editing)
        const newBlock = {
          id: generateId(),
          title: evt.name || 'אירוע',
          start: formatTime(startMinutes),
          duration: 60, // Default 1 hour for events
          category: '',
          notes: evt.notes || '',
          repeat: false,
          priority: 'medium',
          color: evt.color || '',
          reminder: 0,
          completed: false,
          date: getDateKey(currentDate),
          createdAt: new Date().toISOString(),
          linkedEventId: eventId, // Track source for sync indicator only
          sourceType: 'countdown'
        };

        plannerBlocks.push(newBlock);
        saveBlocks();
        render();
      };

      // Add a scheduled task to the planner (standalone copy)
      const addScheduledTaskToPlanner = (taskId) => {
        const task = (typeof tasks !== 'undefined' ? tasks : []).find(t => t.id === taskId);
        if (!task) return;

        let startMinutes = 9 * 60; // Default to 9 AM
        if (task.dueDate && task.dueDate.includes('T')) {
          const dueDate = new Date(task.dueDate);
          startMinutes = dueDate.getHours() * 60 + dueDate.getMinutes();
        }

        const subject = (typeof subjects !== 'undefined' ? subjects : []).find(s => s.id === task.subject);

        // Create a standalone block (copy, not linked for editing)
        const newBlock = {
          id: generateId(),
          title: task.title,
          start: formatTime(startMinutes),
          duration: task.duration || 30,
          category: '',
          notes: task.notes || '',
          repeat: false,
          priority: task.priority || 'medium',
          color: subject ? subject.color : (task.color || ''),
          reminder: 0,
          completed: false,
          date: getDateKey(currentDate),
          createdAt: new Date().toISOString(),
          linkedTaskId: taskId, // Track source for sync indicator only
          sourceType: 'task'
        };

        plannerBlocks.push(newBlock);
        saveBlocks();
        render();
      };

      // Sync all countdowns for current date to planner
      const syncAllCountdowns = () => {
        const currentDateKey = getDateKey(currentDate);
        const currentBlocks = getBlocksForDate(currentDate);

        const countdownsForDate = (typeof events !== 'undefined' ? events : [])
          .filter(evt => {
            if (!evt.date) return false;
            const evtDate = new Date(evt.date);
            return getDateKey(evtDate) === currentDateKey;
          });

        let added = 0;
        countdownsForDate.forEach(evt => {
          // Skip if already synced
          if (currentBlocks.some(b => b.linkedEventId === evt.id)) return;
          addCountdownToPlanner(evt.id);
          added++;
        });

        if (added > 0) {
          render();
        }
        return added;
      };

      // Sync all scheduled tasks for current date to planner
      const syncAllScheduledTasks = () => {
        const currentDateKey = getDateKey(currentDate);
        const currentBlocks = getBlocksForDate(currentDate);

        const scheduledTasks = (typeof tasks !== 'undefined' ? tasks : [])
          .filter(t => {
            if (t.completed || !t.dueDate) return false;
            const dueDate = new Date(t.dueDate);
            return getDateKey(dueDate) === currentDateKey;
          });

        let added = 0;
        scheduledTasks.forEach(task => {
          // Skip if already synced
          if (currentBlocks.some(b => b.linkedTaskId === task.id)) return;
          addScheduledTaskToPlanner(task.id);
          added++;
        });

        if (added > 0) {
          render();
        }
        return added;
      };

      // Sync everything for current date
      const syncAll = () => {
        const countdownsAdded = syncAllCountdowns();
        const tasksAdded = syncAllScheduledTasks();
        return countdownsAdded + tasksAdded;
      };

      // Open add modal
      const openAddModal = (hour = 9) => {
        editingBlockId = null;

        const modal = refs.addModal;
        if (!modal) return;

        const titleEl = modal.querySelector('#plannerModalTitle');
        const blockTitle = modal.querySelector('#plannerBlockTitle');
        const blockStart = modal.querySelector('#plannerBlockStart');
        const blockEnd = modal.querySelector('#plannerBlockEnd');
        const blockCategory = modal.querySelector('#plannerBlockCategory');
        const blockNotes = modal.querySelector('#plannerBlockNotes');
        const blockRepeat = modal.querySelector('#plannerBlockRepeat');
        const deleteBtn = modal.querySelector('#plannerDeleteBtn');
        const priorityPicker = modal.querySelector('#plannerPriorityPicker');

        if (titleEl) titleEl.textContent = '➕ הוסף פעילות';
        if (blockTitle) blockTitle.value = '';
        if (blockStart) blockStart.value = formatTime(hour * 60);
        if (blockEnd) blockEnd.value = formatTime((hour + 1) * 60);
        if (blockCategory) blockCategory.value = '';
        if (blockNotes) blockNotes.value = '';
        if (blockRepeat) blockRepeat.checked = false;
        if (deleteBtn) deleteBtn.style.display = 'none';

        // Reset reminder
        const blockReminder = modal.querySelector('#plannerBlockReminder');
        if (blockReminder) blockReminder.value = '0';

        // Reset priority
        if (priorityPicker) {
          priorityPicker.querySelectorAll('.planner-priority-option').forEach(el => el.classList.remove('selected'));
          const mediumBtn = priorityPicker.querySelector('[data-priority="medium"]');
          if (mediumBtn) mediumBtn.classList.add('selected');
        }

        // Reset color picker
        const colorPicker = modal.querySelector('#plannerColorPicker');
        if (colorPicker) {
          colorPicker.querySelectorAll('.planner-color-option').forEach(el => el.classList.remove('selected'));
          const defaultColor = colorPicker.querySelector('[data-color=""]');
          if (defaultColor) defaultColor.classList.add('selected');
        }

        // Reset duration buttons
        modal.querySelectorAll('.planner-duration-btn').forEach(el => el.classList.remove('active'));
        const defaultDuration = modal.querySelector('[data-duration="60"]');
        if (defaultDuration) defaultDuration.classList.add('active');

        modal.classList.add('open');
        if (blockTitle) blockTitle.focus();
      };

      // Open edit modal
      const openEditModal = (blockId) => {
        const block = plannerBlocks.find(b => b.id === blockId);
        if (!block) return;

        editingBlockId = blockId;

        const modal = refs.addModal;
        if (!modal) return;

        const titleEl = modal.querySelector('#plannerModalTitle');
        const blockTitle = modal.querySelector('#plannerBlockTitle');
        const blockStart = modal.querySelector('#plannerBlockStart');
        const blockEnd = modal.querySelector('#plannerBlockEnd');
        const blockCategory = modal.querySelector('#plannerBlockCategory');
        const blockNotes = modal.querySelector('#plannerBlockNotes');
        const blockRepeat = modal.querySelector('#plannerBlockRepeat');
        const deleteBtn = modal.querySelector('#plannerDeleteBtn');
        const priorityPicker = modal.querySelector('#plannerPriorityPicker');

        if (titleEl) titleEl.textContent = '✏️ ערוך פעילות';
        if (blockTitle) blockTitle.value = block.title || '';
        if (blockStart) blockStart.value = block.start || '09:00';
        if (blockEnd) blockEnd.value = formatTime(parseTime(block.start) + (block.duration || 60));
        if (blockCategory) blockCategory.value = block.category || '';
        if (blockNotes) blockNotes.value = block.notes || '';
        if (blockRepeat) blockRepeat.checked = block.repeat || false;

        // Set reminder
        const blockReminder = modal.querySelector('#plannerBlockReminder');
        if (blockReminder) blockReminder.value = block.reminder || '0';
        if (deleteBtn) deleteBtn.style.display = '';

        // Set priority
        if (priorityPicker) {
          priorityPicker.querySelectorAll('.planner-priority-option').forEach(el => el.classList.remove('selected'));
          const priorityBtn = priorityPicker.querySelector(`[data-priority="${block.priority || 'medium'}"]`);
          if (priorityBtn) priorityBtn.classList.add('selected');
        }

        // Set color
        const colorPicker = modal.querySelector('#plannerColorPicker');
        if (colorPicker) {
          colorPicker.querySelectorAll('.planner-color-option').forEach(el => el.classList.remove('selected'));
          const colorBtn = colorPicker.querySelector(`[data-color="${block.color || ''}"]`);
          if (colorBtn) colorBtn.classList.add('selected');
        }

        modal.classList.add('open');
      };

      // Close modal
      const closeModal = () => {
        if (refs.addModal) refs.addModal.classList.remove('open');
        editingBlockId = null;
      };

      // Save block
      const saveBlock = () => {
        const modal = refs.addModal;
        if (!modal) return;

        const blockTitle = modal.querySelector('#plannerBlockTitle');
        const blockStart = modal.querySelector('#plannerBlockStart');
        const blockEnd = modal.querySelector('#plannerBlockEnd');
        const blockCategory = modal.querySelector('#plannerBlockCategory');
        const blockNotes = modal.querySelector('#plannerBlockNotes');
        const blockRepeat = modal.querySelector('#plannerBlockRepeat');
        const priorityPicker = modal.querySelector('#plannerPriorityPicker');

        const title = blockTitle ? blockTitle.value.trim() : '';
        if (!title) {
          if (blockTitle) blockTitle.focus();
          return;
        }

        const start = blockStart ? blockStart.value : '09:00';
        const end = blockEnd ? blockEnd.value : '10:00';
        const duration = parseTime(end) - parseTime(start);
        const category = blockCategory ? blockCategory.value : '';
        const notes = blockNotes ? blockNotes.value.trim() : '';
        const repeat = blockRepeat ? blockRepeat.checked : false;
        const blockReminder = modal.querySelector('#plannerBlockReminder');
        const reminder = blockReminder ? parseInt(blockReminder.value) || 0 : 0;
        const selectedPriority = priorityPicker ? priorityPicker.querySelector('.selected') : null;
        const priority = selectedPriority ? selectedPriority.dataset.priority : 'medium';
        const colorPicker = modal.querySelector('#plannerColorPicker');
        const selectedColor = colorPicker ? colorPicker.querySelector('.selected') : null;
        const color = selectedColor ? selectedColor.dataset.color : '';

        if (editingBlockId) {
          // Update existing block
          const index = plannerBlocks.findIndex(b => b.id === editingBlockId);
          if (index !== -1) {
            plannerBlocks[index] = {
              ...plannerBlocks[index],
              title,
              start,
              duration: Math.max(15, duration),
              category,
              notes,
              repeat,
              reminder,
              priority,
              color
            };
          }
        } else {
          // Create new block
          const newBlock = {
            id: generateId(),
            title,
            start,
            duration: Math.max(15, duration),
            category,
            notes,
            repeat,
            reminder,
            priority,
            color,
            completed: false,
            date: getDateKey(currentDate),
            createdAt: new Date().toISOString(),
            originId: null
          };
          plannerBlocks.push(newBlock);
        }

        saveBlocks();
        closeModal();
        render();
      };

      // Delete block (removes only the planner block, NOT the linked task)
      const deleteBlock = () => {
        if (!editingBlockId) return;

        // Only remove the planner block - tasks remain intact
        plannerBlocks = plannerBlocks.filter(b => b.id !== editingBlockId);
        saveBlocks();
        closeModal();
        render();
      };

      // Toggle block completion
      const toggleBlockComplete = (blockId) => {
        const block = plannerBlocks.find(b => b.id === blockId);
        if (block) {
          block.completed = !block.completed;
          saveBlocks();
          render();
        }
      };

      // Apply template
      const applyTemplate = (templateKey) => {
        const template = templates[templateKey];
        if (!template) return;

        const dateKey = getDateKey(currentDate);

        template.forEach(item => {
          const newBlock = {
            id: generateId(),
            title: item.title,
            start: item.start,
            duration: item.duration,
            category: item.category,
            priority: item.priority,
            completed: false,
            date: dateKey,
            createdAt: new Date().toISOString()
          };
          plannerBlocks.push(newBlock);
        });

        saveBlocks();
        render();
      };

      // Update view toggle buttons
      const updateViewToggle = () => {
        if (!refs.viewToggle) return;
        refs.viewToggle.querySelectorAll('button').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.view === plannerView);
        });
      };

      // Main render function
      const render = () => {
        // Update date display
        if (refs.currentDate) {
          refs.currentDate.textContent = formatDate(currentDate);
        }

        // Show/hide views
        if (refs.dayView) refs.dayView.style.display = plannerView === 'day' ? '' : 'none';
        if (refs.weekView) refs.weekView.style.display = plannerView === 'week' ? '' : 'none';

        // Render appropriate view
        if (plannerView === 'day') {
          renderTimeline();
        } else {
          renderWeekView();
        }

        renderMiniCalendar();
        renderQuickTasks();
        renderCountdowns();
        renderScheduledTasks();

        // Initialize drag/resize handlers after render
        if (refs.timeline && !refs.timeline.dataset.dragResizeInit) {
          refs.timeline.dataset.dragResizeInit = '1';
          refs.timeline.addEventListener('pointerdown', onTimelinePointerDown, { passive: false });
        }
      };

      // Navigate date
      const navigateDate = (delta) => {
        if (plannerView === 'week') {
          currentDate.setDate(currentDate.getDate() + (delta * 7));
        } else {
          currentDate.setDate(currentDate.getDate() + delta);
        }
        miniCalendarDate = new Date(currentDate);
        render();
      };

      // Go to today
      const goToToday = () => {
        currentDate = new Date();
        miniCalendarDate = new Date();
        render();
      };

      // Initialize
      const init = () => {
        if (initialized) {
          render();
          return;
        }
        initialized = true;

        // Get DOM references
        refs.overlay = $('plannerOverlay');
        refs.currentDate = $('plannerCurrentDate');
        refs.prevDay = $('plannerPrevDay');
        refs.nextDay = $('plannerNextDay');
        refs.todayBtn = $('plannerTodayBtn');
        refs.timeline = $('plannerTimeline');
        refs.dayView = $('plannerDayView');
        refs.weekView = $('plannerWeekView');
        refs.miniGrid = $('plannerMiniGrid');
        refs.miniTitle = $('plannerMiniTitle');
        refs.quickTasks = $('plannerQuickTasks');
        refs.addModal = $('plannerAddModal');
        refs.totalBlocks = $('plannerTotalBlocks');
        refs.totalHours = $('plannerTotalHours');
        refs.completedBlocks = $('plannerCompletedBlocks');
        refs.progress = $('plannerProgress');
        refs.dayTitle = $('plannerDayTitle');
        refs.daySummary = $('plannerDaySummary');
        refs.countdownsList = $('plannerCountdownsList');
        refs.scheduledTasksList = $('plannerScheduledTasksList');
        refs.syncAllBtn = $('plannerSyncAllBtn');
        refs.syncCountdownsBtn = $('plannerSyncCountdownsBtn');
        refs.syncTasksBtn = $('plannerSyncTasksBtn');

        // View toggle
        refs.viewToggle = refs.overlay ? refs.overlay.querySelector('.planner-view-toggle') : null;

        // Load saved blocks
        loadBlocks();

        // Set up event listeners
        if (refs.prevDay) refs.prevDay.onclick = () => navigateDate(-1);
        if (refs.nextDay) refs.nextDay.onclick = () => navigateDate(1);
        if (refs.todayBtn) refs.todayBtn.onclick = goToToday;

        // View toggle
        if (refs.viewToggle) {
          refs.viewToggle.querySelectorAll('button').forEach(btn => {
            btn.onclick = () => {
              plannerView = btn.dataset.view;
              updateViewToggle();
              render();
            };
          });
        }

        // Mini calendar navigation
        const miniPrev = $('plannerMiniPrev');
        const miniNext = $('plannerMiniNext');
        if (miniPrev) miniPrev.onclick = () => {
          miniCalendarDate.setMonth(miniCalendarDate.getMonth() - 1);
          renderMiniCalendar();
        };
        if (miniNext) miniNext.onclick = () => {
          miniCalendarDate.setMonth(miniCalendarDate.getMonth() + 1);
          renderMiniCalendar();
        };

        // Template buttons
        const templateBtns = refs.overlay ? refs.overlay.querySelectorAll('.planner-template-btn') : [];
        templateBtns.forEach(btn => {
          btn.onclick = () => applyTemplate(btn.dataset.template);
        });

        // Sync buttons
        if (refs.syncAllBtn) {
          refs.syncAllBtn.onclick = () => {
            refs.syncAllBtn.classList.add('syncing');
            const count = syncAll();
            setTimeout(() => {
              refs.syncAllBtn.classList.remove('syncing');
            }, 500);
          };
        }

        if (refs.syncCountdownsBtn) {
          refs.syncCountdownsBtn.onclick = () => {
            refs.syncCountdownsBtn.classList.add('syncing');
            syncAllCountdowns();
            setTimeout(() => {
              refs.syncCountdownsBtn.classList.remove('syncing');
            }, 500);
          };
        }

        if (refs.syncTasksBtn) {
          refs.syncTasksBtn.onclick = () => {
            refs.syncTasksBtn.classList.add('syncing');
            syncAllScheduledTasks();
            setTimeout(() => {
              refs.syncTasksBtn.classList.remove('syncing');
            }, 500);
          };
        }

        // Section collapse toggles
        const countdownsToggle = $('plannerCountdownsToggle');
        const scheduledTasksToggle = $('plannerScheduledTasksToggle');

        if (countdownsToggle && refs.countdownsList) {
          countdownsToggle.onclick = () => {
            countdownsToggle.classList.toggle('collapsed');
            refs.countdownsList.classList.toggle('collapsed');
          };
        }

        if (scheduledTasksToggle && refs.scheduledTasksList) {
          scheduledTasksToggle.onclick = () => {
            scheduledTasksToggle.classList.toggle('collapsed');
            refs.scheduledTasksList.classList.toggle('collapsed');
          };
        }

        // Modal events
        if (refs.addModal) {
          const cancelBtn = refs.addModal.querySelector('#plannerCancelBtn');
          const saveBtn = refs.addModal.querySelector('#plannerSaveBtn');
          const deleteBtn = refs.addModal.querySelector('#plannerDeleteBtn');
          const priorityPicker = refs.addModal.querySelector('#plannerPriorityPicker');
          const durationBtns = refs.addModal.querySelectorAll('.planner-duration-btn');

          if (cancelBtn) cancelBtn.onclick = closeModal;
          if (saveBtn) saveBtn.onclick = saveBlock;
          if (deleteBtn) deleteBtn.onclick = deleteBlock;

          // Enter key to save
          refs.addModal.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              const activeEl = document.activeElement;
              // Don't trigger if in textarea
              if (activeEl && activeEl.tagName === 'TEXTAREA') return;
              e.preventDefault();
              saveBlock();
            }
            if (e.key === 'Escape') {
              closeModal();
            }
          });

          // Color picker
          const colorPicker = refs.addModal.querySelector('#plannerColorPicker');
          if (colorPicker) {
            colorPicker.addEventListener('click', (e) => {
              const option = e.target.closest('.planner-color-option');
              if (!option) return;
              colorPicker.querySelectorAll('.planner-color-option').forEach(el => el.classList.remove('selected'));
              option.classList.add('selected');
            });
          }

          // Priority picker
          if (priorityPicker) {
            priorityPicker.addEventListener('click', (e) => {
              const option = e.target.closest('.planner-priority-option');
              if (!option) return;
              priorityPicker.querySelectorAll('.planner-priority-option').forEach(el => el.classList.remove('selected'));
              option.classList.add('selected');
            });
          }

          // Duration presets
          durationBtns.forEach(btn => {
            btn.onclick = () => {
              durationBtns.forEach(b => b.classList.remove('active'));
              btn.classList.add('active');

              const duration = parseInt(btn.dataset.duration);
              const startInput = refs.addModal.querySelector('#plannerBlockStart');
              const endInput = refs.addModal.querySelector('#plannerBlockEnd');

              if (startInput && endInput) {
                const startMins = parseTime(startInput.value);
                endInput.value = formatTime(startMins + duration);
              }
            };
          });

          // Close on backdrop click
          refs.addModal.addEventListener('click', (e) => {
            if (e.target === refs.addModal) closeModal();
          });
        }

        // Initial render
        render();

        // Update now line every minute
        setInterval(() => {
          if (plannerView === 'day' && isToday(currentDate)) {
            renderTimeline();
          }
        }, 60000);
      };

      // Refresh scheduled tasks (called when tasks change)
      const refreshTasks = () => {
        if (refs.overlay && refs.overlay.classList.contains('open')) {
          // Full render to update timeline, scheduled tasks, and quick tasks
          render();
        } else if (refs.scheduledTasksList) {
          // At minimum, update the cached lists for when planner is opened
          renderScheduledTasks();
          renderQuickTasks();
        }
      };

      const addPlannerBlock = async ({ date, title, start, durationMinutes = 60, notes = '', category = '' }) => {
        if (typeof showView === 'function') showView('planner');
        if (!initialized) init();

        const dateObj = new Date(date);
        if (isNaN(dateObj.getTime())) throw new Error('Invalid date');
        const dateKey = getDateKey(dateObj);

        const startMinutes = parseTime(start);
        if (!Number.isFinite(startMinutes)) throw new Error('Invalid start time');

        const duration = Math.min(240, Math.max(15, parseInt(durationMinutes || 60, 10) || 60));

        const newBlock = {
          id: generateId(),
          title: String(title || '').trim() || 'בלוק חדש',
          start: formatTime(startMinutes),
          duration,
          category: String(category || '').trim(),
          notes: String(notes || '').trim(),
          repeat: false,
          priority: 'medium',
          color: '',
          reminder: 0,
          completed: false,
          date: dateKey,
          createdAt: new Date().toISOString()
        };

        plannerBlocks.push(newBlock);
        saveBlocks();
        currentDate = new Date(dateObj);
        render();
      };

      return { init, render, refreshTasks, addPlannerBlock };
    })();

    // Handle Notification Actions (Complete Task)
    const handleCompleteTask = (taskId) => {
      const task = tasks.find(t => t.id === taskId);
      if (task && !task.completed) {
        console.log('Completing task from notification:', taskId);
        if (typeof maybeCreateRecurringTask === 'function') {
          maybeCreateRecurringTask(task);
        }
        const { id, isOwn, isShared, ...cleanTask } = task;
        saveTask(taskId, { ...cleanTask, completed: true }, task.subject);

        if (typeof showToast === 'function') {
          showToast(`Task "${task.title}" completed!`);
        }
      }
    };

    const urlParams = new URLSearchParams(window.location.search);
    const completeTaskId = urlParams.get('completeTask');
    if (completeTaskId) {
      const checkData = setInterval(() => {
        if (typeof tasks !== 'undefined' && tasks.length > 0) {
          clearInterval(checkData);
          handleCompleteTask(completeTaskId);
          const url = new URL(window.location);
          url.searchParams.delete('completeTask');
          url.searchParams.delete('user');
          url.searchParams.delete('sharedSubject');
          window.history.replaceState({}, '', url);
        }
      }, 500);
      setTimeout(() => clearInterval(checkData), 10000);
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.action === 'complete') {
          const url = new URL(event.data.url, window.location.origin);
          const tid = url.searchParams.get('completeTask');
          if (tid) {
            handleCompleteTask(tid);
          }
        }
      });
    }
  </script>

  <!-- Mobile Bottom Navigation Bar -->
  <nav class="mobile-bottom-nav" id="mobileBottomNav" style="display: none;">
    <button class="mobile-nav-item active" data-view="countdown">
      <span class="icon mobile-nav-icon" aria-hidden="true">timer</span>
      <span class="mobile-nav-label">ספירה</span>
    </button>
    <button class="mobile-nav-item" data-view="tasks">
      <span class="icon mobile-nav-icon" aria-hidden="true">checklist</span>
      <span class="mobile-nav-label">משימות</span>
    </button>
    <button class="mobile-nav-item" data-view="pomodoro">
      <span class="icon mobile-nav-icon" aria-hidden="true">timelapse</span>
      <span class="mobile-nav-label">פומודורו</span>
    </button>
    <button class="mobile-nav-item" data-view="planner">
      <span class="icon mobile-nav-icon" aria-hidden="true">event_note</span>
      <span class="mobile-nav-label">מתכנן</span>
    </button>
    <button class="mobile-nav-item" data-view="calendar">
      <span class="icon mobile-nav-icon" aria-hidden="true">calendar_month</span>
      <span class="mobile-nav-label">לוח</span>
    </button>
  </nav>

  <!-- Edge Swipe Indicators -->
  <div class="edge-swipe-indicator left"></div>
  <div class="edge-swipe-indicator right"></div>

  <!-- PWA Install Banner -->
  <div class="pwa-install-banner" id="pwaInstallBanner">
    <div class="pwa-install-icon">📱</div>
    <div class="pwa-install-content">
      <div class="pwa-install-title">התקן את האפליקציה</div>
      <div class="pwa-install-subtitle">גישה מהירה מהמסך הראשי</div>
    </div>
    <button class="pwa-install-btn" id="pwaInstallBtn">התקן</button>
    <button class="pwa-install-close" id="pwaInstallClose">×</button>
  </div>

  <script>
    // PWA Install Prompt Handler
    (function () {
      let deferredPrompt = null;
      const banner = document.getElementById('pwaInstallBanner');
      const installBtn = document.getElementById('pwaInstallBtn');
      const closeBtn = document.getElementById('pwaInstallClose');

      const canShowInstallBanner = () => window.matchMedia(
        '(max-width: 768px), (display-mode: standalone) and (max-width: 1024px)'
      ).matches;

      // Check if already installed or dismissed
      const isInstalled = () => window.matchMedia('(display-mode: standalone)').matches
        || window.navigator.standalone === true;

      const wasDismissed = () => {
        const dismissed = localStorage.getItem('pwaInstallDismissed');
        if (!dismissed) return false;
        // Re-show after 7 days
        const dismissedDate = new Date(parseInt(dismissed));
        const now = new Date();
        const daysDiff = (now - dismissedDate) / (1000 * 60 * 60 * 24);
        return daysDiff < 7;
      };

      const showBanner = () => {
        if (!canShowInstallBanner()) return;
        if (banner && deferredPrompt && !isInstalled() && !wasDismissed()) {
          banner.classList.add('visible');
          console.log('[PWA] Install banner shown');
        }
      };

      const hideBanner = () => {
        banner?.classList.remove('visible');
      };

      // Capture the install prompt event
      window.addEventListener('beforeinstallprompt', (e) => {
        if (!canShowInstallBanner()) {
          return;
        }
        e.preventDefault();
        deferredPrompt = e;
        console.log('[PWA] beforeinstallprompt captured');

        // Show banner after a short delay
        setTimeout(showBanner, 2000);
      });

      // Handle install button click
      installBtn?.addEventListener('click', async () => {
        if (!deferredPrompt) return;

        hideBanner();

        // Show the install prompt
        deferredPrompt.prompt();

        const { outcome } = await deferredPrompt.userChoice;
        console.log('[PWA] Install outcome:', outcome);

        if (outcome === 'accepted') {
          if (window.mobileToast) {
            window.mobileToast('האפליקציה הותקנה!', { icon: '✅' });
          }
        }

        deferredPrompt = null;
      });

      // Handle close button
      closeBtn?.addEventListener('click', () => {
        hideBanner();
        localStorage.setItem('pwaInstallDismissed', Date.now().toString());
        console.log('[PWA] Install banner dismissed');
      });

      // Listen for successful install
      window.addEventListener('appinstalled', () => {
        hideBanner();
        deferredPrompt = null;
        console.log('[PWA] App installed successfully');
        if (window.mobileToast) {
          window.mobileToast('האפליקציה הותקנה בהצלחה!', { icon: '🎉' });
        }
      });
    })();
  </script>

  <script>
    // Mobile Bottom Navigation Handler
    (function () {
      const isMobile = () => window.innerWidth <= 768 ||
        (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches && window.innerWidth <= 1024);

      const mobileNav = document.getElementById('mobileBottomNav');
      const navItems = mobileNav.querySelectorAll('.mobile-nav-item');

      // Show/hide mobile nav based on screen size
      const updateMobileNavVisibility = () => {
        if (isMobile()) {
          mobileNav.style.display = 'flex';
        } else {
          mobileNav.style.display = 'none';
        }
      };

      // Initial check
      updateMobileNavVisibility();

      // Update on resize
      window.addEventListener('resize', updateMobileNavVisibility);

      // Handle navigation clicks
      navItems.forEach(item => {
        item.addEventListener('click', () => {
          const view = item.dataset.view;

          // Update active state
          navItems.forEach(i => i.classList.remove('active'));
          item.classList.add('active');

          // Prefer the app's canonical view switcher (keeps tickers + state consistent)
          if (typeof window.showView === 'function') {
            if (view === 'calendar') {
              window.showView('countdown');
              document.getElementById('toggleSidebar')?.click();
            } else {
              window.showView(view);
              document.getElementById('sidebar')?.classList.add('hidden');
            }
            return;
          }
        });
      });

      // Sync with existing header button clicks
      const syncWithHeader = () => {
        const toggleCountdown = document.getElementById('toggleCountdown');
        const toggleTasks = document.getElementById('toggleTasks');
        const togglePomodoro = document.getElementById('togglePomodoro');
        const togglePlanner = document.getElementById('togglePlanner');
        const toggleSidebar = document.getElementById('toggleSidebar');

        const updateNav = (view) => {
          navItems.forEach(item => {
            item.classList.toggle('active', item.dataset.view === view);
          });
        };

        toggleCountdown?.addEventListener('click', () => updateNav('countdown'));
        toggleTasks?.addEventListener('click', () => updateNav('tasks'));
        togglePomodoro?.addEventListener('click', () => updateNav('pomodoro'));
        togglePlanner?.addEventListener('click', () => updateNav('planner'));
        toggleSidebar?.addEventListener('click', () => updateNav('calendar'));

        window.addEventListener('app:viewchange', (e) => {
          const v = e?.detail?.view;
          if (!v) return;
          updateNav(v);
        });
      };

      syncWithHeader();

      // Mobile Task Sidebar Handler
      const taskSidebar = document.getElementById('taskSidebar');
      const toggleTaskSidebarBtn = document.getElementById('toggleTaskSidebar');
      const mobileSidebarBackdrop = document.getElementById('mobileSidebarBackdrop');

      const toggleMobileTaskSidebar = () => {
        if (!isMobile()) return;

        const isOpen = taskSidebar.classList.contains('open');

        if (isOpen) {
          taskSidebar.classList.remove('open');
          mobileSidebarBackdrop.classList.remove('visible');
          toggleTaskSidebarBtn?.classList.remove('active');
        } else {
          taskSidebar.classList.add('open');
          mobileSidebarBackdrop.classList.add('visible');
          toggleTaskSidebarBtn?.classList.add('active');
        }
      };

      toggleTaskSidebarBtn?.addEventListener('click', (e) => {
        if (isMobile()) {
          e.preventDefault();
          e.stopPropagation();
          toggleMobileTaskSidebar();
        }
      });

      mobileSidebarBackdrop?.addEventListener('click', () => {
        if (taskSidebar?.classList.contains('open')) {
          toggleMobileTaskSidebar();
        }
      });

      // Close task sidebar when clicking on a subject/view on mobile
      if (taskSidebar) {
        taskSidebar.addEventListener('click', (e) => {
          if (isMobile() && (e.target.closest('.smart-view-item') || e.target.closest('.subject-list-header'))) {
            setTimeout(() => {
              toggleMobileTaskSidebar();
            }, 200);
          }
        });
      }

      // Mobile Floating Action Button (FAB)
      const mobileFab = document.getElementById('mobileFab');

      const updateFabVisibility = () => {
        if (!mobileFab) return;
        if (isMobile()) {
          mobileFab.style.display = 'flex';
        } else {
          mobileFab.style.display = 'none';
        }
      };


      updateFabVisibility();
      window.addEventListener('resize', updateFabVisibility);

      // ===== Mobile Event Bottom Sheet =====
      const mobileEventSheet = document.getElementById('mobileEventSheet');
      const mobileEventSheetBackdrop = document.getElementById('mobileEventSheetBackdrop');
      const mobileSheetClose = document.getElementById('mobileSheetClose');
      const mobileSheetCancel = document.getElementById('mobileSheetCancel');
      const mobileSheetAdd = document.getElementById('mobileSheetAdd');
      const mobileSheetTitle = document.getElementById('mobileSheetTitle');
      let mobileEditingId = null; // Track if we're editing an event

      function openMobileEventSheet(eventToEdit = null) {
        if (!mobileEventSheet || !mobileEventSheetBackdrop) return;

        const dateInput = document.getElementById('mobileEventDate');
        const nameInput = document.getElementById('mobileEventName');
        const reminderSelect = document.getElementById('mobileEventReminder');
        const notesInput = document.getElementById('mobileEventNotes');

        if (eventToEdit) {
          // Edit mode
          mobileEditingId = eventToEdit.id;
          if (mobileSheetTitle) mobileSheetTitle.textContent = 'עריכת אירוע ✏️';
          if (mobileSheetAdd) mobileSheetAdd.textContent = 'שמור שינויים ✓';
          if (nameInput) nameInput.value = eventToEdit.name || '';
          if (dateInput) dateInput.value = window.ctx?.toLocalDatetime?.(eventToEdit.date) || eventToEdit.date || '';
          if (reminderSelect) reminderSelect.value = String(eventToEdit.reminder || 0);
          if (notesInput) notesInput.value = eventToEdit.notes || '';
        } else {
          // Add mode
          mobileEditingId = null;
          if (mobileSheetTitle) mobileSheetTitle.textContent = 'הוסף אירוע חדש ➕';
          if (mobileSheetAdd) mobileSheetAdd.textContent = 'הוסף אירוע ✓';
          // Set default date to tomorrow at 9:00 AM
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          tomorrow.setHours(9, 0, 0, 0);
          if (dateInput) {
            const year = tomorrow.getFullYear();
            const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
            const day = String(tomorrow.getDate()).padStart(2, '0');
            dateInput.value = `${year}-${month}-${day}T09:00`;
          }
          if (nameInput) nameInput.value = '';
          if (reminderSelect) reminderSelect.value = '0';
          if (notesInput) notesInput.value = '';
        }

        mobileEventSheetBackdrop.classList.add('open');
        mobileEventSheet.classList.add('open');
        document.body.style.overflow = 'hidden';

        // Focus on name input after animation
        setTimeout(() => {
          nameInput?.focus();
        }, 350);
      }

      function closeMobileEventSheet() {
        if (!mobileEventSheet || !mobileEventSheetBackdrop) return;
        mobileEventSheetBackdrop.classList.remove('open');
        mobileEventSheet.classList.remove('open');
        document.body.style.overflow = '';
        mobileEditingId = null; // Reset edit mode
        if (mobileEventSheet) delete mobileEventSheet.dataset.editingId; // Also reset dataset.editingId from startEdit

        // Clear form
        const nameInput = document.getElementById('mobileEventName');
        const notesInput = document.getElementById('mobileEventNotes');
        const reminderSelect = document.getElementById('mobileEventReminder');
        if (nameInput) nameInput.value = '';
        if (notesInput) notesInput.value = '';
        if (reminderSelect) reminderSelect.value = '0';

        // Reset title and button text
        if (mobileSheetTitle) mobileSheetTitle.textContent = 'הוסף אירוע חדש ➕';
        if (mobileSheetAdd) mobileSheetAdd.textContent = 'הוסף אירוע ✓';
      }

      // Close handlers
      mobileSheetClose?.addEventListener('click', closeMobileEventSheet);
      mobileSheetCancel?.addEventListener('click', closeMobileEventSheet);
      mobileEventSheetBackdrop?.addEventListener('click', closeMobileEventSheet);

      // Expose to ctx for cross-script access (used by startEdit for mobile)
      if (window.ctx) {
        window.ctx.openMobileEventSheet = openMobileEventSheet;
        window.ctx.closeMobileEventSheet = closeMobileEventSheet;
      }

      // Add/Edit event handler
      mobileSheetAdd?.addEventListener('click', () => {
        const name = document.getElementById('mobileEventName')?.value?.trim();
        const dateValue = document.getElementById('mobileEventDate')?.value;
        const reminder = document.getElementById('mobileEventReminder')?.value || '0';
        const notes = document.getElementById('mobileEventNotes')?.value?.trim() || '';

        if (!name) {
          document.getElementById('mobileEventName')?.focus();
          return;
        }

        if (!dateValue) {
          document.getElementById('mobileEventDate')?.focus();
          return;
        }

        // Check for edit mode - either from mobileEditingId or from dataset.editingId (set by startEdit)
        const editId = mobileEditingId || mobileEventSheet?.dataset?.editingId;

        if (editId) {
          // Edit mode - update existing event using context
          if (window.ctx && window.ctx.updateInCloud) {
            const existingEvents = window.ctx.events || [];
            const existingEvent = existingEvents.find(e => e.id === editId);
            if (existingEvent) {
              window.ctx.updateInCloud(editId, {
                ...existingEvent,
                name: name,
                date: new Date(dateValue).toISOString(),
                reminder: parseInt(reminder) || null,
                notes: notes
              });
            }
          }
          closeMobileEventSheet();
          return;
        }

        // Add mode - Sync values to the original form inputs and trigger add
        const originalName = document.getElementById('eventName');
        const originalDate = document.getElementById('eventDate');
        const originalReminder = document.getElementById('eventReminder');
        const originalNotes = document.getElementById('eventNotes');
        const addBtn = document.getElementById('addBtn');

        if (originalName) originalName.value = name;
        if (originalDate) originalDate.value = dateValue;
        if (originalReminder) originalReminder.value = reminder;
        if (originalNotes) originalNotes.value = notes;

        // Trigger the existing add event logic
        addBtn?.click();

        // Close the sheet
        closeMobileEventSheet();
      });

      // FAB click handler - context-aware action
      mobileFab?.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent double taps or focus issues
        const activeNavItem = document.querySelector('.mobile-nav-item.active');
        // Default to countdown if detection fails
        const currentView = activeNavItem?.dataset.view || window.currentView || 'countdown';


        switch (currentView) {
          case 'countdown':
            // Open bottom sheet for adding event
            openMobileEventSheet();
            break;
          case 'tasks':
            // Focus on task input
            const taskInput = document.getElementById('newTaskTitle');
            if (taskInput) {
              taskInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
              setTimeout(() => taskInput.focus(), 300);
            }
            break;
          case 'pomodoro':
            // Start/pause pomodoro
            const pomodoroStartBtn = document.querySelector('.pomodoro-btn.primary');
            pomodoroStartBtn?.click();
            break;
          case 'planner':
            // Open planner add task
            const plannerAddBtn = document.querySelector('.planner-add-task-btn');
            plannerAddBtn?.click();
            break;
          case 'calendar':
            // Open bottom sheet for adding event
            openMobileEventSheet();
            break;
          default:
            openMobileEventSheet();
            break;
        }
      });
    })();

  </script>

  <!-- Mobile Enhancements: Swipe Gestures, Haptic Feedback, Toast Notifications -->
  <script type="module">
    import { initMobileController } from './js/controllers/mobile.js';
    initMobileController();
  </script>

</body>

</html>